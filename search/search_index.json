{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Athena Framework was created with the intention of providing various high quality, reusable, and independent components that can be used for things such as serialization, validation, dependency injection, etc. These components can be used on their own within a standalone application, or as a means to \"build\" a framework. The design principles of the Athena Framework take heavy inspiration from various other frameworks including Symfony , and Spring . Athena is the result of integrating these components into one cohesive framework. Feature Overview In regards to other Crystal web frameworks, Athena employs some unique concepts, features, and design principles: Annotations, including user-defined ones, are used to define & configure routes among other things Adheres to the SOLID design principles; basing its dependencies on interfaces, and providing a Dependency Injection Service Container to help manage dependencies/ease testing Event based; allows tapping into various events during the life-cycle of a request Flexible foundation; can make an application as simple or complex as needed, using only the features/components that are needed Resources Gitter Channel API Docs Github Organization Roadmap","title":"Introduction"},{"location":"#feature-overview","text":"In regards to other Crystal web frameworks, Athena employs some unique concepts, features, and design principles: Annotations, including user-defined ones, are used to define & configure routes among other things Adheres to the SOLID design principles; basing its dependencies on interfaces, and providing a Dependency Injection Service Container to help manage dependencies/ease testing Event based; allows tapping into various events during the life-cycle of a request Flexible foundation; can make an application as simple or complex as needed, using only the features/components that are needed","title":"Feature Overview"},{"location":"#resources","text":"Gitter Channel API Docs Github Organization Roadmap","title":"Resources"},{"location":"SUMMARY/","text":"Manual Introduction Getting Started Advanced Usage Components Dependency Injection Event Dispatcher Config Serializer Validator Spec Cookbook Listeners Param Converters Exclusion Strategies Routing DependencyInjection EventDispatcher Config Serializer Validator Spec","title":"SUMMARY"},{"location":"Config/","text":"alias ACF Convenience alias to make referencing Athena::Config types easier. Alias definition Athena::Config Constants CONFIG_PATH_NAME = \"ATHENA_CONFIG_PATH\" The name of the environment variable that stores the path to the configuration file. DEFAULT_CONFIG_PATH = \"./athena.yml\" The default path to the configuration file. module Athena A web framework comprised of reusable, independent components. See Athena Framework on Github. Constants ENV_NAME = \"ATHENA_ENV\" The name of the environment variable used to determine Athena's current environment. Class methods .environment : String Returns the current environment Athena is in based on ENV_NAME . Defaults to development if not defined. module Athena::Config Athena's Config component contains common types for configuring a component. The main types include: ACF::Base represents the structure of Athena's YAML configuration file. ACF::ConfigurationResolver allows resolving the configuration for a given component within a service. ACF::AnnotationConfigurations stores annotation configurations registered via Athena::Config.configuration_annotation . Annotations must be read/supplied to .new by owning shard. See each specific type for more detailed information. Constants CONFIG_PATH_NAME = \"ATHENA_CONFIG_PATH\" The name of the environment variable that stores the path to the configuration file. DEFAULT_CONFIG_PATH = \"./athena.yml\" The default path to the configuration file. Class methods .config Returns the ACF::Base object instantiated from the configuration file located at .config_path . The contents of the configuration file are included into the binary at compile time so that the file itself does not need to be present for the binary to run. The configuration string is not processed until .config is called for the first time so that in the future it will respect ENV vars for the environment the binary is in. TODO: Handle resolving ENV vars and DI parameters within the configuration file. .config_path : String Returns the current path that the configuration file is located at. Falls back on DEFAULT_CONFIG_PATH if a ATHENA_CONFIG_PATH ENV variable is not defined. Macros configuration_annotation Registers a configuration annotation with the provided name . Defines a configuration record with the provided args , if any, that represents the possible arguments that the annotation accepts. May also be used with a block to add custom methods to the configuration record. Example # Defines an annotation without any arguments. ACF . configuration_annotation Secure # Defines annotation with a required and optional argument. # The default value will be used if that key isn't supplied in the annotation. ACF . configuration_annotation SomeAnn , id : Int32 , debug : Bool = true # A block can be used to define custom methods on the configuration object. ACF . configuration_annotation CustomAnn , first_name : String , last_name : String do def name : String \" #{ @first_name } #{ @last_name } \" end end NOTE: The logic to actually do the resolution of the annotations must be handled in the owning shard. Athena::Config only defines the common logic that each implementation can use. See ACF::AnnotationConfigurations for more information.","title":"Config"},{"location":"Config/#ACF","text":"Convenience alias to make referencing Athena::Config types easier.","title":"ACF"},{"location":"Config/#alias-definition","text":"Athena::Config","title":"Alias definition"},{"location":"Config/#constants","text":"","title":"Constants"},{"location":"Config/#ACF::CONFIG_PATH_NAME","text":"The name of the environment variable that stores the path to the configuration file.","title":"CONFIG_PATH_NAME"},{"location":"Config/#ACF::DEFAULT_CONFIG_PATH","text":"The default path to the configuration file.","title":"DEFAULT_CONFIG_PATH"},{"location":"Config/#Athena","text":"A web framework comprised of reusable, independent components. See Athena Framework on Github.","title":"Athena"},{"location":"Config/#constants_1","text":"","title":"Constants"},{"location":"Config/#Athena::ENV_NAME","text":"The name of the environment variable used to determine Athena's current environment.","title":"ENV_NAME"},{"location":"Config/#class-methods","text":"","title":"Class methods"},{"location":"Config/#Athena.environment()","text":"Returns the current environment Athena is in based on ENV_NAME . Defaults to development if not defined.","title":".environment"},{"location":"Config/#Athena::Config","text":"Athena's Config component contains common types for configuring a component. The main types include: ACF::Base represents the structure of Athena's YAML configuration file. ACF::ConfigurationResolver allows resolving the configuration for a given component within a service. ACF::AnnotationConfigurations stores annotation configurations registered via Athena::Config.configuration_annotation . Annotations must be read/supplied to .new by owning shard. See each specific type for more detailed information.","title":"Config"},{"location":"Config/#constants_2","text":"","title":"Constants"},{"location":"Config/#Athena::Config::CONFIG_PATH_NAME","text":"The name of the environment variable that stores the path to the configuration file.","title":"CONFIG_PATH_NAME"},{"location":"Config/#Athena::Config::DEFAULT_CONFIG_PATH","text":"The default path to the configuration file.","title":"DEFAULT_CONFIG_PATH"},{"location":"Config/#class-methods_1","text":"","title":"Class methods"},{"location":"Config/#Athena::Config.config()","text":"Returns the ACF::Base object instantiated from the configuration file located at .config_path . The contents of the configuration file are included into the binary at compile time so that the file itself does not need to be present for the binary to run. The configuration string is not processed until .config is called for the first time so that in the future it will respect ENV vars for the environment the binary is in. TODO: Handle resolving ENV vars and DI parameters within the configuration file.","title":".config"},{"location":"Config/#Athena::Config.config_path()","text":"Returns the current path that the configuration file is located at. Falls back on DEFAULT_CONFIG_PATH if a ATHENA_CONFIG_PATH ENV variable is not defined.","title":".config_path"},{"location":"Config/#macros","text":"","title":"Macros"},{"location":"Config/#Athena::Config:configuration_annotation(name,*args,&)","text":"Registers a configuration annotation with the provided name . Defines a configuration record with the provided args , if any, that represents the possible arguments that the annotation accepts. May also be used with a block to add custom methods to the configuration record.","title":"configuration_annotation"},{"location":"Config/#Athena::Config:configuration_annotation(name,*args,&)--example","text":"# Defines an annotation without any arguments. ACF . configuration_annotation Secure # Defines annotation with a required and optional argument. # The default value will be used if that key isn't supplied in the annotation. ACF . configuration_annotation SomeAnn , id : Int32 , debug : Bool = true # A block can be used to define custom methods on the configuration object. ACF . configuration_annotation CustomAnn , first_name : String , last_name : String do def name : String \" #{ @first_name } #{ @last_name } \" end end NOTE: The logic to actually do the resolution of the annotations must be handled in the owning shard. Athena::Config only defines the common logic that each implementation can use. See ACF::AnnotationConfigurations for more information.","title":"Example"},{"location":"Config/AnnotationConfigurations/","text":"struct Athena::Config::AnnotationConfigurations inherits Struct Wraps a hash of configuration annotations applied to a given type, method, or instance variable. Provides the logic to access each annotation's configuration in a type safe manner. Implementations using this type must define the logic to provide the annotation hash manually; this would most likely just be something like: # Define a hash to store the configurations. {% custom_configurations = {} of Nil => Nil %} # Iterate over the stored annotation classes. {% for ann_class in ACF :: CUSTOM_ANNOTATIONS %} {% ann_class = ann_class . resolve %} # Define an array to store the annotation configurations of this type. {% annotations = [] of Nil %} # Iterate over each annotation of this type on the given type, method, or instance variable. {% for ann in type_method_instance_variable . annotations ann_class %} # Add a new instance of the annotations configuration to the array. # Add the annotation's positional arguments first, if any, then named arguments. {% annotations << \" #{ ann_class } Configuration.new( #{ ann . args . empty? ? \"\" . id : \" #{ ann . args . splat } ,\" . id }#{ ann . named_args . double_splat } )\" . id %} {% end %} # Update the configuration hash with the annotation class and configuration objects, but only if there was at least one. {% custom_configurations [ ann_class ] = \"( #{ annotations } of ACF::AnnotationConfigurations::ConfigurationBase)\" . id unless annotations . empty? %} {% end %} # ... # Use the built hash to instantiate a new `ACF::AnnotationConfigurations` instance. ACF :: AnnotationConfigurations . new ( {{ custom_configurations }} of ACF :: AnnotationConfigurations :: Classes => Array ( ACF :: AnnotationConfigurations :: ConfigurationBase )), TODO: Centralize the hash resolution logic once this issue is resolved. Class methods .new ( annotation_hash : AnnotationHash = AnnotationHash . new ) Methods #has? ( ann_class : ACF::AnnotationConfigurations::Classes ) : Bool Returns true if there are annotations of the provided ann_class , otherwise false .","title":"AnnotationConfigurations"},{"location":"Config/AnnotationConfigurations/#Athena::Config::AnnotationConfigurations","text":"Wraps a hash of configuration annotations applied to a given type, method, or instance variable. Provides the logic to access each annotation's configuration in a type safe manner. Implementations using this type must define the logic to provide the annotation hash manually; this would most likely just be something like: # Define a hash to store the configurations. {% custom_configurations = {} of Nil => Nil %} # Iterate over the stored annotation classes. {% for ann_class in ACF :: CUSTOM_ANNOTATIONS %} {% ann_class = ann_class . resolve %} # Define an array to store the annotation configurations of this type. {% annotations = [] of Nil %} # Iterate over each annotation of this type on the given type, method, or instance variable. {% for ann in type_method_instance_variable . annotations ann_class %} # Add a new instance of the annotations configuration to the array. # Add the annotation's positional arguments first, if any, then named arguments. {% annotations << \" #{ ann_class } Configuration.new( #{ ann . args . empty? ? \"\" . id : \" #{ ann . args . splat } ,\" . id }#{ ann . named_args . double_splat } )\" . id %} {% end %} # Update the configuration hash with the annotation class and configuration objects, but only if there was at least one. {% custom_configurations [ ann_class ] = \"( #{ annotations } of ACF::AnnotationConfigurations::ConfigurationBase)\" . id unless annotations . empty? %} {% end %} # ... # Use the built hash to instantiate a new `ACF::AnnotationConfigurations` instance. ACF :: AnnotationConfigurations . new ( {{ custom_configurations }} of ACF :: AnnotationConfigurations :: Classes => Array ( ACF :: AnnotationConfigurations :: ConfigurationBase )), TODO: Centralize the hash resolution logic once this issue is resolved.","title":"AnnotationConfigurations"},{"location":"Config/AnnotationConfigurations/#class-methods","text":"","title":"Class methods"},{"location":"Config/AnnotationConfigurations/#Athena::Config::AnnotationConfigurations.new(annotation_hash)","text":"","title":".new"},{"location":"Config/AnnotationConfigurations/#methods","text":"","title":"Methods"},{"location":"Config/AnnotationConfigurations/#Athena::Config::AnnotationConfigurations#has?(ann_class)","text":"Returns true if there are annotations of the provided ann_class , otherwise false .","title":"#has?"},{"location":"Config/AnnotationConfigurations/AnnotationHash/","text":"alias Athena::Config::AnnotationConfigurations::AnnotationHash The Hash type that will store the annotation configurations. Alias definition Hash ( Athena :: Config :: AnnotationConfigurations :: Placeholder . class , Array ( Athena::Config::AnnotationConfigurations::ConfigurationBase ))","title":"AnnotationHash"},{"location":"Config/AnnotationConfigurations/AnnotationHash/#Athena::Config::AnnotationConfigurations::AnnotationHash","text":"The Hash type that will store the annotation configurations.","title":"AnnotationHash"},{"location":"Config/AnnotationConfigurations/AnnotationHash/#alias-definition","text":"Hash ( Athena :: Config :: AnnotationConfigurations :: Placeholder . class , Array ( Athena::Config::AnnotationConfigurations::ConfigurationBase ))","title":"Alias definition"},{"location":"Config/AnnotationConfigurations/Classes/","text":"alias Athena::Config::AnnotationConfigurations::Classes A union representing the possible annotation classes that could be applied to a type, method, or instance variable. Alias definition Athena :: Config :: AnnotationConfigurations :: Placeholder . class","title":"Classes"},{"location":"Config/AnnotationConfigurations/Classes/#Athena::Config::AnnotationConfigurations::Classes","text":"A union representing the possible annotation classes that could be applied to a type, method, or instance variable.","title":"Classes"},{"location":"Config/AnnotationConfigurations/Classes/#alias-definition","text":"Athena :: Config :: AnnotationConfigurations :: Placeholder . class","title":"Alias definition"},{"location":"Config/AnnotationConfigurations/ConfigurationBase/","text":"abstract struct Athena::Config::AnnotationConfigurations::ConfigurationBase inherits Struct Base type of annotation configuration objects registered via Athena::Config.configuration_annotation . Class methods .new","title":"ConfigurationBase"},{"location":"Config/AnnotationConfigurations/ConfigurationBase/#Athena::Config::AnnotationConfigurations::ConfigurationBase","text":"Base type of annotation configuration objects registered via Athena::Config.configuration_annotation .","title":"ConfigurationBase"},{"location":"Config/AnnotationConfigurations/ConfigurationBase/#class-methods","text":"","title":"Class methods"},{"location":"Config/AnnotationConfigurations/ConfigurationBase/#Athena::Config::AnnotationConfigurations::ConfigurationBase.new()","text":"","title":".new"},{"location":"Config/Base/","text":"struct Athena::Config::Base inherits Struct Base config type that wraps the Athena configuration file. Components may add their own ACF::Configuration types to self to allow configuring that specific component. # Define a custom configuration type. # Additional configuration types may be nested. struct SomeConfig include ACF :: Configuration # Defines a required configuration property. # Optional properties can be made nilable or given a default value. getter api_key : String end # Reopen the base type to add our custom configuration type. struct Athena::Config:: Base getter some_config : SomeConfig end ACF::Base 's YAML representation now looks like: --- some_config : api_key : API_KEY Included modules Athena::Config::Configuration YAML::Serializable YAML::Serializable::Strict Class methods .new ( ctx : YAML :: ParseContext , node : YAML :: Nodes :: Node ) .new Methods #routing : Athena::Routing::Config All configuration related to the ART component.","title":"Base"},{"location":"Config/Base/#Athena::Config::Base","text":"Base config type that wraps the Athena configuration file. Components may add their own ACF::Configuration types to self to allow configuring that specific component. # Define a custom configuration type. # Additional configuration types may be nested. struct SomeConfig include ACF :: Configuration # Defines a required configuration property. # Optional properties can be made nilable or given a default value. getter api_key : String end # Reopen the base type to add our custom configuration type. struct Athena::Config:: Base getter some_config : SomeConfig end ACF::Base 's YAML representation now looks like: --- some_config : api_key : API_KEY","title":"Base"},{"location":"Config/Base/#included-modules","text":"Athena::Config::Configuration YAML::Serializable YAML::Serializable::Strict","title":"Included modules"},{"location":"Config/Base/#class-methods","text":"","title":"Class methods"},{"location":"Config/Base/#Athena::Config::Base.new(ctx,node)","text":"","title":".new"},{"location":"Config/Base/#methods","text":"","title":"Methods"},{"location":"Config/Base/#Athena::Config::Base#routing()","text":"All configuration related to the ART component.","title":"#routing"},{"location":"Config/Configuration/","text":"module Athena::Config::Configuration Helper mixin that includes the modules and defines the methods required for a configuration. Includes YAML::Serializable for handling deserializing the configuration file into a ACF::Base and YAML::Serializable::Strict to prevent unused/undefined configurations within the file. See ACF::Base for more information on defining custom configuration types. Direct including types Athena::Config::Base Athena::Routing::Config Athena::Routing::Config::CORS","title":"Configuration"},{"location":"Config/Configuration/#Athena::Config::Configuration","text":"Helper mixin that includes the modules and defines the methods required for a configuration. Includes YAML::Serializable for handling deserializing the configuration file into a ACF::Base and YAML::Serializable::Strict to prevent unused/undefined configurations within the file. See ACF::Base for more information on defining custom configuration types.","title":"Configuration"},{"location":"Config/Configuration/#direct-including-types","text":"Athena::Config::Base Athena::Routing::Config Athena::Routing::Config::CORS","title":"Direct including types"},{"location":"Config/ConfigurationResolver/","text":"struct Athena::Config::ConfigurationResolver inherits Struct See Athena::Config::ConfigurationResolverInterface . Included modules Athena::Config::ConfigurationResolverInterface Class methods .new Methods #resolve ( _type : Athena :: Routing :: Config :: CORS . class ) : ART::Config::CORS ? :inherit: #resolve ( _type : _ ) Resolves the configuration object for the given _type . Raises a NotImplementedError if no #resolve method exists for the given _type . #resolve : ACF::Base Returns the ACF::Base configuration object.","title":"ConfigurationResolver"},{"location":"Config/ConfigurationResolver/#Athena::Config::ConfigurationResolver","text":"See Athena::Config::ConfigurationResolverInterface .","title":"ConfigurationResolver"},{"location":"Config/ConfigurationResolver/#included-modules","text":"Athena::Config::ConfigurationResolverInterface","title":"Included modules"},{"location":"Config/ConfigurationResolver/#class-methods","text":"","title":"Class methods"},{"location":"Config/ConfigurationResolver/#Athena::Config::ConfigurationResolver.new()","text":"","title":".new"},{"location":"Config/ConfigurationResolver/#methods","text":"","title":"Methods"},{"location":"Config/ConfigurationResolver/#Athena::Config::ConfigurationResolver#resolve(_type)","text":":inherit:","title":"#resolve"},{"location":"Config/ConfigurationResolver/#Athena::Config::ConfigurationResolver#resolve(_type)","text":"Resolves the configuration object for the given _type . Raises a NotImplementedError if no #resolve method exists for the given _type .","title":"#resolve"},{"location":"Config/ConfigurationResolverInterface/","text":"module Athena::Config::ConfigurationResolverInterface A type that allows resolving a specific configuration object by type. Can be reopened to be made into a service to allow resolving configurations within other services. Component configurations that should be resolvable must reopen self and add a #resolve method with a type restriction thats returns the desired configuration. # Define a custom configuration type. # Additional configuration types may be nested. struct SomeConfig include ACF :: Configuration # Defines a required configuration property. # Optional properties can be made nilable or given a default value. getter api_key : String end # Reopen ACF::Base to add our custom configuration type. struct Athena::Config:: Base getter some_config : SomeConfig end # Reopen ConfigurationResolver to add a method that allows resolving the `SomeConfig` object. # # Attempting to resolve a configuration type that has not been added will result in a `NotImplementedError`. struct Athena::Config:: ConfigurationResolver # :inherit: def resolve ( _type : SomeConfig . class ) : SomeConfig # A private `#base` helper method is defined which returns the `ACF::Base` instance. base . some_config end end # Assuming the YAML configuration file looks like: # --- # some_config: # api_key: API_KEY ACF :: ConfigurationResolver . new . resolve ( SomeConfig ) . api_key # => API_KEY Direct including types Athena::Config::ConfigurationResolver Methods abstract #resolve ( _type : _ ) Resolves the configuration object for the given _type . Raises a NotImplementedError if no #resolve method exists for the given _type . abstract #resolve : ACF::Base Returns the ACF::Base configuration object.","title":"ConfigurationResolverInterface"},{"location":"Config/ConfigurationResolverInterface/#Athena::Config::ConfigurationResolverInterface","text":"A type that allows resolving a specific configuration object by type. Can be reopened to be made into a service to allow resolving configurations within other services. Component configurations that should be resolvable must reopen self and add a #resolve method with a type restriction thats returns the desired configuration. # Define a custom configuration type. # Additional configuration types may be nested. struct SomeConfig include ACF :: Configuration # Defines a required configuration property. # Optional properties can be made nilable or given a default value. getter api_key : String end # Reopen ACF::Base to add our custom configuration type. struct Athena::Config:: Base getter some_config : SomeConfig end # Reopen ConfigurationResolver to add a method that allows resolving the `SomeConfig` object. # # Attempting to resolve a configuration type that has not been added will result in a `NotImplementedError`. struct Athena::Config:: ConfigurationResolver # :inherit: def resolve ( _type : SomeConfig . class ) : SomeConfig # A private `#base` helper method is defined which returns the `ACF::Base` instance. base . some_config end end # Assuming the YAML configuration file looks like: # --- # some_config: # api_key: API_KEY ACF :: ConfigurationResolver . new . resolve ( SomeConfig ) . api_key # => API_KEY","title":"ConfigurationResolverInterface"},{"location":"Config/ConfigurationResolverInterface/#direct-including-types","text":"Athena::Config::ConfigurationResolver","title":"Direct including types"},{"location":"Config/ConfigurationResolverInterface/#methods","text":"","title":"Methods"},{"location":"Config/ConfigurationResolverInterface/#Athena::Config::ConfigurationResolverInterface#resolve(_type)","text":"Resolves the configuration object for the given _type . Raises a NotImplementedError if no #resolve method exists for the given _type .","title":"#resolve"},{"location":"DependencyInjection/","text":"alias ADI Convenience alias to make referencing Athena::DependencyInjection types easier. Alias definition Athena::DependencyInjection module Athena::DependencyInjection Athena's Dependency Injection (DI) component, ADI for short, adds a service container layer to your project. This allows useful objects, aka services, to be shared throughout the project. These objects live in a special class called the ADI::ServiceContainer (SC). The SC is lazily initialized on fibers; this allows the SC to be accessed anywhere within the project. The Athena::DependencyInjection.container method will return the SC for the current fiber. Since the SC is defined on fibers, it allows for each fiber to have its own SC instance. This can be useful for web frameworks as each request would have its own SC scoped to that request. See ADI::Register for documentation on registering services. NOTE: It is highly recommended to use interfaces as opposed to concrete types when defining the initializers for both services and non-services. Using interfaces allows changing the functionality of a type by just changing what service gets injected into it, such as via an alias. See this blog post for an example of this. Class methods .container : ADI::ServiceContainer Returns the ADI::ServiceContainer for the current fiber. Macros auto_configure ( type , options ) Applies the provided options to any registered service of the provided type . A common use case of this would be to apply a specific tag to all instances of an interface; thus preventing the need to manually apply the tag for each implementation. This can be paired with Athena::DependencyInjection.bind to make working with tags easier. It can also be used to set the public and lazy options. Example module ConfigInterface ; end # Automatically apply the `\"config\"` tag to all instances of `ConfigInterface`. ADI . auto_configure ConfigInterface , { tags : [ \"config\" ] } @[ ADI :: Register ] record ConfigOne do include ConfigInterface end @[ ADI :: Register ] record ConfigTwo do include ConfigInterface end # Options supplied on the annotation itself override the auto configured options. @[ ADI :: Register ( tags : [] of String ) ] record ConfigThree do include ConfigInterface end @[ ADI :: Register ( _configs : \"!config\" , public : true ) ] record ConfigClient , configs : Array ( ConfigInterface ) ADI . container . config_client . configs # => [ConfigOne(), ConfigTwo()] bind ( key , value ) Allows binding a value to a key in order to enable auto registration of that value. Bindings allow scalar values, or those that could not otherwise be handled via service aliases , to be auto registered. This allows those arguments to be defined once and reused, as opposed to using named arguments to manually specify them for each service. Bindings can also be declared with a type restriction to allow taking the type restriction of the argument into account. Typed bindings are always checked first as the most specific type is always preferred. If no typed bindings match the argument's type, then the last defined untyped bindings is used. Example module ValueInterface ; end @[ ADI :: Register ( _value : 1 , name : \"value_one\" ) ] @[ ADI :: Register ( _value : 2 , name : \"value_two\" ) ] @[ ADI :: Register ( _value : 3 , name : \"value_three\" ) ] record ValueService , value : Int32 do include ValueInterface end # Untyped bindings ADI . bind api_key , ENV [ \"API_KEY\" ] ADI . bind config , { id : 12_i64 , active : true } ADI . bind static_value , 123 ADI . bind odd_values , [ \"@value_one\" , \"@value_three\" ] ADI . bind value_arr , [ true , true , false ] # Typed bindings ADI . bind value_arr : Array ( Int32 ), [ 1 , 2 , 3 ] ADI . bind value_arr : Array ( Float64 ), [ 1.0 , 2.0 , 3.0 ] @[ ADI :: Register ( public : true ) ] record BindingClient , api_key : String , config : NamedTuple ( id : Int64 , active : Bool ), static_value : Int32 , odd_values : Array ( ValueInterface ) @[ ADI :: Register ( public : true ) ] record IntArr , value_arr : Array ( Int32 ) @[ ADI :: Register ( public : true ) ] record FloatArr , value_arr : Array ( Float64 ) @[ ADI :: Register ( public : true ) ] record BoolArr , value_arr : Array ( Bool ) ADI . container . binding_client # => # BindingClient( # @api_key=\"123ABC\", # @config={id: 12, active: true}, # @static_value=123, # @odd_values=[ValueService(@value=1), ValueService(@value=3)]) ADI . container . int_arr # => IntArr(@value_arr=[1, 2, 3]) ADI . container . float_arr # => FloatArr(@value_arr=[1.0, 2.0, 3.0]) ADI . container . bool_arr # => BoolArr(@value_arr=[true, true, false])","title":"DependencyInjection"},{"location":"DependencyInjection/#ADI","text":"Convenience alias to make referencing Athena::DependencyInjection types easier.","title":"ADI"},{"location":"DependencyInjection/#alias-definition","text":"Athena::DependencyInjection","title":"Alias definition"},{"location":"DependencyInjection/#Athena::DependencyInjection","text":"Athena's Dependency Injection (DI) component, ADI for short, adds a service container layer to your project. This allows useful objects, aka services, to be shared throughout the project. These objects live in a special class called the ADI::ServiceContainer (SC). The SC is lazily initialized on fibers; this allows the SC to be accessed anywhere within the project. The Athena::DependencyInjection.container method will return the SC for the current fiber. Since the SC is defined on fibers, it allows for each fiber to have its own SC instance. This can be useful for web frameworks as each request would have its own SC scoped to that request. See ADI::Register for documentation on registering services. NOTE: It is highly recommended to use interfaces as opposed to concrete types when defining the initializers for both services and non-services. Using interfaces allows changing the functionality of a type by just changing what service gets injected into it, such as via an alias. See this blog post for an example of this.","title":"DependencyInjection"},{"location":"DependencyInjection/#class-methods","text":"","title":"Class methods"},{"location":"DependencyInjection/#Athena::DependencyInjection.container()","text":"Returns the ADI::ServiceContainer for the current fiber.","title":".container"},{"location":"DependencyInjection/#macros","text":"","title":"Macros"},{"location":"DependencyInjection/#Athena::DependencyInjection:auto_configure(type,options)","text":"Applies the provided options to any registered service of the provided type . A common use case of this would be to apply a specific tag to all instances of an interface; thus preventing the need to manually apply the tag for each implementation. This can be paired with Athena::DependencyInjection.bind to make working with tags easier. It can also be used to set the public and lazy options.","title":"auto_configure"},{"location":"DependencyInjection/#Athena::DependencyInjection:auto_configure(type,options)--example","text":"module ConfigInterface ; end # Automatically apply the `\"config\"` tag to all instances of `ConfigInterface`. ADI . auto_configure ConfigInterface , { tags : [ \"config\" ] } @[ ADI :: Register ] record ConfigOne do include ConfigInterface end @[ ADI :: Register ] record ConfigTwo do include ConfigInterface end # Options supplied on the annotation itself override the auto configured options. @[ ADI :: Register ( tags : [] of String ) ] record ConfigThree do include ConfigInterface end @[ ADI :: Register ( _configs : \"!config\" , public : true ) ] record ConfigClient , configs : Array ( ConfigInterface ) ADI . container . config_client . configs # => [ConfigOne(), ConfigTwo()]","title":"Example"},{"location":"DependencyInjection/#Athena::DependencyInjection:bind(key,value)","text":"Allows binding a value to a key in order to enable auto registration of that value. Bindings allow scalar values, or those that could not otherwise be handled via service aliases , to be auto registered. This allows those arguments to be defined once and reused, as opposed to using named arguments to manually specify them for each service. Bindings can also be declared with a type restriction to allow taking the type restriction of the argument into account. Typed bindings are always checked first as the most specific type is always preferred. If no typed bindings match the argument's type, then the last defined untyped bindings is used.","title":"bind"},{"location":"DependencyInjection/#Athena::DependencyInjection:bind(key,value)--example","text":"module ValueInterface ; end @[ ADI :: Register ( _value : 1 , name : \"value_one\" ) ] @[ ADI :: Register ( _value : 2 , name : \"value_two\" ) ] @[ ADI :: Register ( _value : 3 , name : \"value_three\" ) ] record ValueService , value : Int32 do include ValueInterface end # Untyped bindings ADI . bind api_key , ENV [ \"API_KEY\" ] ADI . bind config , { id : 12_i64 , active : true } ADI . bind static_value , 123 ADI . bind odd_values , [ \"@value_one\" , \"@value_three\" ] ADI . bind value_arr , [ true , true , false ] # Typed bindings ADI . bind value_arr : Array ( Int32 ), [ 1 , 2 , 3 ] ADI . bind value_arr : Array ( Float64 ), [ 1.0 , 2.0 , 3.0 ] @[ ADI :: Register ( public : true ) ] record BindingClient , api_key : String , config : NamedTuple ( id : Int64 , active : Bool ), static_value : Int32 , odd_values : Array ( ValueInterface ) @[ ADI :: Register ( public : true ) ] record IntArr , value_arr : Array ( Int32 ) @[ ADI :: Register ( public : true ) ] record FloatArr , value_arr : Array ( Float64 ) @[ ADI :: Register ( public : true ) ] record BoolArr , value_arr : Array ( Bool ) ADI . container . binding_client # => # BindingClient( # @api_key=\"123ABC\", # @config={id: 12, active: true}, # @static_value=123, # @odd_values=[ValueService(@value=1), ValueService(@value=3)]) ADI . container . int_arr # => IntArr(@value_arr=[1, 2, 3]) ADI . container . float_arr # => FloatArr(@value_arr=[1.0, 2.0, 3.0]) ADI . container . bool_arr # => BoolArr(@value_arr=[true, true, false])","title":"Example"},{"location":"DependencyInjection/Inject/","text":"annotation Athena::DependencyInjection::Inject Specifies which constructor should be used for injection. @[ ADI :: Register ( _value : 2 , public : true ) ] class SomeService @active : Bool = false def initialize ( value : String , @active : Bool ) @value = value . to_i end @[ ADI :: Inject ] def initialize ( @value : Int32 ); end end ADI . container . some_service # => #<SomeService:0x7f51a77b1eb0 @active=false, @value=2> SomeService . new \"1\" , true # => #<SomeService:0x7f51a77b1e90 @active=true, @value=1> Without the ADI::Inject annotation, the first initializer would be used, which would fail since we are not providing a value for the active argument. ADI::Inject allows telling the service container that it should use the second constructor when registering this service. This allows a constructor overload specific to DI to be used while still allowing the type to be used outside of DI via other constructors.","title":"Inject"},{"location":"DependencyInjection/Inject/#Athena::DependencyInjection::Inject","text":"Specifies which constructor should be used for injection. @[ ADI :: Register ( _value : 2 , public : true ) ] class SomeService @active : Bool = false def initialize ( value : String , @active : Bool ) @value = value . to_i end @[ ADI :: Inject ] def initialize ( @value : Int32 ); end end ADI . container . some_service # => #<SomeService:0x7f51a77b1eb0 @active=false, @value=2> SomeService . new \"1\" , true # => #<SomeService:0x7f51a77b1e90 @active=true, @value=1> Without the ADI::Inject annotation, the first initializer would be used, which would fail since we are not providing a value for the active argument. ADI::Inject allows telling the service container that it should use the second constructor when registering this service. This allows a constructor overload specific to DI to be used while still allowing the type to be used outside of DI via other constructors.","title":"Inject"},{"location":"DependencyInjection/Register/","text":"annotation Athena::DependencyInjection::Register Registers a service based on the type the annotation is applied to. The type of the service affects how it behaves within the container. When a struct service is retrieved or injected into a type, it will be a copy of the one in the SC (passed by value). This means that changes made to it in one type, will NOT be reflected in other types. A class service on the other hand will be a reference to the one in the SC. This allows it to share state between services. Optional Arguments In most cases, the annotation can be applied without additional arguments. However, the annotation accepts a handful of optional arguments to fine tune how the service is registered. name : String - The name of the service. Should be unique. Defaults to the type's FQN snake cased. public : Bool - If the service should be directly accessible from the container. Defaults to false . public_alias : Bool - If a service should be directly accessible from the container via an alias. Defaults to false . lazy : Bool - If the service should be lazily instantiated. I.e. only instantiated when it is first accessed; either directly or as a dependency of another service. Defaults to true . alias : T - Injects self when this type is used as a type restriction. See the Aliasing Services example for more information. tags : Array(String | NamedTuple(name: String, priority: Int32?)) - Tags that should be assigned to the service. Defaults to an empty array. See the Tagging Services example for more information. type : T - The type of the service within the container. Defaults to service's types. See the Customizing Service's Type section. factory : String | Tuple(T, String) - Use a factory type/method to create the service. See the Factories section. Examples Basic Usage The simplest usage involves only applying the ADI::Register annotation to a type. If the type does not have any arguments, then it is simply registered as a service as is. If the type does have arguments, then an attempt is made to register the service by automatically resolving dependencies based on type restrictions. @[ ADI :: Register ] # Register a service without any dependencies. struct ShoutTransformer def transform ( value : String ) : String value . upcase end end @[ ADI :: Register ( public : true ) ] # The ShoutTransformer is injected based on the type restriction of the `transformer` argument. struct SomeAPIClient def initialize ( @transformer : ShoutTransformer ); end def send ( message : String ) message = @transformer . transform message # ... end end ADI . container . some_api_client . send \"foo\" # => FOO Aliasing Services An important part of DI is building against interfaces as opposed to concrete types. This allows a type to depend upon abstractions rather than a specific implementation of the interface. Or in other words, prevents a singular implementation from being tightly coupled with another type. We can use the alias argument when registering a service to tell the container that it should inject this service when a type restriction for the aliased service is found. # Define an interface for our services to use. module TransformerInterface abstract def transform ( value : String ) : String end @[ ADI :: Register ( alias : TransformerInterface ) ] # Alias the `TransformerInterface` to this service. struct ShoutTransformer include TransformerInterface def transform ( value : String ) : String value . upcase end end @[ ADI :: Register ] # Define another transformer type. struct ReverseTransformer include TransformerInterface def transform ( value : String ) : String value . reverse end end @[ ADI :: Register ( public : true ) ] # The `ShoutTransformer` is injected because the `TransformerInterface` is aliased to the `ShoutTransformer`. struct SomeAPIClient def initialize ( @transformer : TransformerInterface ); end def send ( message : String ) message = @transformer . transform message # ... end end ADI . container . some_api_client . send \"foo\" # => FOO Any service that uses TransformerInterface as a dependency type restriction will get the ShoutTransformer . However, it is also possible to use a specific implementation while still building against the interface. The name of the constructor argument is used in part to resolve the dependency. @[ ADI :: Register ( public : true ) ] # The `ReverseTransformer` is injected because the constructor argument's name matches the service name of `ReverseTransformer`. struct SomeAPIClient def initialize ( reverse_transformer : TransformerInterface ) @transformer = reverse_transformer end def send ( message : String ) message = @transformer . transform message # ... end end ADI . container . some_api_client . send \"foo\" # => oof Scalar Arguments The auto registration logic as shown in previous examples only works on service dependencies. Scalar arguments, such as Arrays, Strings, NamedTuples, etc, must be defined manually. This is achieved by using the argument's name prefixed with a _ symbol as named arguments within the annotation. @[ ADI :: Register ( _shell : ENV [ \"SHELL\" ] , _config : { id : 12_i64 , active : true }, public : true ) ] struct ScalarClient def initialize ( @shell : String , @config : NamedTuple ( id : Int64 , active : Bool )); end end ADI . container . scalar_client # => ScalarClient(@config={id: 12, active: true}, @shell=\"/bin/bash\") Arrays can also include references to services by prefixing the name of the service with an @ symbol. module Interface ; end @[ ADI :: Register ] struct One include Interface end @[ ADI :: Register ] struct Two include Interface end @[ ADI :: Register ] struct Three include Interface end @[ ADI :: Register ( _services : [ \"@one\" , \"@three\" ] , public : true ) ] struct ArrayClient def initialize ( @services : Array ( Interface )); end end ADI . container . array_client # => ArrayClient(@services=[One(), Three()]) While scalar arguments cannot be auto registered by default, the Athena::DependencyInjection.bind macro can be used to support it. For example: ADI.bind shell, \"bash\" . This would now inject the string \"bash\" whenever an argument named shell is encountered. Tagging Services Services can also be tagged. Service tags allows another service to have all services with a specific tag injected as a dependency. A tag consists of a name, and additional metadata related to the tag. Currently the only supported metadata value is priority , which controls the order in which the services are injected; the higher the priority the sooner in the array it would be. In the future support for custom tag metadata will be implemented. The Athena::DependencyInjection.auto_configure macro may also be used to make working with tags easier. PARTNER_TAG = \"partner\" @[ ADI :: Register ( _id : 1 , name : \"google\" , tags : [ { name : PARTNER_TAG , priority : 5 } ] ) ] @[ ADI :: Register ( _id : 2 , name : \"facebook\" , tags : [ PARTNER_TAG ] ) ] @[ ADI :: Register ( _id : 3 , name : \"yahoo\" , tags : [ { name : \"partner\" , priority : 10 } ] ) ] @[ ADI :: Register ( _id : 4 , name : \"microsoft\" , tags : [ PARTNER_TAG ] ) ] # Register multiple services based on the same type. Each service must give define a unique name. record FeedPartner , id : Int32 @[ ADI :: Register ( _services : \"!partner\" , public : true ) ] # Inject all services with the `\"partner\"` tag into `self`. class PartnerClient def initialize ( @services : Array ( FeedPartner )); end end ADI . container . partner_client # => # #<PartnerClient:0x7f43c0a1ae60 # @services= # [FeedPartner(@id=3, @name=\"Yahoo\"), # FeedPartner(@id=1, @name=\"Google\"), # FeedPartner(@id=2, @name=\"Facebook\"), # FeedPartner(@id=4, @name=\"Microsoft\")]> While tagged services cannot be injected automatically by default, the Athena::DependencyInjection.bind macro can be used to support it. For example: ADI.bind partners, \"!partner\" . This would now inject all services with the partner tagged when an argument named partners is encountered. A type restriction can also be added to the binding to allow reusing the name. See the documentation for Athena::DependencyInjection.bind for an example. Optional Services Services defined with a nillable type restriction are considered to be optional. If no service could be resolved from the type, then nil is injected instead. Similarly, if the argument has a default value, that value would be used instead. struct OptionalMissingService end @[ ADI :: Register ] struct OptionalExistingService end @[ ADI :: Register ( public : true ) ] class OptionalClient getter service_missing , service_existing , service_default def initialize ( @service_missing : OptionalMissingService? , @service_existing : OptionalExistingService? , @service_default : OptionalMissingService | Int32 | Nil = 12 ); end end ADI . container . optional_client # #<OptionalClient:0x7fe7de7cdf40 # @service_default=12, # @service_existing=OptionalExistingService(), # @service_missing=nil> Generic Services Generic arguments can be provided as positional arguments within the ADI::Register annotation. NOTE: Services based on generic types MUST explicitly provide a name via the name field within the ADI::Register annotation since there wouldn't be a way to tell them apart from the class name alone. @[ ADI :: Register ( Int32 , Bool , name : \"int_service\" , public : true ) ] @[ ADI :: Register ( Float64 , Bool , name : \"float_service\" , public : true ) ] struct GenericService ( T , B ) def type { T , B } end end ADI . container . int_service . type # => {Int32, Bool} ADI . container . float_service . type # => {Float64, Bool} Factories In some cases it may be necessary to use the factory design pattern to handle creating an object as opposed to creating the object directly. In this case the factory argument can be used. Factory methods are class methods defined on some type; either the service itself or a different type. Arguments to the factory method are provided as they would if the service was being created directly. This includes auto resolved service dependencies, and scalar underscore based arguments included within the ADI::Register annotation. Same Type A String factory value denotes the method name that should be called on the service itself to create the service. # Calls `StringFactoryService.double` to create the service. @[ ADI :: Register ( _value : 10 , public : true , factory : \"double\" ) ] class StringFactoryService getter value : Int32 def self . double ( value : Int32 ) : self new value * 2 end def initialize ( @value : Int32 ); end end ADI . container . string_factory_service . value # => 20 Different Type A Tuple can also be provided as the factory value to allow using an external type's factory method to create the service. The first item represents the factory type to use, and the second item represents the method that should be called. class TestFactory def self . create_tuple_service ( value : Int32 ) : TupleFactoryService TupleFactoryService . new value * 3 end end # Calls `TestFactory.create_tuple_service` to create the service. @[ ADI :: Register ( _value : 10 , public : true , factory : { TestFactory , \"create_tuple_service\" }) ] class TupleFactoryService getter value : Int32 def initialize ( @value : Int32 ); end end ADI . container . tuple_factory_service . value # => 30 Customizing Service's Type By default when a service is registered, it is typed the same as the service, for example: @[ ADI :: Register ] class MyService ; end This service is essentially represented in the service container as @my_service : MyService . This is usually fine for most services, however there are some cases where the service's type should not be the concrete implementation. An example of this is if that service should be mockable in a test setting. Mockable services should be typed to an interface that they implement in order to allow mock implementations to be used if needed. module SomeInterface ; end @[ ADI :: Register ( type : SomeInterface ) ] class MyService include SomeInterface end By specifying the type as SomeInterface , this changes the services representation in the service container to @my_service : SomeInterface , thus allowing the exact implementation to be changed. See ADI::Spec::MockableServiceContainer for more details.","title":"Register"},{"location":"DependencyInjection/Register/#Athena::DependencyInjection::Register","text":"Registers a service based on the type the annotation is applied to. The type of the service affects how it behaves within the container. When a struct service is retrieved or injected into a type, it will be a copy of the one in the SC (passed by value). This means that changes made to it in one type, will NOT be reflected in other types. A class service on the other hand will be a reference to the one in the SC. This allows it to share state between services.","title":"Register"},{"location":"DependencyInjection/Register/#Athena::DependencyInjection::Register--optional-arguments","text":"In most cases, the annotation can be applied without additional arguments. However, the annotation accepts a handful of optional arguments to fine tune how the service is registered. name : String - The name of the service. Should be unique. Defaults to the type's FQN snake cased. public : Bool - If the service should be directly accessible from the container. Defaults to false . public_alias : Bool - If a service should be directly accessible from the container via an alias. Defaults to false . lazy : Bool - If the service should be lazily instantiated. I.e. only instantiated when it is first accessed; either directly or as a dependency of another service. Defaults to true . alias : T - Injects self when this type is used as a type restriction. See the Aliasing Services example for more information. tags : Array(String | NamedTuple(name: String, priority: Int32?)) - Tags that should be assigned to the service. Defaults to an empty array. See the Tagging Services example for more information. type : T - The type of the service within the container. Defaults to service's types. See the Customizing Service's Type section. factory : String | Tuple(T, String) - Use a factory type/method to create the service. See the Factories section.","title":"Optional Arguments"},{"location":"DependencyInjection/Register/#Athena::DependencyInjection::Register--examples","text":"","title":"Examples"},{"location":"DependencyInjection/Register/#Athena::DependencyInjection::Register--basic-usage","text":"The simplest usage involves only applying the ADI::Register annotation to a type. If the type does not have any arguments, then it is simply registered as a service as is. If the type does have arguments, then an attempt is made to register the service by automatically resolving dependencies based on type restrictions. @[ ADI :: Register ] # Register a service without any dependencies. struct ShoutTransformer def transform ( value : String ) : String value . upcase end end @[ ADI :: Register ( public : true ) ] # The ShoutTransformer is injected based on the type restriction of the `transformer` argument. struct SomeAPIClient def initialize ( @transformer : ShoutTransformer ); end def send ( message : String ) message = @transformer . transform message # ... end end ADI . container . some_api_client . send \"foo\" # => FOO","title":"Basic Usage"},{"location":"DependencyInjection/Register/#Athena::DependencyInjection::Register--aliasing-services","text":"An important part of DI is building against interfaces as opposed to concrete types. This allows a type to depend upon abstractions rather than a specific implementation of the interface. Or in other words, prevents a singular implementation from being tightly coupled with another type. We can use the alias argument when registering a service to tell the container that it should inject this service when a type restriction for the aliased service is found. # Define an interface for our services to use. module TransformerInterface abstract def transform ( value : String ) : String end @[ ADI :: Register ( alias : TransformerInterface ) ] # Alias the `TransformerInterface` to this service. struct ShoutTransformer include TransformerInterface def transform ( value : String ) : String value . upcase end end @[ ADI :: Register ] # Define another transformer type. struct ReverseTransformer include TransformerInterface def transform ( value : String ) : String value . reverse end end @[ ADI :: Register ( public : true ) ] # The `ShoutTransformer` is injected because the `TransformerInterface` is aliased to the `ShoutTransformer`. struct SomeAPIClient def initialize ( @transformer : TransformerInterface ); end def send ( message : String ) message = @transformer . transform message # ... end end ADI . container . some_api_client . send \"foo\" # => FOO Any service that uses TransformerInterface as a dependency type restriction will get the ShoutTransformer . However, it is also possible to use a specific implementation while still building against the interface. The name of the constructor argument is used in part to resolve the dependency. @[ ADI :: Register ( public : true ) ] # The `ReverseTransformer` is injected because the constructor argument's name matches the service name of `ReverseTransformer`. struct SomeAPIClient def initialize ( reverse_transformer : TransformerInterface ) @transformer = reverse_transformer end def send ( message : String ) message = @transformer . transform message # ... end end ADI . container . some_api_client . send \"foo\" # => oof","title":"Aliasing Services"},{"location":"DependencyInjection/Register/#Athena::DependencyInjection::Register--scalar-arguments","text":"The auto registration logic as shown in previous examples only works on service dependencies. Scalar arguments, such as Arrays, Strings, NamedTuples, etc, must be defined manually. This is achieved by using the argument's name prefixed with a _ symbol as named arguments within the annotation. @[ ADI :: Register ( _shell : ENV [ \"SHELL\" ] , _config : { id : 12_i64 , active : true }, public : true ) ] struct ScalarClient def initialize ( @shell : String , @config : NamedTuple ( id : Int64 , active : Bool )); end end ADI . container . scalar_client # => ScalarClient(@config={id: 12, active: true}, @shell=\"/bin/bash\") Arrays can also include references to services by prefixing the name of the service with an @ symbol. module Interface ; end @[ ADI :: Register ] struct One include Interface end @[ ADI :: Register ] struct Two include Interface end @[ ADI :: Register ] struct Three include Interface end @[ ADI :: Register ( _services : [ \"@one\" , \"@three\" ] , public : true ) ] struct ArrayClient def initialize ( @services : Array ( Interface )); end end ADI . container . array_client # => ArrayClient(@services=[One(), Three()]) While scalar arguments cannot be auto registered by default, the Athena::DependencyInjection.bind macro can be used to support it. For example: ADI.bind shell, \"bash\" . This would now inject the string \"bash\" whenever an argument named shell is encountered.","title":"Scalar Arguments"},{"location":"DependencyInjection/Register/#Athena::DependencyInjection::Register--tagging-services","text":"Services can also be tagged. Service tags allows another service to have all services with a specific tag injected as a dependency. A tag consists of a name, and additional metadata related to the tag. Currently the only supported metadata value is priority , which controls the order in which the services are injected; the higher the priority the sooner in the array it would be. In the future support for custom tag metadata will be implemented. The Athena::DependencyInjection.auto_configure macro may also be used to make working with tags easier. PARTNER_TAG = \"partner\" @[ ADI :: Register ( _id : 1 , name : \"google\" , tags : [ { name : PARTNER_TAG , priority : 5 } ] ) ] @[ ADI :: Register ( _id : 2 , name : \"facebook\" , tags : [ PARTNER_TAG ] ) ] @[ ADI :: Register ( _id : 3 , name : \"yahoo\" , tags : [ { name : \"partner\" , priority : 10 } ] ) ] @[ ADI :: Register ( _id : 4 , name : \"microsoft\" , tags : [ PARTNER_TAG ] ) ] # Register multiple services based on the same type. Each service must give define a unique name. record FeedPartner , id : Int32 @[ ADI :: Register ( _services : \"!partner\" , public : true ) ] # Inject all services with the `\"partner\"` tag into `self`. class PartnerClient def initialize ( @services : Array ( FeedPartner )); end end ADI . container . partner_client # => # #<PartnerClient:0x7f43c0a1ae60 # @services= # [FeedPartner(@id=3, @name=\"Yahoo\"), # FeedPartner(@id=1, @name=\"Google\"), # FeedPartner(@id=2, @name=\"Facebook\"), # FeedPartner(@id=4, @name=\"Microsoft\")]> While tagged services cannot be injected automatically by default, the Athena::DependencyInjection.bind macro can be used to support it. For example: ADI.bind partners, \"!partner\" . This would now inject all services with the partner tagged when an argument named partners is encountered. A type restriction can also be added to the binding to allow reusing the name. See the documentation for Athena::DependencyInjection.bind for an example.","title":"Tagging Services"},{"location":"DependencyInjection/Register/#Athena::DependencyInjection::Register--optional-services","text":"Services defined with a nillable type restriction are considered to be optional. If no service could be resolved from the type, then nil is injected instead. Similarly, if the argument has a default value, that value would be used instead. struct OptionalMissingService end @[ ADI :: Register ] struct OptionalExistingService end @[ ADI :: Register ( public : true ) ] class OptionalClient getter service_missing , service_existing , service_default def initialize ( @service_missing : OptionalMissingService? , @service_existing : OptionalExistingService? , @service_default : OptionalMissingService | Int32 | Nil = 12 ); end end ADI . container . optional_client # #<OptionalClient:0x7fe7de7cdf40 # @service_default=12, # @service_existing=OptionalExistingService(), # @service_missing=nil>","title":"Optional Services"},{"location":"DependencyInjection/Register/#Athena::DependencyInjection::Register--generic-services","text":"Generic arguments can be provided as positional arguments within the ADI::Register annotation. NOTE: Services based on generic types MUST explicitly provide a name via the name field within the ADI::Register annotation since there wouldn't be a way to tell them apart from the class name alone. @[ ADI :: Register ( Int32 , Bool , name : \"int_service\" , public : true ) ] @[ ADI :: Register ( Float64 , Bool , name : \"float_service\" , public : true ) ] struct GenericService ( T , B ) def type { T , B } end end ADI . container . int_service . type # => {Int32, Bool} ADI . container . float_service . type # => {Float64, Bool}","title":"Generic Services"},{"location":"DependencyInjection/Register/#Athena::DependencyInjection::Register--factories","text":"In some cases it may be necessary to use the factory design pattern to handle creating an object as opposed to creating the object directly. In this case the factory argument can be used. Factory methods are class methods defined on some type; either the service itself or a different type. Arguments to the factory method are provided as they would if the service was being created directly. This includes auto resolved service dependencies, and scalar underscore based arguments included within the ADI::Register annotation.","title":"Factories"},{"location":"DependencyInjection/Register/#Athena::DependencyInjection::Register--same-type","text":"A String factory value denotes the method name that should be called on the service itself to create the service. # Calls `StringFactoryService.double` to create the service. @[ ADI :: Register ( _value : 10 , public : true , factory : \"double\" ) ] class StringFactoryService getter value : Int32 def self . double ( value : Int32 ) : self new value * 2 end def initialize ( @value : Int32 ); end end ADI . container . string_factory_service . value # => 20","title":"Same Type"},{"location":"DependencyInjection/Register/#Athena::DependencyInjection::Register--different-type","text":"A Tuple can also be provided as the factory value to allow using an external type's factory method to create the service. The first item represents the factory type to use, and the second item represents the method that should be called. class TestFactory def self . create_tuple_service ( value : Int32 ) : TupleFactoryService TupleFactoryService . new value * 3 end end # Calls `TestFactory.create_tuple_service` to create the service. @[ ADI :: Register ( _value : 10 , public : true , factory : { TestFactory , \"create_tuple_service\" }) ] class TupleFactoryService getter value : Int32 def initialize ( @value : Int32 ); end end ADI . container . tuple_factory_service . value # => 30","title":"Different Type"},{"location":"DependencyInjection/Register/#Athena::DependencyInjection::Register--customizing-services-type","text":"By default when a service is registered, it is typed the same as the service, for example: @[ ADI :: Register ] class MyService ; end This service is essentially represented in the service container as @my_service : MyService . This is usually fine for most services, however there are some cases where the service's type should not be the concrete implementation. An example of this is if that service should be mockable in a test setting. Mockable services should be typed to an interface that they implement in order to allow mock implementations to be used if needed. module SomeInterface ; end @[ ADI :: Register ( type : SomeInterface ) ] class MyService include SomeInterface end By specifying the type as SomeInterface , this changes the services representation in the service container to @my_service : SomeInterface , thus allowing the exact implementation to be changed. See ADI::Spec::MockableServiceContainer for more details.","title":"Customizing Service's Type"},{"location":"DependencyInjection/ServiceContainer/","text":"class Athena::DependencyInjection::ServiceContainer inherits Reference Where the instantiated services live. If a service is public, a getter based on the service's name as well as its type is defined. Otherwise, services are only available via constructor DI. TODO: Reduce the amount of duplication when this issue is resolved. Direct known subclasses Athena::DependencyInjection::Spec::MockableServiceContainer Class methods .new Initializes the container. Auto registering annotated services. Methods #athena_routing_route_handler #get ( service : Athena :: Routing :: RequestStore . class ) : Athena::Routing::RequestStore #get ( service : Athena :: Routing :: Router . class ) : Athena::Routing::Router #get ( service : Athena :: Routing :: RouteHandler . class ) : Athena::Routing::RouteHandler #request_store #router","title":"ServiceContainer"},{"location":"DependencyInjection/ServiceContainer/#Athena::DependencyInjection::ServiceContainer","text":"Where the instantiated services live. If a service is public, a getter based on the service's name as well as its type is defined. Otherwise, services are only available via constructor DI. TODO: Reduce the amount of duplication when this issue is resolved.","title":"ServiceContainer"},{"location":"DependencyInjection/ServiceContainer/#direct-known-subclasses","text":"Athena::DependencyInjection::Spec::MockableServiceContainer","title":"Direct known subclasses"},{"location":"DependencyInjection/ServiceContainer/#class-methods","text":"","title":"Class methods"},{"location":"DependencyInjection/ServiceContainer/#Athena::DependencyInjection::ServiceContainer.new()","text":"Initializes the container. Auto registering annotated services.","title":".new"},{"location":"DependencyInjection/ServiceContainer/#methods","text":"","title":"Methods"},{"location":"DependencyInjection/ServiceContainer/#Athena::DependencyInjection::ServiceContainer#athena_routing_route_handler()","text":"","title":"#athena_routing_route_handler"},{"location":"DependencyInjection/ServiceContainer/#Athena::DependencyInjection::ServiceContainer#get(service)","text":"","title":"#get"},{"location":"DependencyInjection/ServiceContainer/#Athena::DependencyInjection::ServiceContainer#get(service)","text":"","title":"#get"},{"location":"DependencyInjection/ServiceContainer/#Athena::DependencyInjection::ServiceContainer#get(service)","text":"","title":"#get"},{"location":"DependencyInjection/ServiceContainer/#Athena::DependencyInjection::ServiceContainer#request_store()","text":"","title":"#request_store"},{"location":"DependencyInjection/ServiceContainer/#Athena::DependencyInjection::ServiceContainer#router()","text":"","title":"#router"},{"location":"DependencyInjection/Spec/","text":"module Athena::DependencyInjection::Spec A set of testing utilities/types to aid in testing Athena::DependencyInjection related types. Getting Started Require this module in your spec_helper.cr file. # This also requires \"spec\". require \"athena-dependency_injection/spec\"","title":"Spec"},{"location":"DependencyInjection/Spec/#Athena::DependencyInjection::Spec","text":"A set of testing utilities/types to aid in testing Athena::DependencyInjection related types.","title":"Spec"},{"location":"DependencyInjection/Spec/#Athena::DependencyInjection::Spec--getting-started","text":"Require this module in your spec_helper.cr file. # This also requires \"spec\". require \"athena-dependency_injection/spec\"","title":"Getting Started"},{"location":"DependencyInjection/Spec/MockableServiceContainer/","text":"class Athena::DependencyInjection::Spec::MockableServiceContainer inherits Athena::DependencyInjection::ServiceContainer A mock implementation of ADI::ServiceContainer that be used within a testing context to allow for mocking out services without affecting the actual container outside of tests. An example of this is when integration testing service based ART::Controller s. Service dependencies that interact with an external source, like a third party API or a database, should most likely be mocked out. However your other services should be left as is in order to get the most benefit from the test. Mocking The ADI::ServiceContainer is nothing more than a normal Crystal class with some instance variables and methods. As such, mocking services is as easy as monkey patching self with the mocked versions, assuming of course they are of a compatible type. Given Crystal's lack of a robust mocking shard, it isn't as straightforward as other languages. The best way at the moment is either using inheritance or interfaces (modules) to manually create a concrete test class/struct; with the latter option being preferred as it would work for both structs and classes. For example, we can create a mock implementation of a type by extending it: class MockMyService < MyService def get_value # Can now just return a static expected value. # Test properties/constructor(s) can also be added to make it a bit more generic. 1234 end end Because our mock extends MyService , it is a compatible type for anything typed as MyService . Another way to handle mocking is via interfaces (modules). module SomeInterface ; end struct MockMyService include SomeInterface end Because our mock implements SomeInterface , it is a compatible type for anything typed as SomeInterface . NOTE: Service mocks do not need to registered as services themselves since they will need to be configured manually. NOTE: The type argument as part of the ADI::Register annotation can be used to set the type of a service within the container. See ADI::Register@customizing-services-type for more details. Dynamic Mocks A dynamic mock consists of adding a setter to self that allows setting the mocked service dynamically at runtime, while keeping the original up until if/when it is replaced. class ADI::Spec:: MockableServiceContainer # The setter should be nilable as they're lazily initialized within the container. setter my_service : MyServiceInterface? end # ... # Now the `my_service` service can be replaced at runtime. mock_container . my_service = MockMyService . new # ... Global Mocks Global mocks totally replace the original service, i.e. always return the mocked service. class ADI::Spec:: MockableServiceContainer # Global mocks should use the block based `getter` macro. getter my_service : MyServiceInterface { MockMyService . new } end # `MockMyService` will now be injected across the board when using `self`. # ... Hybrid Mocks Dynamic and Global mocking can also be combined to allow having a default mock, but allow overriding if/when needed. This can be accomplished by adding both a getter and setter to self. class ADI::Spec:: MockableServiceContainer # Hybrid mocks should use the block based `property` macro. property my_service : MyServiceInterface { DefaultMockService . new } end # ... # `DefaultMockService` will now be injected across the board by when using `self`. # But can still be replaced at runtime. mock_container . my_service = CustomMockService . new # ...","title":"MockableServiceContainer"},{"location":"DependencyInjection/Spec/MockableServiceContainer/#Athena::DependencyInjection::Spec::MockableServiceContainer","text":"A mock implementation of ADI::ServiceContainer that be used within a testing context to allow for mocking out services without affecting the actual container outside of tests. An example of this is when integration testing service based ART::Controller s. Service dependencies that interact with an external source, like a third party API or a database, should most likely be mocked out. However your other services should be left as is in order to get the most benefit from the test.","title":"MockableServiceContainer"},{"location":"DependencyInjection/Spec/MockableServiceContainer/#Athena::DependencyInjection::Spec::MockableServiceContainer--mocking","text":"The ADI::ServiceContainer is nothing more than a normal Crystal class with some instance variables and methods. As such, mocking services is as easy as monkey patching self with the mocked versions, assuming of course they are of a compatible type. Given Crystal's lack of a robust mocking shard, it isn't as straightforward as other languages. The best way at the moment is either using inheritance or interfaces (modules) to manually create a concrete test class/struct; with the latter option being preferred as it would work for both structs and classes. For example, we can create a mock implementation of a type by extending it: class MockMyService < MyService def get_value # Can now just return a static expected value. # Test properties/constructor(s) can also be added to make it a bit more generic. 1234 end end Because our mock extends MyService , it is a compatible type for anything typed as MyService . Another way to handle mocking is via interfaces (modules). module SomeInterface ; end struct MockMyService include SomeInterface end Because our mock implements SomeInterface , it is a compatible type for anything typed as SomeInterface . NOTE: Service mocks do not need to registered as services themselves since they will need to be configured manually. NOTE: The type argument as part of the ADI::Register annotation can be used to set the type of a service within the container. See ADI::Register@customizing-services-type for more details.","title":"Mocking"},{"location":"DependencyInjection/Spec/MockableServiceContainer/#Athena::DependencyInjection::Spec::MockableServiceContainer--dynamic-mocks","text":"A dynamic mock consists of adding a setter to self that allows setting the mocked service dynamically at runtime, while keeping the original up until if/when it is replaced. class ADI::Spec:: MockableServiceContainer # The setter should be nilable as they're lazily initialized within the container. setter my_service : MyServiceInterface? end # ... # Now the `my_service` service can be replaced at runtime. mock_container . my_service = MockMyService . new # ...","title":"Dynamic Mocks"},{"location":"DependencyInjection/Spec/MockableServiceContainer/#Athena::DependencyInjection::Spec::MockableServiceContainer--global-mocks","text":"Global mocks totally replace the original service, i.e. always return the mocked service. class ADI::Spec:: MockableServiceContainer # Global mocks should use the block based `getter` macro. getter my_service : MyServiceInterface { MockMyService . new } end # `MockMyService` will now be injected across the board when using `self`. # ...","title":"Global Mocks"},{"location":"DependencyInjection/Spec/MockableServiceContainer/#Athena::DependencyInjection::Spec::MockableServiceContainer--hybrid-mocks","text":"Dynamic and Global mocking can also be combined to allow having a default mock, but allow overriding if/when needed. This can be accomplished by adding both a getter and setter to self. class ADI::Spec:: MockableServiceContainer # Hybrid mocks should use the block based `property` macro. property my_service : MyServiceInterface { DefaultMockService . new } end # ... # `DefaultMockService` will now be injected across the board by when using `self`. # But can still be replaced at runtime. mock_container . my_service = CustomMockService . new # ...","title":"Hybrid Mocks"},{"location":"EventDispatcher/","text":"alias AED Convenience alias to make referencing Athena::EventDispatcher types easier. Alias definition Athena::EventDispatcher Constants VERSION = \"0.1.0\" module Athena::EventDispatcher A Mediator and Observer pattern event library. Athena::EventDispatcher or, AED for short, allows defining instance methods on EventListenerInterface types (observers) that will be executed when an Event is dispatched via the EventDispatcher (mediator). All events are registered with an EventDispatcher at compile time. While the recommended usage involves using listener structs, it is also possible to add/remove event handlers dynamically at runtime. The EventDispatcher has two constructors; one that supports manual or DI initialization, while the other auto registers listeners at compile time via macros. An event is nothing more than a class that, optionally, contains stateful information about the event. For example a HttpOnRequest event would contain a reference to the HTTP::Request object so that the listeners have access to request data. Similarly, a HttpOnResponse event would contain a reference to the HTTP::Server::Response object so that the response body/headers/status can be mutated by the listeners. Since events and listeners are registered at compile time (via macros or DI), listeners can be added to a project seamlessly without updating any configuration, or having to instantiate a HTTP::Handler object and add it to an array for example. The main benefit of this is that an external shard that defines a listener could be installed and would inherently be picked up and used by Athena::EventDispatcher ; thus making an application easily extendable. Example # Create a custom event. class ExceptionEvent < AED :: Event property ? handled : Bool = false getter exception : Exception # Events can contain stateful information related to the event. def initialize ( @exception : Exception ); end end # Create a listener. struct ExceptionListener include AED :: EventListenerInterface # Define what events `self` is listening on as well as their priorities. # # The higher the priority the sooner that specific listener is executed. def self . subscribed_events : AED :: SubscribedEvents AED :: SubscribedEvents { ExceptionEvent => 0 , } end # Listener handler's are `#call` instance methods restricted to the type of event it should handle. # # Multiple methods can be defined to handle multiple events within the same listener. # # Event handler's also have access to the dispatcher instance itself. def call ( event : ExceptionEvent , dispatcher : AED :: EventDispatcherInterface ) : Nil # Do something with the `ExceptionEvent` and/or dispatcher event . handled = true end end # New up an `AED::EventDispatcher`, using `AED::EventDispatcher#new`. # This overload automatically registers listeners using macros. # # See also `AED::EventDispatcher#new(listeners : Array(EventListenerInterface))` for a more manual/DI friendly initializer. dispatcher = AED :: EventDispatcher . new # Instantiate our custom event. event = ExceptionEvent . new ArgumentError . new ( \"Test exception\" ) # All events are dispatched via an `AED::EventDispatcher` instance. # # Similarly, all listeners are registered with it. dispatcher . dispatch event event . handled # => true # Additional methods also exist on the dispatcher, such as: # * Adding/removing listeners at runtime # * Checking the priority of a listener # * Getting an array of listeners for a given event # * Checking if there is a listener(s) listening on a given `AED::Event` dispatcher . has_listeners? ExceptionEvent # => true Constants VERSION = \"0.1.0\" Macros create_listener Creates a listener for the provided event . The macro's block is used as the listener. The macro block implicitly yields event and dispatcher . listener = AED . create_listener ( SampleEvent ) do # Do something with the event. event . some_method # A reference to the `AED::EventDispatcherInterface` is also provided. dispatcher . dispatch FakeEvent . new end","title":"EventDispatcher"},{"location":"EventDispatcher/#AED","text":"Convenience alias to make referencing Athena::EventDispatcher types easier.","title":"AED"},{"location":"EventDispatcher/#alias-definition","text":"Athena::EventDispatcher","title":"Alias definition"},{"location":"EventDispatcher/#constants","text":"","title":"Constants"},{"location":"EventDispatcher/#AED::VERSION","text":"","title":"VERSION"},{"location":"EventDispatcher/#Athena::EventDispatcher","text":"A Mediator and Observer pattern event library. Athena::EventDispatcher or, AED for short, allows defining instance methods on EventListenerInterface types (observers) that will be executed when an Event is dispatched via the EventDispatcher (mediator). All events are registered with an EventDispatcher at compile time. While the recommended usage involves using listener structs, it is also possible to add/remove event handlers dynamically at runtime. The EventDispatcher has two constructors; one that supports manual or DI initialization, while the other auto registers listeners at compile time via macros. An event is nothing more than a class that, optionally, contains stateful information about the event. For example a HttpOnRequest event would contain a reference to the HTTP::Request object so that the listeners have access to request data. Similarly, a HttpOnResponse event would contain a reference to the HTTP::Server::Response object so that the response body/headers/status can be mutated by the listeners. Since events and listeners are registered at compile time (via macros or DI), listeners can be added to a project seamlessly without updating any configuration, or having to instantiate a HTTP::Handler object and add it to an array for example. The main benefit of this is that an external shard that defines a listener could be installed and would inherently be picked up and used by Athena::EventDispatcher ; thus making an application easily extendable.","title":"EventDispatcher"},{"location":"EventDispatcher/#Athena::EventDispatcher--example","text":"# Create a custom event. class ExceptionEvent < AED :: Event property ? handled : Bool = false getter exception : Exception # Events can contain stateful information related to the event. def initialize ( @exception : Exception ); end end # Create a listener. struct ExceptionListener include AED :: EventListenerInterface # Define what events `self` is listening on as well as their priorities. # # The higher the priority the sooner that specific listener is executed. def self . subscribed_events : AED :: SubscribedEvents AED :: SubscribedEvents { ExceptionEvent => 0 , } end # Listener handler's are `#call` instance methods restricted to the type of event it should handle. # # Multiple methods can be defined to handle multiple events within the same listener. # # Event handler's also have access to the dispatcher instance itself. def call ( event : ExceptionEvent , dispatcher : AED :: EventDispatcherInterface ) : Nil # Do something with the `ExceptionEvent` and/or dispatcher event . handled = true end end # New up an `AED::EventDispatcher`, using `AED::EventDispatcher#new`. # This overload automatically registers listeners using macros. # # See also `AED::EventDispatcher#new(listeners : Array(EventListenerInterface))` for a more manual/DI friendly initializer. dispatcher = AED :: EventDispatcher . new # Instantiate our custom event. event = ExceptionEvent . new ArgumentError . new ( \"Test exception\" ) # All events are dispatched via an `AED::EventDispatcher` instance. # # Similarly, all listeners are registered with it. dispatcher . dispatch event event . handled # => true # Additional methods also exist on the dispatcher, such as: # * Adding/removing listeners at runtime # * Checking the priority of a listener # * Getting an array of listeners for a given event # * Checking if there is a listener(s) listening on a given `AED::Event` dispatcher . has_listeners? ExceptionEvent # => true","title":"Example"},{"location":"EventDispatcher/#constants_1","text":"","title":"Constants"},{"location":"EventDispatcher/#Athena::EventDispatcher::VERSION","text":"","title":"VERSION"},{"location":"EventDispatcher/#macros","text":"","title":"Macros"},{"location":"EventDispatcher/#Athena::EventDispatcher:create_listener(event,&)","text":"Creates a listener for the provided event . The macro's block is used as the listener. The macro block implicitly yields event and dispatcher . listener = AED . create_listener ( SampleEvent ) do # Do something with the event. event . some_method # A reference to the `AED::EventDispatcherInterface` is also provided. dispatcher . dispatch FakeEvent . new end","title":"create_listener"},{"location":"EventDispatcher/Event/","text":"class Athena::EventDispatcher::Event inherits Reference Base class for all event objects. This event does not contain any event data and can be used by events that do not require any state. Can be inherited from to include information about the event. NOTE: If one event inherits from another, and both are being used within a listener; the child event's handler would be executed twice since its type is compatible with the parent. Either use composition versus inheritance for sharing common logic between events, or add an explicit type check in the listener. # Define a custom event class ExceptionEvent < AED :: Event getter exception : Exception def initialize ( @exception : Exception ); end end # Using Event on its own dispatcher . dispatch AED :: Event . new # Dispatch a custom event exception = ArgumentError . new \"Value cannot be negative\" dispatcher . dispatch ExceptionEvent . new exception Included modules Athena::EventDispatcher::StoppableEvent Direct known subclasses Athena::Routing::Events::Action Athena::Routing::Events::Exception Athena::Routing::Events::Request Athena::Routing::Events::Response Athena::Routing::Events::Terminate Athena::Routing::Events::View","title":"Event"},{"location":"EventDispatcher/Event/#Athena::EventDispatcher::Event","text":"Base class for all event objects. This event does not contain any event data and can be used by events that do not require any state. Can be inherited from to include information about the event. NOTE: If one event inherits from another, and both are being used within a listener; the child event's handler would be executed twice since its type is compatible with the parent. Either use composition versus inheritance for sharing common logic between events, or add an explicit type check in the listener. # Define a custom event class ExceptionEvent < AED :: Event getter exception : Exception def initialize ( @exception : Exception ); end end # Using Event on its own dispatcher . dispatch AED :: Event . new # Dispatch a custom event exception = ArgumentError . new \"Value cannot be negative\" dispatcher . dispatch ExceptionEvent . new exception","title":"Event"},{"location":"EventDispatcher/Event/#included-modules","text":"Athena::EventDispatcher::StoppableEvent","title":"Included modules"},{"location":"EventDispatcher/Event/#direct-known-subclasses","text":"Athena::Routing::Events::Action Athena::Routing::Events::Exception Athena::Routing::Events::Request Athena::Routing::Events::Response Athena::Routing::Events::Terminate Athena::Routing::Events::View","title":"Direct known subclasses"},{"location":"EventDispatcher/EventDispatcher/","text":"class Athena::EventDispatcher::EventDispatcher inherits Reference Included modules Athena::EventDispatcher::EventDispatcherInterface Class methods .new ( listeners : Array ( AED::EventListenerInterface )) Initializes self with the provided listeners . This overload is mainly intended for DI or to manually configure the listeners that should be listened on. .new Initializes self automatically via macros. This overload is mainly intended for use cases where the listener types don't have any dependencies, and/or all listeners should listen. Methods #add_listener ( event : AED :: Event . class , listener : AED::EventListenerType , priority : Int32 = 0 ) : Nil Adds the provided listener as a listener for event , optionally with the provided priority . #dispatch ( event : AED::Event ) : Nil Dispatches event to all listeners registered on self that are listening on that event. AED::EventListenerInterface 's are executed based on the listener's priority; the higher the value the sooner it gets executed. #has_listeners? ( event : AED :: Event . class? = nil ) : Bool Returns true if there are any listeners listening on the provided event . If no event is provided, returns true if there are ANY listeners registered on self . #listener_priority ( event : AED :: Event . class , listener : AED :: EventListenerInterface . class ) : Int32 ? Returns the listener priority for the provided event . Returns nil if no listeners are listening on the provided event or if listener isn't listening on event . #listeners ( event : AED :: Event . class? = nil ) : Array ( AED::EventListener ) Returns the listeners listening on the provided event . If no event is provided, returns all listeners. #remove_listener ( event : AED :: Event . class , listener : AED :: EventListenerInterface . class ) : Nil Removes the provided event from the provided listener . #remove_listener ( event : AED :: Event . class , listener : AED::EventListenerType ) : Nil Removes the provided event from the provided listener .","title":"EventDispatcher"},{"location":"EventDispatcher/EventDispatcher/#Athena::EventDispatcher::EventDispatcher","text":"","title":"EventDispatcher"},{"location":"EventDispatcher/EventDispatcher/#included-modules","text":"Athena::EventDispatcher::EventDispatcherInterface","title":"Included modules"},{"location":"EventDispatcher/EventDispatcher/#class-methods","text":"","title":"Class methods"},{"location":"EventDispatcher/EventDispatcher/#Athena::EventDispatcher::EventDispatcher.new(listeners)","text":"Initializes self with the provided listeners . This overload is mainly intended for DI or to manually configure the listeners that should be listened on.","title":".new"},{"location":"EventDispatcher/EventDispatcher/#methods","text":"","title":"Methods"},{"location":"EventDispatcher/EventDispatcher/#Athena::EventDispatcher::EventDispatcher#add_listener(event,listener,priority)","text":"Adds the provided listener as a listener for event , optionally with the provided priority .","title":"#add_listener"},{"location":"EventDispatcher/EventDispatcher/#Athena::EventDispatcher::EventDispatcher#dispatch(event)","text":"Dispatches event to all listeners registered on self that are listening on that event. AED::EventListenerInterface 's are executed based on the listener's priority; the higher the value the sooner it gets executed.","title":"#dispatch"},{"location":"EventDispatcher/EventDispatcher/#Athena::EventDispatcher::EventDispatcher#has_listeners?(event)","text":"Returns true if there are any listeners listening on the provided event . If no event is provided, returns true if there are ANY listeners registered on self .","title":"#has_listeners?"},{"location":"EventDispatcher/EventDispatcher/#Athena::EventDispatcher::EventDispatcher#listener_priority(event,listener)","text":"Returns the listener priority for the provided event . Returns nil if no listeners are listening on the provided event or if listener isn't listening on event .","title":"#listener_priority"},{"location":"EventDispatcher/EventDispatcher/#Athena::EventDispatcher::EventDispatcher#listeners(event)","text":"Returns the listeners listening on the provided event . If no event is provided, returns all listeners.","title":"#listeners"},{"location":"EventDispatcher/EventDispatcher/#Athena::EventDispatcher::EventDispatcher#remove_listener(event,listener)","text":"Removes the provided event from the provided listener .","title":"#remove_listener"},{"location":"EventDispatcher/EventDispatcher/#Athena::EventDispatcher::EventDispatcher#remove_listener(event,listener)","text":"Removes the provided event from the provided listener .","title":"#remove_listener"},{"location":"EventDispatcher/EventDispatcherInterface/","text":"module Athena::EventDispatcher::EventDispatcherInterface Base type of an event dispatcher. Defines how dispatchers should be implemented. Direct including types Athena::EventDispatcher::EventDispatcher Methods abstract #add_listener ( event : AED :: Event . class , listener : AED::EventListenerType , priority : Int32 ) : Nil Adds the provided listener as a listener for event , optionally with the provided priority . abstract #dispatch ( event : AED::Event ) : Nil Dispatches event to all listeners registered on self that are listening on that event. AED::EventListenerInterface 's are executed based on the listener's priority; the higher the value the sooner it gets executed. abstract #has_listeners? ( event : AED :: Event . class? ) : Bool Returns true if there are any listeners listening on the provided event . If no event is provided, returns true if there are ANY listeners registered on self . abstract #listener_priority ( event : AED :: Event . class , listener : AED :: EventListenerInterface . class ) : Int32 ? Returns the listener priority for the provided event . Returns nil if no listeners are listening on the provided event or if listener isn't listening on event . abstract #listeners ( event : AED :: Event . class? ) : Array ( AED::EventListener ) Returns the listeners listening on the provided event . If no event is provided, returns all listeners. abstract #remove_listener ( event : AED :: Event . class , listener : AED :: EventListenerInterface . class ) : Nil Removes the provided event from the provided listener . abstract #remove_listener ( event : AED :: Event . class , listener : AED::EventListenerType ) : Nil Removes the provided event from the provided listener .","title":"EventDispatcherInterface"},{"location":"EventDispatcher/EventDispatcherInterface/#Athena::EventDispatcher::EventDispatcherInterface","text":"Base type of an event dispatcher. Defines how dispatchers should be implemented.","title":"EventDispatcherInterface"},{"location":"EventDispatcher/EventDispatcherInterface/#direct-including-types","text":"Athena::EventDispatcher::EventDispatcher","title":"Direct including types"},{"location":"EventDispatcher/EventDispatcherInterface/#methods","text":"","title":"Methods"},{"location":"EventDispatcher/EventDispatcherInterface/#Athena::EventDispatcher::EventDispatcherInterface#add_listener(event,listener,priority)","text":"Adds the provided listener as a listener for event , optionally with the provided priority .","title":"#add_listener"},{"location":"EventDispatcher/EventDispatcherInterface/#Athena::EventDispatcher::EventDispatcherInterface#dispatch(event)","text":"Dispatches event to all listeners registered on self that are listening on that event. AED::EventListenerInterface 's are executed based on the listener's priority; the higher the value the sooner it gets executed.","title":"#dispatch"},{"location":"EventDispatcher/EventDispatcherInterface/#Athena::EventDispatcher::EventDispatcherInterface#has_listeners?(event)","text":"Returns true if there are any listeners listening on the provided event . If no event is provided, returns true if there are ANY listeners registered on self .","title":"#has_listeners?"},{"location":"EventDispatcher/EventDispatcherInterface/#Athena::EventDispatcher::EventDispatcherInterface#listener_priority(event,listener)","text":"Returns the listener priority for the provided event . Returns nil if no listeners are listening on the provided event or if listener isn't listening on event .","title":"#listener_priority"},{"location":"EventDispatcher/EventDispatcherInterface/#Athena::EventDispatcher::EventDispatcherInterface#listeners(event)","text":"Returns the listeners listening on the provided event . If no event is provided, returns all listeners.","title":"#listeners"},{"location":"EventDispatcher/EventDispatcherInterface/#Athena::EventDispatcher::EventDispatcherInterface#remove_listener(event,listener)","text":"Removes the provided event from the provided listener .","title":"#remove_listener"},{"location":"EventDispatcher/EventDispatcherInterface/#Athena::EventDispatcher::EventDispatcherInterface#remove_listener(event,listener)","text":"Removes the provided event from the provided listener .","title":"#remove_listener"},{"location":"EventDispatcher/EventListener/","text":"struct Athena::EventDispatcher::EventListener inherits Struct Wraps an EventListenerType in order to keep track of its priority . Class methods .new ( listener : EventListenerType , priority : Int32 = 0 ) Methods #listener : EventListenerType The wrapped EventListenerType instance. #priority : Int32 The priority of the EventListenerType instance. The higher the priority the sooner listener will be executed.","title":"EventListener"},{"location":"EventDispatcher/EventListener/#Athena::EventDispatcher::EventListener","text":"Wraps an EventListenerType in order to keep track of its priority .","title":"EventListener"},{"location":"EventDispatcher/EventListener/#class-methods","text":"","title":"Class methods"},{"location":"EventDispatcher/EventListener/#Athena::EventDispatcher::EventListener.new(listener,priority)","text":"","title":".new"},{"location":"EventDispatcher/EventListener/#methods","text":"","title":"Methods"},{"location":"EventDispatcher/EventListener/#Athena::EventDispatcher::EventListener#listener()","text":"The wrapped EventListenerType instance.","title":"#listener"},{"location":"EventDispatcher/EventListener/#Athena::EventDispatcher::EventListener#priority()","text":"The priority of the EventListenerType instance. The higher the priority the sooner listener will be executed.","title":"#priority"},{"location":"EventDispatcher/EventListenerInterface/","text":"module Athena::EventDispatcher::EventListenerInterface Interface for event listeners. Listeners are defined by including this module. An event can be listened for by defining #call(event : AED::Event, dispatcher : AED::EventDispatcherInterface) : Nil . The first argument should be typed to the specific AED::Event instance that the method should listen on. Multiple methods can be defined to handle multiple events within the same listener. Implementors must also define self.subscribed_events : AED::SubscribedEvents that represents the events that self 's methods are listening on. The value of the hash is the priority of the listener. The higher the value the sooner that listener method gets executed. Implementors can also define initializers if external dependencies are required for handling the event. However, AED::EventDispatcher#new(listeners : Array(EventListenerInterface)) must be used to register self , either with DI, or provided manually. struct TestListener include AED :: EventListenerInterface def self . subscribed_events : AED :: SubscribedEvents AED :: SubscribedEvents { HttpRequestEvent => 0 , ExceptionEvent => 4 , } end def call ( event : HttpRequestEvent , dispatcher : AED :: EventDispatcherInterface ) : Nil # Do something with the `HttpRequestEvent` and/or dispatcher end def call ( event : ExceptionEvent , dispatcher : AED :: EventDispatcherInterface ) : Nil # Do something with the `ExceptionEvent` and/or dispatcher end end Direct including types Athena::Routing::Listeners::CORS Athena::Routing::Listeners::Error Athena::Routing::Listeners::ParamConverter Athena::Routing::Listeners::ParamFetcher Athena::Routing::Listeners::Routing Athena::Routing::Listeners::View Class methods .subscribed_events : AED::SubscribedEvents Returns the AED::Event s that self is listening on, along with the listener priority of each event. Implementors should overide this with the events it should listen on. Methods #call ( event : AED::Event , dispatcher : AED::EventDispatcherInterface ) : Nil Example method for listening on a specific event . Implementors can define multiple of these, assuming each one listens on a different AED::Event type. Internally this method is used to make the compiler happy, in practice it should never get called.","title":"EventListenerInterface"},{"location":"EventDispatcher/EventListenerInterface/#Athena::EventDispatcher::EventListenerInterface","text":"Interface for event listeners. Listeners are defined by including this module. An event can be listened for by defining #call(event : AED::Event, dispatcher : AED::EventDispatcherInterface) : Nil . The first argument should be typed to the specific AED::Event instance that the method should listen on. Multiple methods can be defined to handle multiple events within the same listener. Implementors must also define self.subscribed_events : AED::SubscribedEvents that represents the events that self 's methods are listening on. The value of the hash is the priority of the listener. The higher the value the sooner that listener method gets executed. Implementors can also define initializers if external dependencies are required for handling the event. However, AED::EventDispatcher#new(listeners : Array(EventListenerInterface)) must be used to register self , either with DI, or provided manually. struct TestListener include AED :: EventListenerInterface def self . subscribed_events : AED :: SubscribedEvents AED :: SubscribedEvents { HttpRequestEvent => 0 , ExceptionEvent => 4 , } end def call ( event : HttpRequestEvent , dispatcher : AED :: EventDispatcherInterface ) : Nil # Do something with the `HttpRequestEvent` and/or dispatcher end def call ( event : ExceptionEvent , dispatcher : AED :: EventDispatcherInterface ) : Nil # Do something with the `ExceptionEvent` and/or dispatcher end end","title":"EventListenerInterface"},{"location":"EventDispatcher/EventListenerInterface/#direct-including-types","text":"Athena::Routing::Listeners::CORS Athena::Routing::Listeners::Error Athena::Routing::Listeners::ParamConverter Athena::Routing::Listeners::ParamFetcher Athena::Routing::Listeners::Routing Athena::Routing::Listeners::View","title":"Direct including types"},{"location":"EventDispatcher/EventListenerInterface/#class-methods","text":"","title":"Class methods"},{"location":"EventDispatcher/EventListenerInterface/#Athena::EventDispatcher::EventListenerInterface.subscribed_events()","text":"Returns the AED::Event s that self is listening on, along with the listener priority of each event. Implementors should overide this with the events it should listen on.","title":".subscribed_events"},{"location":"EventDispatcher/EventListenerInterface/#methods","text":"","title":"Methods"},{"location":"EventDispatcher/EventListenerInterface/#Athena::EventDispatcher::EventListenerInterface#call(event,dispatcher)","text":"Example method for listening on a specific event . Implementors can define multiple of these, assuming each one listens on a different AED::Event type. Internally this method is used to make the compiler happy, in practice it should never get called.","title":"#call"},{"location":"EventDispatcher/EventListenerType/","text":"alias Athena::EventDispatcher::EventListenerType The possible types an event listener can be. AED::EventListenerInterface instances use #call in order to keep a common interface with the Proc based listeners. Alias definition Athena::EventDispatcher::EventListenerInterface | Athena::EventDispatcher::Event , Athena::EventDispatcher::EventDispatcherInterface -> Nil","title":"EventListenerType"},{"location":"EventDispatcher/EventListenerType/#Athena::EventDispatcher::EventListenerType","text":"The possible types an event listener can be. AED::EventListenerInterface instances use #call in order to keep a common interface with the Proc based listeners.","title":"EventListenerType"},{"location":"EventDispatcher/EventListenerType/#alias-definition","text":"Athena::EventDispatcher::EventListenerInterface | Athena::EventDispatcher::Event , Athena::EventDispatcher::EventDispatcherInterface -> Nil","title":"Alias definition"},{"location":"EventDispatcher/StoppableEvent/","text":"module Athena::EventDispatcher::StoppableEvent An AED::Event whose processing may be interrupted when the event has been handled. AED::EventDispatcherInterface implementations MUST check to determine if an AED::Event is marked as stopped after each listener is called. If it is, then the AED::EventListenerType should return immediately without calling any further AED::EventListenerType . Direct including types Athena::EventDispatcher::Event Methods #propagate? : Bool If future AED::EventListenerType should be executed. #stop_propagation : Nil Prevent future AED::EventListenerType from executing once any listener calls #stop_propagation on self .","title":"StoppableEvent"},{"location":"EventDispatcher/StoppableEvent/#Athena::EventDispatcher::StoppableEvent","text":"An AED::Event whose processing may be interrupted when the event has been handled. AED::EventDispatcherInterface implementations MUST check to determine if an AED::Event is marked as stopped after each listener is called. If it is, then the AED::EventListenerType should return immediately without calling any further AED::EventListenerType .","title":"StoppableEvent"},{"location":"EventDispatcher/StoppableEvent/#direct-including-types","text":"Athena::EventDispatcher::Event","title":"Direct including types"},{"location":"EventDispatcher/StoppableEvent/#methods","text":"","title":"Methods"},{"location":"EventDispatcher/StoppableEvent/#Athena::EventDispatcher::StoppableEvent#propagate?()","text":"If future AED::EventListenerType should be executed.","title":"#propagate?"},{"location":"EventDispatcher/StoppableEvent/#Athena::EventDispatcher::StoppableEvent#stop_propagation()","text":"Prevent future AED::EventListenerType from executing once any listener calls #stop_propagation on self .","title":"#stop_propagation"},{"location":"EventDispatcher/SubscribedEvents/","text":"alias Athena::EventDispatcher::SubscribedEvents The mapping of the AED::Event and the priority a AED::EventListenerInterface is listening on. See AED::EventListenerInterface . Alias definition Hash ( Athena :: EventDispatcher :: Event . class , Int32 )","title":"SubscribedEvents"},{"location":"EventDispatcher/SubscribedEvents/#Athena::EventDispatcher::SubscribedEvents","text":"The mapping of the AED::Event and the priority a AED::EventListenerInterface is listening on. See AED::EventListenerInterface .","title":"SubscribedEvents"},{"location":"EventDispatcher/SubscribedEvents/#alias-definition","text":"Hash ( Athena :: EventDispatcher :: Event . class , Int32 )","title":"Alias definition"},{"location":"Routing/","text":"alias ART Convenience alias to make referencing Athena::Routing types easier. Alias definition Athena::Routing Constants LOGGER = Log . for ( \"athena.routing\" ) module Athena::Routing See the external documentation for an introduction to Athena . Also checkout the Components for an overview of how Athena is designed. Constants LOGGER = Log . for ( \"athena.routing\" ) Class methods .run ( port : Int32 = 3000 , host : String = \"0.0.0.0\" , reuse_port : Bool = false ) : Nil Runs an HTTP::Server listening on the given port and host . require \"athena\" class ExampleController < ART :: Controller @[ ART :: Get ( \"/\" ) ] def root : String \"At the index\" end end ART . run See ART::Controller for more information on defining controllers/route actions.","title":"Routing"},{"location":"Routing/#ART","text":"Convenience alias to make referencing Athena::Routing types easier.","title":"ART"},{"location":"Routing/#alias-definition","text":"Athena::Routing","title":"Alias definition"},{"location":"Routing/#constants","text":"","title":"Constants"},{"location":"Routing/#ART::LOGGER","text":"","title":"LOGGER"},{"location":"Routing/#Athena::Routing","text":"See the external documentation for an introduction to Athena . Also checkout the Components for an overview of how Athena is designed.","title":"Routing"},{"location":"Routing/#constants_1","text":"","title":"Constants"},{"location":"Routing/#Athena::Routing::LOGGER","text":"","title":"LOGGER"},{"location":"Routing/#class-methods","text":"","title":"Class methods"},{"location":"Routing/#Athena::Routing.run(port,host,reuse_port)","text":"Runs an HTTP::Server listening on the given port and host . require \"athena\" class ExampleController < ART :: Controller @[ ART :: Get ( \"/\" ) ] def root : String \"At the index\" end end ART . run See ART::Controller for more information on defining controllers/route actions.","title":".run"},{"location":"Routing/Action/","text":"struct Athena::Routing::Action(Controller, ActionType, ReturnType, ArgTypeTuple, ArgumentsType) inherits Athena::Routing::ActionBase Represents an endpoint within the application. Includes metadata about the endpoint, such as its controller, arguments, return type, and the action that should be executed. Class methods .new ( action : ActionType , name : String , method : String , path : String , constraints : Hash ( String , Regex ), arguments : ArgumentsType , param_converters : Array ( ART::ParamConverterInterface::ConfigurationInterface ), view_context : ART::Action::ViewContext , annotation_configurations : ACF::AnnotationConfigurations , params : Array ( ART::Params::ParamInterface ), _controller : Controller . class , _return_type : ReturnType . class , _arg_types : ArgTypeTuple . class ) Methods #annotation_configurations : ACF::AnnotationConfigurations Returns annotation configurations registered via Athena::Config.configuration_annotation and applied to self . These configurations could then be accessed within ART::ParamConverterInterface s and/or ART::Listeners s. See ART::Events::RequestAware for an example. #arguments : ArgumentsType Returns an Array(ART::Arguments::ArgumentMetadata) that self requires. #constraints : Hash ( String , Regex ) Returns any routing constraints related to self . #controller : Controller . class The ART::Controller that includes self . #execute ( arguments : Array ) : ReturnType Executes the action related to self with the provided arguments array. #method : String Returns the HTTP method associated with self . #name : String Returns the name of the the controller action related to self . #param_converters : Array ( ART::ParamConverterInterface::ConfigurationInterface ) Returns an Array(ART::ParamConverterInterface::ConfigurationInterface) representing the ART::ParamConverter s applied to self . #params : Array ( ART::Params::ParamInterface ) #path : String Returns the URL path related to self . #return_type : ReturnType . class The type that self 's route should return. #view_context : ART::Action::ViewContext Returns the ART::Action::ViewContext related to self .","title":"Action"},{"location":"Routing/Action/#Athena::Routing::Action","text":"Represents an endpoint within the application. Includes metadata about the endpoint, such as its controller, arguments, return type, and the action that should be executed.","title":"Action"},{"location":"Routing/Action/#class-methods","text":"","title":"Class methods"},{"location":"Routing/Action/#Athena::Routing::Action.new(action,name,method,path,constraints,arguments,param_converters,view_context,annotation_configurations,params,_controller,_return_type,_arg_types)","text":"","title":".new"},{"location":"Routing/Action/#methods","text":"","title":"Methods"},{"location":"Routing/Action/#Athena::Routing::Action#annotation_configurations()","text":"Returns annotation configurations registered via Athena::Config.configuration_annotation and applied to self . These configurations could then be accessed within ART::ParamConverterInterface s and/or ART::Listeners s. See ART::Events::RequestAware for an example.","title":"#annotation_configurations"},{"location":"Routing/Action/#Athena::Routing::Action#arguments()","text":"Returns an Array(ART::Arguments::ArgumentMetadata) that self requires.","title":"#arguments"},{"location":"Routing/Action/#Athena::Routing::Action#constraints()","text":"Returns any routing constraints related to self .","title":"#constraints"},{"location":"Routing/Action/#Athena::Routing::Action#controller()","text":"The ART::Controller that includes self .","title":"#controller"},{"location":"Routing/Action/#Athena::Routing::Action#execute(arguments)","text":"Executes the action related to self with the provided arguments array.","title":"#execute"},{"location":"Routing/Action/#Athena::Routing::Action#method()","text":"Returns the HTTP method associated with self .","title":"#method"},{"location":"Routing/Action/#Athena::Routing::Action#name()","text":"Returns the name of the the controller action related to self .","title":"#name"},{"location":"Routing/Action/#Athena::Routing::Action#param_converters()","text":"Returns an Array(ART::ParamConverterInterface::ConfigurationInterface) representing the ART::ParamConverter s applied to self .","title":"#param_converters"},{"location":"Routing/Action/#Athena::Routing::Action#params()","text":"","title":"#params"},{"location":"Routing/Action/#Athena::Routing::Action#path()","text":"Returns the URL path related to self .","title":"#path"},{"location":"Routing/Action/#Athena::Routing::Action#return_type()","text":"The type that self 's route should return.","title":"#return_type"},{"location":"Routing/Action/#Athena::Routing::Action#view_context()","text":"Returns the ART::Action::ViewContext related to self .","title":"#view_context"},{"location":"Routing/Action/ViewContext/","text":"class Athena::Routing::Action::ViewContext inherits Reference Stores runtime configuration data from the ART::View annotation about how to render the output of the related action. This includes the action's HTTP::Status and any serialization related configuration options. Class methods .new ( status : HTTP :: Status? = nil , emit_nil : Bool = false , serialization_groups : Array ( String )? = nil , validation_groups : Array ( String )? = nil ) Methods #emit_nil : Bool Returns true if nil values should be serialized. #emit_nil= ( emit_nil : Bool ) Returns true if nil values should be serialized. #has_custom_status? : Bool Returns true if the action related to self defined a custom status via the ART::View annotation, otherwise false . #serialization_groups : Array ( String )? Returns the groups that should be used for serialization as part of ASR::ExclusionStrategies::Groups . #serialization_groups= ( serialization_groups : Array ( String ) ?) Returns the groups that should be used for serialization as part of ASR::ExclusionStrategies::Groups . #status : HTTP :: Status Returns the HTTP::Status this action should return. Defaults to HTTP::Status::OK (200). #status= ( status : HTTP :: Status ) Returns the HTTP::Status this action should return. Defaults to HTTP::Status::OK (200). #validation_groups : Array ( String )? Returns the groups that should be used to validate any objects related to this route. See AVD::Constraint@validation-groups . #validation_groups= ( validation_groups : Array ( String ) ?) Returns the groups that should be used to validate any objects related to this route. See AVD::Constraint@validation-groups . #version : String ? Returns the serialization version to use for this route as part of ASR::ExclusionStrategies::Version . Can be set as part of an ART::Events::Action event listener based on the resolved version of the request. #version= ( version : String ?) Returns the serialization version to use for this route as part of ASR::ExclusionStrategies::Version . Can be set as part of an ART::Events::Action event listener based on the resolved version of the request.","title":"ViewContext"},{"location":"Routing/Action/ViewContext/#Athena::Routing::Action::ViewContext","text":"Stores runtime configuration data from the ART::View annotation about how to render the output of the related action. This includes the action's HTTP::Status and any serialization related configuration options.","title":"ViewContext"},{"location":"Routing/Action/ViewContext/#class-methods","text":"","title":"Class methods"},{"location":"Routing/Action/ViewContext/#Athena::Routing::Action::ViewContext.new(status,emit_nil,serialization_groups,validation_groups)","text":"","title":".new"},{"location":"Routing/Action/ViewContext/#methods","text":"","title":"Methods"},{"location":"Routing/Action/ViewContext/#Athena::Routing::Action::ViewContext#emit_nil()","text":"Returns true if nil values should be serialized.","title":"#emit_nil"},{"location":"Routing/Action/ViewContext/#Athena::Routing::Action::ViewContext#emit_nil=(emit_nil)","text":"Returns true if nil values should be serialized.","title":"#emit_nil="},{"location":"Routing/Action/ViewContext/#Athena::Routing::Action::ViewContext#has_custom_status?()","text":"Returns true if the action related to self defined a custom status via the ART::View annotation, otherwise false .","title":"#has_custom_status?"},{"location":"Routing/Action/ViewContext/#Athena::Routing::Action::ViewContext#serialization_groups()","text":"Returns the groups that should be used for serialization as part of ASR::ExclusionStrategies::Groups .","title":"#serialization_groups"},{"location":"Routing/Action/ViewContext/#Athena::Routing::Action::ViewContext#serialization_groups=(serialization_groups)","text":"Returns the groups that should be used for serialization as part of ASR::ExclusionStrategies::Groups .","title":"#serialization_groups="},{"location":"Routing/Action/ViewContext/#Athena::Routing::Action::ViewContext#status()","text":"Returns the HTTP::Status this action should return. Defaults to HTTP::Status::OK (200).","title":"#status"},{"location":"Routing/Action/ViewContext/#Athena::Routing::Action::ViewContext#status=(status)","text":"Returns the HTTP::Status this action should return. Defaults to HTTP::Status::OK (200).","title":"#status="},{"location":"Routing/Action/ViewContext/#Athena::Routing::Action::ViewContext#validation_groups()","text":"Returns the groups that should be used to validate any objects related to this route. See AVD::Constraint@validation-groups .","title":"#validation_groups"},{"location":"Routing/Action/ViewContext/#Athena::Routing::Action::ViewContext#validation_groups=(validation_groups)","text":"Returns the groups that should be used to validate any objects related to this route. See AVD::Constraint@validation-groups .","title":"#validation_groups="},{"location":"Routing/Action/ViewContext/#Athena::Routing::Action::ViewContext#version()","text":"Returns the serialization version to use for this route as part of ASR::ExclusionStrategies::Version . Can be set as part of an ART::Events::Action event listener based on the resolved version of the request.","title":"#version"},{"location":"Routing/Action/ViewContext/#Athena::Routing::Action::ViewContext#version=(version)","text":"Returns the serialization version to use for this route as part of ASR::ExclusionStrategies::Version . Can be set as part of an ART::Events::Action event listener based on the resolved version of the request.","title":"#version="},{"location":"Routing/ActionBase/","text":"abstract struct Athena::Routing::ActionBase inherits Struct Parent type of a route just used for typing. See ART::Action . Direct known subclasses Athena::Routing::Action(Controller, ActionType, ReturnType, ArgTypeTuple, ArgumentsType) Class methods .new","title":"ActionBase"},{"location":"Routing/ActionBase/#Athena::Routing::ActionBase","text":"Parent type of a route just used for typing. See ART::Action .","title":"ActionBase"},{"location":"Routing/ActionBase/#direct-known-subclasses","text":"Athena::Routing::Action(Controller, ActionType, ReturnType, ArgTypeTuple, ArgumentsType)","title":"Direct known subclasses"},{"location":"Routing/ActionBase/#class-methods","text":"","title":"Class methods"},{"location":"Routing/ActionBase/#Athena::Routing::ActionBase.new()","text":"","title":".new"},{"location":"Routing/Arguments/","text":"module Athena::Routing::Arguments Namespace for types related to controller action arguments. See ART::Arguments::ArgumentMetadata .","title":"Arguments"},{"location":"Routing/Arguments/#Athena::Routing::Arguments","text":"Namespace for types related to controller action arguments. See ART::Arguments::ArgumentMetadata .","title":"Arguments"},{"location":"Routing/Arguments/ArgumentMetadata/","text":"struct Athena::Routing::Arguments::ArgumentMetadata(T) inherits Struct Represents a controller action argument. Stores metadata associated with it, such as its name, type, and default value if any. Class methods .new ( name : String , has_default : Bool , is_nilable : Bool = false , default : T? = nil , type : T . class = T ) Methods #default : T? The default value of the argument, if any. See ART::Arguments::Resolvers::DefaultValue . #has_default? : Bool If this argument has a default value. #name : String The name of the argument. #nilable? : Bool If nil is a valid argument for the argument. #type : T . class The type of the parameter, i.e. what its type restriction is.","title":"ArgumentMetadata"},{"location":"Routing/Arguments/ArgumentMetadata/#Athena::Routing::Arguments::ArgumentMetadata","text":"Represents a controller action argument. Stores metadata associated with it, such as its name, type, and default value if any.","title":"ArgumentMetadata"},{"location":"Routing/Arguments/ArgumentMetadata/#class-methods","text":"","title":"Class methods"},{"location":"Routing/Arguments/ArgumentMetadata/#Athena::Routing::Arguments::ArgumentMetadata.new(name,has_default,is_nilable,default,type)","text":"","title":".new"},{"location":"Routing/Arguments/ArgumentMetadata/#methods","text":"","title":"Methods"},{"location":"Routing/Arguments/ArgumentMetadata/#Athena::Routing::Arguments::ArgumentMetadata#default()","text":"The default value of the argument, if any. See ART::Arguments::Resolvers::DefaultValue .","title":"#default"},{"location":"Routing/Arguments/ArgumentMetadata/#Athena::Routing::Arguments::ArgumentMetadata#has_default?()","text":"If this argument has a default value.","title":"#has_default?"},{"location":"Routing/Arguments/ArgumentMetadata/#Athena::Routing::Arguments::ArgumentMetadata#name()","text":"The name of the argument.","title":"#name"},{"location":"Routing/Arguments/ArgumentMetadata/#Athena::Routing::Arguments::ArgumentMetadata#nilable?()","text":"If nil is a valid argument for the argument.","title":"#nilable?"},{"location":"Routing/Arguments/ArgumentMetadata/#Athena::Routing::Arguments::ArgumentMetadata#type()","text":"The type of the parameter, i.e. what its type restriction is.","title":"#type"},{"location":"Routing/Arguments/ArgumentResolver/","text":"struct Athena::Routing::Arguments::ArgumentResolver inherits Struct The default implementation of ART::Arguments::ArgumentResolverInterface . Included modules Athena::Routing::Arguments::ArgumentResolverInterface Class methods .new ( argument_resolvers : Array ( Athena::Routing::Arguments::Resolvers::ArgumentValueResolverInterface )) Methods #get_arguments ( request : HTTP::Request , route : ART::ActionBase ) : Array Returns an array of arguments resolved from the provided request for the given route .","title":"ArgumentResolver"},{"location":"Routing/Arguments/ArgumentResolver/#Athena::Routing::Arguments::ArgumentResolver","text":"The default implementation of ART::Arguments::ArgumentResolverInterface .","title":"ArgumentResolver"},{"location":"Routing/Arguments/ArgumentResolver/#included-modules","text":"Athena::Routing::Arguments::ArgumentResolverInterface","title":"Included modules"},{"location":"Routing/Arguments/ArgumentResolver/#class-methods","text":"","title":"Class methods"},{"location":"Routing/Arguments/ArgumentResolver/#Athena::Routing::Arguments::ArgumentResolver.new(argument_resolvers)","text":"","title":".new"},{"location":"Routing/Arguments/ArgumentResolver/#methods","text":"","title":"Methods"},{"location":"Routing/Arguments/ArgumentResolver/#Athena::Routing::Arguments::ArgumentResolver#get_arguments(request,route)","text":"Returns an array of arguments resolved from the provided request for the given route .","title":"#get_arguments"},{"location":"Routing/Arguments/ArgumentResolverInterface/","text":"module Athena::Routing::Arguments::ArgumentResolverInterface Responsible for resolving the arguments that will be passed to a controller action. See the external documentation for more information. Direct including types Athena::Routing::Arguments::ArgumentResolver Methods abstract #get_arguments ( request : HTTP::Request , route : ART::ActionBase ) : Array Returns an array of arguments resolved from the provided request for the given route .","title":"ArgumentResolverInterface"},{"location":"Routing/Arguments/ArgumentResolverInterface/#Athena::Routing::Arguments::ArgumentResolverInterface","text":"Responsible for resolving the arguments that will be passed to a controller action. See the external documentation for more information.","title":"ArgumentResolverInterface"},{"location":"Routing/Arguments/ArgumentResolverInterface/#direct-including-types","text":"Athena::Routing::Arguments::ArgumentResolver","title":"Direct including types"},{"location":"Routing/Arguments/ArgumentResolverInterface/#methods","text":"","title":"Methods"},{"location":"Routing/Arguments/ArgumentResolverInterface/#Athena::Routing::Arguments::ArgumentResolverInterface#get_arguments(request,route)","text":"Returns an array of arguments resolved from the provided request for the given route .","title":"#get_arguments"},{"location":"Routing/Arguments/Resolvers/","text":"module Athena::Routing::Arguments::Resolvers The default ART::Arguments::Resolvers::ArgumentValueResolverInterface s that will handle resolving controller action arguments from a request (or other source). Custom argument value resolvers can also be defined, see ART::Arguments::Resolvers::ArgumentValueResolverInterface . NOTE: In order for Athena::Routing to pick up your custom value resolvers, be sure to ADI::Register it as a service, and tag it as ART::Arguments::Resolvers::TAG . A priority field can also be optionally included in the annotation, the higher the value the sooner in the array it'll be when injected. See each resolver for more detailed information. Constants TAG = \"athena.argument_value_resolver\" The tag name for ART::Arguments::Resolvers::ArgumentValueResolverInterface s.","title":"Resolvers"},{"location":"Routing/Arguments/Resolvers/#Athena::Routing::Arguments::Resolvers","text":"The default ART::Arguments::Resolvers::ArgumentValueResolverInterface s that will handle resolving controller action arguments from a request (or other source). Custom argument value resolvers can also be defined, see ART::Arguments::Resolvers::ArgumentValueResolverInterface . NOTE: In order for Athena::Routing to pick up your custom value resolvers, be sure to ADI::Register it as a service, and tag it as ART::Arguments::Resolvers::TAG . A priority field can also be optionally included in the annotation, the higher the value the sooner in the array it'll be when injected. See each resolver for more detailed information.","title":"Resolvers"},{"location":"Routing/Arguments/Resolvers/#constants","text":"","title":"Constants"},{"location":"Routing/Arguments/Resolvers/#Athena::Routing::Arguments::Resolvers::TAG","text":"The tag name for ART::Arguments::Resolvers::ArgumentValueResolverInterface s.","title":"TAG"},{"location":"Routing/Arguments/Resolvers/ArgumentValueResolverInterface/","text":"module Athena::Routing::Arguments::Resolvers::ArgumentValueResolverInterface Argument value resolvers handle resolving the arguments for a controller action from a request, or other source. Custom resolvers can be defined by creating a service that implements this interface, and is tagged with ART::Arguments::Resolvers::TAG , optionally with a priority to determine the order in which the resolvers are executed. @[ ADI :: Register ( tags : [ { name : ART :: Arguments :: Resolvers :: TAG , priority : 10 } ] ) ] struct CustomResolver include Athena :: Routing :: Arguments :: Resolvers :: ArgumentValueResolverInterface # :inherit: def supports? ( request : HTTP :: Request , argument : ART :: Arguments :: ArgumentMetadata ) : Bool # Define the logic that determines if `self` is able to resolve a value for the given request/argument. # This resolver would handle resolving a value for action arguments whose type is `MyCustomType`. argument . type == MyCustomType end # :inherit: def resolve ( request : HTTP :: Request , argument : ART :: Arguments :: ArgumentMetadata ) # Return the resolved value. It could either come from the request itself, an injected service, or hardcoded. # `#resolve` is only executed if `#supports?` returns `true`. MyCustomType . new \"foo\" end end Direct including types Athena::Routing::Arguments::Resolvers::DefaultValue Athena::Routing::Arguments::Resolvers::Request Athena::Routing::Arguments::Resolvers::RequestAttribute Methods abstract #resolve ( request : HTTP::Request , argument : ART::Arguments::ArgumentMetadata ) Returns a value resolved from the provided request and argument . abstract #supports? ( request : HTTP::Request , argument : ART::Arguments::ArgumentMetadata ) : Bool Returns true if self is able to resolve a value from the provided request and argument .","title":"ArgumentValueResolverInterface"},{"location":"Routing/Arguments/Resolvers/ArgumentValueResolverInterface/#Athena::Routing::Arguments::Resolvers::ArgumentValueResolverInterface","text":"Argument value resolvers handle resolving the arguments for a controller action from a request, or other source. Custom resolvers can be defined by creating a service that implements this interface, and is tagged with ART::Arguments::Resolvers::TAG , optionally with a priority to determine the order in which the resolvers are executed. @[ ADI :: Register ( tags : [ { name : ART :: Arguments :: Resolvers :: TAG , priority : 10 } ] ) ] struct CustomResolver include Athena :: Routing :: Arguments :: Resolvers :: ArgumentValueResolverInterface # :inherit: def supports? ( request : HTTP :: Request , argument : ART :: Arguments :: ArgumentMetadata ) : Bool # Define the logic that determines if `self` is able to resolve a value for the given request/argument. # This resolver would handle resolving a value for action arguments whose type is `MyCustomType`. argument . type == MyCustomType end # :inherit: def resolve ( request : HTTP :: Request , argument : ART :: Arguments :: ArgumentMetadata ) # Return the resolved value. It could either come from the request itself, an injected service, or hardcoded. # `#resolve` is only executed if `#supports?` returns `true`. MyCustomType . new \"foo\" end end","title":"ArgumentValueResolverInterface"},{"location":"Routing/Arguments/Resolvers/ArgumentValueResolverInterface/#direct-including-types","text":"Athena::Routing::Arguments::Resolvers::DefaultValue Athena::Routing::Arguments::Resolvers::Request Athena::Routing::Arguments::Resolvers::RequestAttribute","title":"Direct including types"},{"location":"Routing/Arguments/Resolvers/ArgumentValueResolverInterface/#methods","text":"","title":"Methods"},{"location":"Routing/Arguments/Resolvers/ArgumentValueResolverInterface/#Athena::Routing::Arguments::Resolvers::ArgumentValueResolverInterface#resolve(request,argument)","text":"Returns a value resolved from the provided request and argument .","title":"#resolve"},{"location":"Routing/Arguments/Resolvers/ArgumentValueResolverInterface/#Athena::Routing::Arguments::Resolvers::ArgumentValueResolverInterface#supports?(request,argument)","text":"Returns true if self is able to resolve a value from the provided request and argument .","title":"#supports?"},{"location":"Routing/Arguments/Resolvers/DefaultValue/","text":"struct Athena::Routing::Arguments::Resolvers::DefaultValue inherits Struct Handles resolving an argument's default value if no other value was able to be resolved. @[ ART :: Get ( \"/\" ) ] @[ ART :: QueryParam ( \"query_param\" ) ] def get_query_param ( query_param : Int32 = 123 ) : Int32 # `query_param` would be `123` if the request does not include a query parameter named `query_param`. query_param end Included modules Athena::Routing::Arguments::Resolvers::ArgumentValueResolverInterface Class methods .new Methods #resolve ( request : HTTP::Request , argument : ART::Arguments::ArgumentMetadata ) Returns a value resolved from the provided request and argument . #supports? ( request : HTTP::Request , argument : ART::Arguments::ArgumentMetadata ) : Bool Returns true if self is able to resolve a value from the provided request and argument .","title":"DefaultValue"},{"location":"Routing/Arguments/Resolvers/DefaultValue/#Athena::Routing::Arguments::Resolvers::DefaultValue","text":"Handles resolving an argument's default value if no other value was able to be resolved. @[ ART :: Get ( \"/\" ) ] @[ ART :: QueryParam ( \"query_param\" ) ] def get_query_param ( query_param : Int32 = 123 ) : Int32 # `query_param` would be `123` if the request does not include a query parameter named `query_param`. query_param end","title":"DefaultValue"},{"location":"Routing/Arguments/Resolvers/DefaultValue/#included-modules","text":"Athena::Routing::Arguments::Resolvers::ArgumentValueResolverInterface","title":"Included modules"},{"location":"Routing/Arguments/Resolvers/DefaultValue/#class-methods","text":"","title":"Class methods"},{"location":"Routing/Arguments/Resolvers/DefaultValue/#Athena::Routing::Arguments::Resolvers::DefaultValue.new()","text":"","title":".new"},{"location":"Routing/Arguments/Resolvers/DefaultValue/#methods","text":"","title":"Methods"},{"location":"Routing/Arguments/Resolvers/DefaultValue/#Athena::Routing::Arguments::Resolvers::DefaultValue#resolve(request,argument)","text":"Returns a value resolved from the provided request and argument .","title":"#resolve"},{"location":"Routing/Arguments/Resolvers/DefaultValue/#Athena::Routing::Arguments::Resolvers::DefaultValue#supports?(request,argument)","text":"Returns true if self is able to resolve a value from the provided request and argument .","title":"#supports?"},{"location":"Routing/Arguments/Resolvers/Request/","text":"struct Athena::Routing::Arguments::Resolvers::Request inherits Struct Handles resolving a value for action arguments typed as HTTP::Request . @[ ART :: Get ( \"/\" ) ] def get_request_path ( request : HTTP :: Request ) : String request . path end Included modules Athena::Routing::Arguments::Resolvers::ArgumentValueResolverInterface Class methods .new Methods #resolve ( request : HTTP::Request , argument : ART::Arguments::ArgumentMetadata ) Returns a value resolved from the provided request and argument . #supports? ( request : HTTP::Request , argument : ART::Arguments::ArgumentMetadata ) : Bool Returns true if self is able to resolve a value from the provided request and argument .","title":"Request"},{"location":"Routing/Arguments/Resolvers/Request/#Athena::Routing::Arguments::Resolvers::Request","text":"Handles resolving a value for action arguments typed as HTTP::Request . @[ ART :: Get ( \"/\" ) ] def get_request_path ( request : HTTP :: Request ) : String request . path end","title":"Request"},{"location":"Routing/Arguments/Resolvers/Request/#included-modules","text":"Athena::Routing::Arguments::Resolvers::ArgumentValueResolverInterface","title":"Included modules"},{"location":"Routing/Arguments/Resolvers/Request/#class-methods","text":"","title":"Class methods"},{"location":"Routing/Arguments/Resolvers/Request/#Athena::Routing::Arguments::Resolvers::Request.new()","text":"","title":".new"},{"location":"Routing/Arguments/Resolvers/Request/#methods","text":"","title":"Methods"},{"location":"Routing/Arguments/Resolvers/Request/#Athena::Routing::Arguments::Resolvers::Request#resolve(request,argument)","text":"Returns a value resolved from the provided request and argument .","title":"#resolve"},{"location":"Routing/Arguments/Resolvers/Request/#Athena::Routing::Arguments::Resolvers::Request#supports?(request,argument)","text":"Returns true if self is able to resolve a value from the provided request and argument .","title":"#supports?"},{"location":"Routing/Arguments/Resolvers/RequestAttribute/","text":"struct Athena::Routing::Arguments::Resolvers::RequestAttribute inherits Struct Handles resolving a value that is stored in the request's ART::ParameterBag . This includes any path/query parameters, or custom types values stored via an AED::EventListenerInterface . @[ ART :: Get ( \"/:id\" ) ] def get_id ( id : Int32 ) : Int32 id end Included modules Athena::Routing::Arguments::Resolvers::ArgumentValueResolverInterface Class methods .new Methods #resolve ( request : HTTP::Request , argument : ART::Arguments::ArgumentMetadata ) Returns a value resolved from the provided request and argument . #supports? ( request : HTTP::Request , argument : ART::Arguments::ArgumentMetadata ) : Bool Returns true if self is able to resolve a value from the provided request and argument .","title":"RequestAttribute"},{"location":"Routing/Arguments/Resolvers/RequestAttribute/#Athena::Routing::Arguments::Resolvers::RequestAttribute","text":"Handles resolving a value that is stored in the request's ART::ParameterBag . This includes any path/query parameters, or custom types values stored via an AED::EventListenerInterface . @[ ART :: Get ( \"/:id\" ) ] def get_id ( id : Int32 ) : Int32 id end","title":"RequestAttribute"},{"location":"Routing/Arguments/Resolvers/RequestAttribute/#included-modules","text":"Athena::Routing::Arguments::Resolvers::ArgumentValueResolverInterface","title":"Included modules"},{"location":"Routing/Arguments/Resolvers/RequestAttribute/#class-methods","text":"","title":"Class methods"},{"location":"Routing/Arguments/Resolvers/RequestAttribute/#Athena::Routing::Arguments::Resolvers::RequestAttribute.new()","text":"","title":".new"},{"location":"Routing/Arguments/Resolvers/RequestAttribute/#methods","text":"","title":"Methods"},{"location":"Routing/Arguments/Resolvers/RequestAttribute/#Athena::Routing::Arguments::Resolvers::RequestAttribute#resolve(request,argument)","text":"Returns a value resolved from the provided request and argument .","title":"#resolve"},{"location":"Routing/Arguments/Resolvers/RequestAttribute/#Athena::Routing::Arguments::Resolvers::RequestAttribute#supports?(request,argument)","text":"Returns true if self is able to resolve a value from the provided request and argument .","title":"#supports?"},{"location":"Routing/Config/","text":"struct Athena::Routing::Config inherits Struct Encompasses all configuration related to the Athena::Routing component. For a higher level introduction to configuring Athena components, see Athena::Config . Included modules Athena::Config::Configuration YAML::Serializable YAML::Serializable::Strict Class methods .new ( ctx : YAML :: ParseContext , node : YAML :: Nodes :: Node ) .new Methods #cors : ART::Config::CORS ? Configuration related to Athena::Routing::Listeners::CORS . Disables the listener if not defined.","title":"Config"},{"location":"Routing/Config/#Athena::Routing::Config","text":"Encompasses all configuration related to the Athena::Routing component. For a higher level introduction to configuring Athena components, see Athena::Config .","title":"Config"},{"location":"Routing/Config/#included-modules","text":"Athena::Config::Configuration YAML::Serializable YAML::Serializable::Strict","title":"Included modules"},{"location":"Routing/Config/#class-methods","text":"","title":"Class methods"},{"location":"Routing/Config/#Athena::Routing::Config.new(ctx,node)","text":"","title":".new"},{"location":"Routing/Config/#methods","text":"","title":"Methods"},{"location":"Routing/Config/#Athena::Routing::Config#cors()","text":"Configuration related to Athena::Routing::Listeners::CORS . Disables the listener if not defined.","title":"#cors"},{"location":"Routing/Config/CORS/","text":"struct Athena::Routing::Config::CORS inherits Struct Configuration options for ART::Listeners::CORS . If ART::Config.cors is not defined in your configuration file, the listener is disabled. TODO: Allow scoping CORS options to specific routes versus applying them to all routes. See ART::Config and the external documentation for more information. Included modules Athena::Config::Configuration YAML::Serializable YAML::Serializable::Strict Class methods .new ( ctx : YAML :: ParseContext , node : YAML :: Nodes :: Node ) .new Methods #allow_credentials : Bool Indicates whether the request can be made using credentials. Maps to the access-control-allow-credentials header. #allow_headers : Array ( String ) The header or headers that can be used when making the actual request. Can be set to [\"*\"] to allow any headers. maps to the access-control-allow-headers header. #allow_methods : Array ( String ) The method or methods allowed when accessing the resource. Maps to the access-control-allow-methods header. Defaults to the CORS-safelisted methods . #allow_origin : Array ( String ) A white-listed array of valid origins. Can be set to [\"*\"] to allow any origin. TODO: Allow Regex based origins. #expose_headers : Array ( String ) Array of headers that the browser is allowed to read from the response. Maps to the access-control-expose-headers header. #max_age : Int32 Number of seconds that the results of a preflight request can be cached. Maps to the access-control-max-age header.","title":"CORS"},{"location":"Routing/Config/CORS/#Athena::Routing::Config::CORS","text":"Configuration options for ART::Listeners::CORS . If ART::Config.cors is not defined in your configuration file, the listener is disabled. TODO: Allow scoping CORS options to specific routes versus applying them to all routes. See ART::Config and the external documentation for more information.","title":"CORS"},{"location":"Routing/Config/CORS/#included-modules","text":"Athena::Config::Configuration YAML::Serializable YAML::Serializable::Strict","title":"Included modules"},{"location":"Routing/Config/CORS/#class-methods","text":"","title":"Class methods"},{"location":"Routing/Config/CORS/#Athena::Routing::Config::CORS.new(ctx,node)","text":"","title":".new"},{"location":"Routing/Config/CORS/#methods","text":"","title":"Methods"},{"location":"Routing/Config/CORS/#Athena::Routing::Config::CORS#allow_credentials()","text":"Indicates whether the request can be made using credentials. Maps to the access-control-allow-credentials header.","title":"#allow_credentials"},{"location":"Routing/Config/CORS/#Athena::Routing::Config::CORS#allow_headers()","text":"The header or headers that can be used when making the actual request. Can be set to [\"*\"] to allow any headers. maps to the access-control-allow-headers header.","title":"#allow_headers"},{"location":"Routing/Config/CORS/#Athena::Routing::Config::CORS#allow_methods()","text":"The method or methods allowed when accessing the resource. Maps to the access-control-allow-methods header. Defaults to the CORS-safelisted methods .","title":"#allow_methods"},{"location":"Routing/Config/CORS/#Athena::Routing::Config::CORS#allow_origin()","text":"A white-listed array of valid origins. Can be set to [\"*\"] to allow any origin. TODO: Allow Regex based origins.","title":"#allow_origin"},{"location":"Routing/Config/CORS/#Athena::Routing::Config::CORS#expose_headers()","text":"Array of headers that the browser is allowed to read from the response. Maps to the access-control-expose-headers header.","title":"#expose_headers"},{"location":"Routing/Config/CORS/#Athena::Routing::Config::CORS#max_age()","text":"Number of seconds that the results of a preflight request can be cached. Maps to the access-control-max-age header.","title":"#max_age"},{"location":"Routing/Controller/","text":"abstract class Athena::Routing::Controller inherits Reference The core of any framework is routing; how a route is tied to an action. Athena takes an annotation based approach; an annotation, such as ART::Get is applied to an instance method of a controller class, which will be executed when that endpoint receives a request. The annotation includes the path as well as any constraints that a parameter must meet in order for the route to be invoked. Additional annotations also exist for setting a query param or a param converter. See ART::QueryParam and ART::ParamConverter respectively. Child controllers must inherit from ART::Controller (or an abstract child of it). Each request gets its own instance of the controller to better allow for DI via Athena::DependencyInjection . A route action can either return an ART::Response , or some other type. If an ART::Response is returned, then it is used directly. Otherwise an ART::Events::View is emitted to convert the action result into an ART::Response . By default, ART::Listeners::View will JSON encode the value if it is not handled earlier by another listener. Example The following controller shows examples of the various routing features of Athena. ART::Controller also defines various macro DSLs, such as ART::Controller.get to make defining routes seem more Sinatra/Kemal like. See the documentation on the macros for more details. require \"athena\" require \"mime\" # The `ART::Prefix` annotation can be applied to a controller to define a prefix to use for all routes within `self`. @[ ART :: Prefix ( \"athena\" ) ] class TestController < ART :: Controller # A GET endpoint returning an `ART::Response`. # Can be used to return raw data, such as HTML or CSS etc, in a one-off manor. @[ ART :: Get ( path : \"/index\" ) ] def index : ART :: Response ART :: Response . new \"<h1>Welcome to my website!</h1>\" , headers : HTTP :: Headers { \"content-type\" => MIME . from_extension ( \".html\" )} end # A GET endpoint returning an `ART::StreamedResponse`. # Can be used to stream the response content to the client; useful if the content is too large to fit into memory. @[ ART :: Get ( path : \"/users\" ) ] def users : ART :: Response ART :: StreamedResponse . new headers : HTTP :: Headers { \"content-type\" => \"application/json; charset=UTF-8\" } do | io | User . all . to_json io end end # A GET endpoint using a param converter to render a template. # # Assumes there is a `User` object that exposes their name, and an `ART::ParamConverterInterface` to provide the user with the provided *id*. # ``` # # user.ecr # Morning, <%= user.name %> it is currently <%= time %>. # ``` @[ ART :: ParamConverter ( \"user\" , converter : SomeConverter ) ] @[ ART :: Get ( \"/wakeup/:id\" ) ] def wakeup ( user : User ) : ART :: Response # Template variables not supplied in the action's arguments must be defined manually time = Time . utc # Creates an `ART::Response` with the content of rendering the template, also sets the content type to `text/html`. render \"user.ecr\" end # A GET endpoint with no params returning a `String`. # # Action return type restrictions are required. @[ ART :: Get ( \"/me\" ) ] def get_me : String \"Jim\" end # A GET endpoint with no params returning `Nil`. # `Nil` return types are returned with a status # of 204 no content @[ ART :: Get ( \"/no_content\" ) ] def get_no_content : Nil # Do stuff end # A GET endpoint with two `Int32` params returning an `Int32`. # # The parameters of a route _MUST_ match the arguments of the action. # Type restrictions on action arguments are required. @[ ART :: Get ( \"/add/:val1/:val2\" ) ] def add ( val1 : Int32 , val2 : Int32 ) : Int32 val1 + val2 end # A GET endpoint with an `String` route param, and a required string query param that must match the given pattern; returning a `String`. # # A non-nilable type denotes it as required. If the parameter is not supplied, and no default value is assigned, an `ART::Exceptions::BadRequest` exception is raised. @[ ART :: QueryParam ( \"time\" , constraints : /\\d:\\d:\\d/ ) ] @[ ART :: Get ( \"/event/:event_name/\" ) ] def event_time ( event_name : String , time : String ) : String \" #{ event_name } occurred at #{ time } \" end # A GET endpoint with an optional query parameter and optional path param with a default value; returning a `NamedTuple(user_id : Int32?, page : Int32)`. # # A nilable type denotes it as optional. If the parameter is not supplied (or could not be converted), and no default value is assigned, it is `nil`. @[ ART :: QueryParam ( \"user_id\" ) ] @[ ART :: Get ( \"/events/(:page)\" ) ] def events ( user_id : Int32 ?, page : Int32 = 1 ) : NamedTuple ( user_id : Int32 ?, page : Int32 ) { user_id : user_id , page : page } end # A GET endpoint with param constraints. The param must match the supplied Regex or it will not match and return a 404 error. @[ ART :: Get ( \"/time/:time/\" , constraints : { \"time\" => /\\d{2}:\\d{2}:\\d{2}/ }) ] def get_constraint ( time : String ) : String time end # A POST endpoint with a route param and accessing the request body; returning a `Bool`. # # It is recommended to use param converters to pass an actual object representing the data (assuming the body is JSON) # to the route's action; however the raw request body can be accessed by typing an action argument as `HTTP::Request`. @[ ART :: Post ( \"/test/:expected\" ) ] def post_body ( expected : String , request : HTTP :: Request ) : Bool expected == request . body . try &. gets_to_end end end ART . run # GET /athena/index\" # => <h1>Welcome to my website!</h1> # GET /athena/users\" # => [{\"id\":1,...},...] # GET /athena/wakeup/17\" # => Morning, Allison it is currently 2020-02-01 18:38:12 UTC. # GET /athena/me\" # => \"Jim\" # GET /athena/add/50/25\" # => 75 # GET /athena/event/foobar?time=1:1:1\" # => \"foobar occurred at 1:1:1\" # GET /athena/events\" # => {\"user_id\":null,\"page\":1} # GET /athena/events/17?user_id=19\" # => {\"user_id\":19,\"page\":17} # GET /athena/time/12:45:30\" # => \"12:45:30\" # GET /athena/time/12:aa:30\" # => 404 not found # GET /athena/no_content\" # => 204 no content # POST /athena/test/foo\", body: \"foo\" # => true Methods #generate_url ( route : String , params : Hash ( String , _ )? = nil , reference_type : ART::URLGeneratorInterface::ReferenceType = :absolute_path ) : String Generates a URL to the provided route with the provided params . See ART::URLGeneratorInterface#generate . #generate_url ( route : String , reference_type : ART::URLGeneratorInterface::ReferenceType = :absolute_path , ** params ) Generates a URL to the provided route with the provided params . See ART::URLGeneratorInterface#generate . #redirect ( url : String , status : HTTP :: Status = HTTP :: Status :: FOUND ) : ART::RedirectResponse Returns an ART::RedirectResponse to the provided url , optionally with the provided status . class ExampleController < ART :: Controller @[ ART :: Get ( \"redirect_to_google\" ) ] def redirect_to_google : ART :: RedirectResponse self . redirect \"https://google.com\" end end #redirect_to_route ( route : String , params : Hash ( String , _ )? = nil , status : HTTP :: Status = :found ) : ART::RedirectResponse Returns an ART::RedirectResponse to the provided route with the provided params . require \"athena\" class ExampleController < ART :: Controller # Define a route to redirect to, explicitly naming this route `add`. # The default route name is controller + method down snake-cased; e.x. `example_controller_add`. @[ ART :: Get ( \"/add/:value1/:value2\" , name : \"add\" ) ] def add ( value1 : Int32 , value2 : Int32 , negative : Bool = false ) : Int32 sum = value1 + value2 negative ? - sum : sum end # Define a route that redirects to the `add` route with fixed parameters. @[ ART :: Get ( \"/\" ) ] def redirect : ART :: RedirectResponse self . redirect_to_route \"add\" , { \"value1\" => 8 , \"value2\" => 2 } end end ART . run # GET / # => 10 #redirect_to_route ( route : String , status : HTTP :: Status = :found , ** params ) : ART::RedirectResponse Returns an ART::RedirectResponse to the provided route with the provided params . require \"athena\" class ExampleController < ART :: Controller # Define a route to redirect to, explicitly naming this route `add`. # The default route name is controller + method down snake-cased; e.x. `example_controller_add`. @[ ART :: Get ( \"/add/:value1/:value2\" , name : \"add\" ) ] def add ( value1 : Int32 , value2 : Int32 , negative : Bool = false ) : Int32 sum = value1 + value2 negative ? - sum : sum end # Define a route that redirects to the `add` route with fixed parameters. @[ ART :: Get ( \"/\" ) ] def redirect : ART :: RedirectResponse self . redirect_to_route \"add\" , value1 : 8 , value2 : 2 end end ART . run # GET / # => 10 Macros delete Helper DSL macro for creating DELETE actions. The first argument is the path that the action should handle; which maps to path on the HTTP method annotation. The second argument is a variable amount of arguments with a syntax similar to Crystal's record . There are also a few optional named arguments that map to the corresponding field on the HTTP method annotation. The macro simply defines a method based on the options passed to it. Additional annotations, such as for query params or a param converter can simply be added on top of the macro. Optional Named Arguments return_type - The return type to set for the action. Defaults to String if not provided. constraints - Any constraints that should be applied to the route. Example class ExampleController < ART :: Controller delete \"values/:value1/:value2\" , value1 : Int32 , value2 : Float64 , constraints : { \"value1\" => /\\d+/ , \"value2\" => /\\d+\\.\\d+/ } do \"Value1: #{ value1 } - Value2: #{ value2 } \" end end get Helper DSL macro for creating GET actions. The first argument is the path that the action should handle; which maps to path on the HTTP method annotation. The second argument is a variable amount of arguments with a syntax similar to Crystal's record . There are also a few optional named arguments that map to the corresponding field on the HTTP method annotation. The macro simply defines a method based on the options passed to it. Additional annotations, such as for query params or a param converter can simply be added on top of the macro. Optional Named Arguments return_type - The return type to set for the action. Defaults to String if not provided. constraints - Any constraints that should be applied to the route. Example class ExampleController < ART :: Controller get \"values/:value1/:value2\" , value1 : Int32 , value2 : Float64 , constraints : { \"value1\" => /\\d+/ , \"value2\" => /\\d+\\.\\d+/ } do \"Value1: #{ value1 } - Value2: #{ value2 } \" end end head Helper DSL macro for creating HEAD actions. The first argument is the path that the action should handle; which maps to path on the HTTP method annotation. The second argument is a variable amount of arguments with a syntax similar to Crystal's record . There are also a few optional named arguments that map to the corresponding field on the HTTP method annotation. The macro simply defines a method based on the options passed to it. Additional annotations, such as for query params or a param converter can simply be added on top of the macro. Optional Named Arguments return_type - The return type to set for the action. Defaults to String if not provided. constraints - Any constraints that should be applied to the route. Example class ExampleController < ART :: Controller head \"values/:value1/:value2\" , value1 : Int32 , value2 : Float64 , constraints : { \"value1\" => /\\d+/ , \"value2\" => /\\d+\\.\\d+/ } do \"Value1: #{ value1 } - Value2: #{ value2 } \" end end link Helper DSL macro for creating LINK actions. The first argument is the path that the action should handle; which maps to path on the HTTP method annotation. The second argument is a variable amount of arguments with a syntax similar to Crystal's record . There are also a few optional named arguments that map to the corresponding field on the HTTP method annotation. The macro simply defines a method based on the options passed to it. Additional annotations, such as for query params or a param converter can simply be added on top of the macro. Optional Named Arguments return_type - The return type to set for the action. Defaults to String if not provided. constraints - Any constraints that should be applied to the route. Example class ExampleController < ART :: Controller link \"values/:value1/:value2\" , value1 : Int32 , value2 : Float64 , constraints : { \"value1\" => /\\d+/ , \"value2\" => /\\d+\\.\\d+/ } do \"Value1: #{ value1 } - Value2: #{ value2 } \" end end patch Helper DSL macro for creating PATCH actions. The first argument is the path that the action should handle; which maps to path on the HTTP method annotation. The second argument is a variable amount of arguments with a syntax similar to Crystal's record . There are also a few optional named arguments that map to the corresponding field on the HTTP method annotation. The macro simply defines a method based on the options passed to it. Additional annotations, such as for query params or a param converter can simply be added on top of the macro. Optional Named Arguments return_type - The return type to set for the action. Defaults to String if not provided. constraints - Any constraints that should be applied to the route. Example class ExampleController < ART :: Controller patch \"values/:value1/:value2\" , value1 : Int32 , value2 : Float64 , constraints : { \"value1\" => /\\d+/ , \"value2\" => /\\d+\\.\\d+/ } do \"Value1: #{ value1 } - Value2: #{ value2 } \" end end post Helper DSL macro for creating POST actions. The first argument is the path that the action should handle; which maps to path on the HTTP method annotation. The second argument is a variable amount of arguments with a syntax similar to Crystal's record . There are also a few optional named arguments that map to the corresponding field on the HTTP method annotation. The macro simply defines a method based on the options passed to it. Additional annotations, such as for query params or a param converter can simply be added on top of the macro. Optional Named Arguments return_type - The return type to set for the action. Defaults to String if not provided. constraints - Any constraints that should be applied to the route. Example class ExampleController < ART :: Controller post \"values/:value1/:value2\" , value1 : Int32 , value2 : Float64 , constraints : { \"value1\" => /\\d+/ , \"value2\" => /\\d+\\.\\d+/ } do \"Value1: #{ value1 } - Value2: #{ value2 } \" end end put Helper DSL macro for creating PUT actions. The first argument is the path that the action should handle; which maps to path on the HTTP method annotation. The second argument is a variable amount of arguments with a syntax similar to Crystal's record . There are also a few optional named arguments that map to the corresponding field on the HTTP method annotation. The macro simply defines a method based on the options passed to it. Additional annotations, such as for query params or a param converter can simply be added on top of the macro. Optional Named Arguments return_type - The return type to set for the action. Defaults to String if not provided. constraints - Any constraints that should be applied to the route. Example class ExampleController < ART :: Controller put \"values/:value1/:value2\" , value1 : Int32 , value2 : Float64 , constraints : { \"value1\" => /\\d+/ , \"value2\" => /\\d+\\.\\d+/ } do \"Value1: #{ value1 } - Value2: #{ value2 } \" end end render ( template ) Renders a template. Uses ECR to render the template , creating an ART::Response with its rendered content and adding a text/html content-type header. The response can be modified further before returning it if needed. Variables used within the template must be defined within the action's body manually if they are not provided within the action's arguments. # greeting.ecr Greetings , <%= name %>! # example_controller.cr class ExampleController < ART :: Controller @[ ART :: Get ( \"/:name\" ) ] def greet ( name : String ) : ART :: Response render \"greeting.ecr\" end end ART . run # GET /Fred # => Greetings, Fred! render ( template , layout ) Renders a template within a layout. # layout.ecr < h1 > Content : < /h1> <%= content -%> # greeting.ecr Greetings, <%= name %>! # example_controller.cr class ExampleController < ART::Controller @[ART::Get(\"/ :name \")] def greet(name : String) : ART::Response render \" greeting . ecr \", \" layout . ecr \" end end ART.run # GET /Fred # => <h1>Content:</h1> Greetings, Fred! unlink Helper DSL macro for creating UNLINK actions. The first argument is the path that the action should handle; which maps to path on the HTTP method annotation. The second argument is a variable amount of arguments with a syntax similar to Crystal's record . There are also a few optional named arguments that map to the corresponding field on the HTTP method annotation. The macro simply defines a method based on the options passed to it. Additional annotations, such as for query params or a param converter can simply be added on top of the macro. Optional Named Arguments return_type - The return type to set for the action. Defaults to String if not provided. constraints - Any constraints that should be applied to the route. Example class ExampleController < ART :: Controller unlink \"values/:value1/:value2\" , value1 : Int32 , value2 : Float64 , constraints : { \"value1\" => /\\d+/ , \"value2\" => /\\d+\\.\\d+/ } do \"Value1: #{ value1 } - Value2: #{ value2 } \" end end","title":"Controller"},{"location":"Routing/Controller/#Athena::Routing::Controller","text":"The core of any framework is routing; how a route is tied to an action. Athena takes an annotation based approach; an annotation, such as ART::Get is applied to an instance method of a controller class, which will be executed when that endpoint receives a request. The annotation includes the path as well as any constraints that a parameter must meet in order for the route to be invoked. Additional annotations also exist for setting a query param or a param converter. See ART::QueryParam and ART::ParamConverter respectively. Child controllers must inherit from ART::Controller (or an abstract child of it). Each request gets its own instance of the controller to better allow for DI via Athena::DependencyInjection . A route action can either return an ART::Response , or some other type. If an ART::Response is returned, then it is used directly. Otherwise an ART::Events::View is emitted to convert the action result into an ART::Response . By default, ART::Listeners::View will JSON encode the value if it is not handled earlier by another listener.","title":"Controller"},{"location":"Routing/Controller/#Athena::Routing::Controller--example","text":"The following controller shows examples of the various routing features of Athena. ART::Controller also defines various macro DSLs, such as ART::Controller.get to make defining routes seem more Sinatra/Kemal like. See the documentation on the macros for more details. require \"athena\" require \"mime\" # The `ART::Prefix` annotation can be applied to a controller to define a prefix to use for all routes within `self`. @[ ART :: Prefix ( \"athena\" ) ] class TestController < ART :: Controller # A GET endpoint returning an `ART::Response`. # Can be used to return raw data, such as HTML or CSS etc, in a one-off manor. @[ ART :: Get ( path : \"/index\" ) ] def index : ART :: Response ART :: Response . new \"<h1>Welcome to my website!</h1>\" , headers : HTTP :: Headers { \"content-type\" => MIME . from_extension ( \".html\" )} end # A GET endpoint returning an `ART::StreamedResponse`. # Can be used to stream the response content to the client; useful if the content is too large to fit into memory. @[ ART :: Get ( path : \"/users\" ) ] def users : ART :: Response ART :: StreamedResponse . new headers : HTTP :: Headers { \"content-type\" => \"application/json; charset=UTF-8\" } do | io | User . all . to_json io end end # A GET endpoint using a param converter to render a template. # # Assumes there is a `User` object that exposes their name, and an `ART::ParamConverterInterface` to provide the user with the provided *id*. # ``` # # user.ecr # Morning, <%= user.name %> it is currently <%= time %>. # ``` @[ ART :: ParamConverter ( \"user\" , converter : SomeConverter ) ] @[ ART :: Get ( \"/wakeup/:id\" ) ] def wakeup ( user : User ) : ART :: Response # Template variables not supplied in the action's arguments must be defined manually time = Time . utc # Creates an `ART::Response` with the content of rendering the template, also sets the content type to `text/html`. render \"user.ecr\" end # A GET endpoint with no params returning a `String`. # # Action return type restrictions are required. @[ ART :: Get ( \"/me\" ) ] def get_me : String \"Jim\" end # A GET endpoint with no params returning `Nil`. # `Nil` return types are returned with a status # of 204 no content @[ ART :: Get ( \"/no_content\" ) ] def get_no_content : Nil # Do stuff end # A GET endpoint with two `Int32` params returning an `Int32`. # # The parameters of a route _MUST_ match the arguments of the action. # Type restrictions on action arguments are required. @[ ART :: Get ( \"/add/:val1/:val2\" ) ] def add ( val1 : Int32 , val2 : Int32 ) : Int32 val1 + val2 end # A GET endpoint with an `String` route param, and a required string query param that must match the given pattern; returning a `String`. # # A non-nilable type denotes it as required. If the parameter is not supplied, and no default value is assigned, an `ART::Exceptions::BadRequest` exception is raised. @[ ART :: QueryParam ( \"time\" , constraints : /\\d:\\d:\\d/ ) ] @[ ART :: Get ( \"/event/:event_name/\" ) ] def event_time ( event_name : String , time : String ) : String \" #{ event_name } occurred at #{ time } \" end # A GET endpoint with an optional query parameter and optional path param with a default value; returning a `NamedTuple(user_id : Int32?, page : Int32)`. # # A nilable type denotes it as optional. If the parameter is not supplied (or could not be converted), and no default value is assigned, it is `nil`. @[ ART :: QueryParam ( \"user_id\" ) ] @[ ART :: Get ( \"/events/(:page)\" ) ] def events ( user_id : Int32 ?, page : Int32 = 1 ) : NamedTuple ( user_id : Int32 ?, page : Int32 ) { user_id : user_id , page : page } end # A GET endpoint with param constraints. The param must match the supplied Regex or it will not match and return a 404 error. @[ ART :: Get ( \"/time/:time/\" , constraints : { \"time\" => /\\d{2}:\\d{2}:\\d{2}/ }) ] def get_constraint ( time : String ) : String time end # A POST endpoint with a route param and accessing the request body; returning a `Bool`. # # It is recommended to use param converters to pass an actual object representing the data (assuming the body is JSON) # to the route's action; however the raw request body can be accessed by typing an action argument as `HTTP::Request`. @[ ART :: Post ( \"/test/:expected\" ) ] def post_body ( expected : String , request : HTTP :: Request ) : Bool expected == request . body . try &. gets_to_end end end ART . run # GET /athena/index\" # => <h1>Welcome to my website!</h1> # GET /athena/users\" # => [{\"id\":1,...},...] # GET /athena/wakeup/17\" # => Morning, Allison it is currently 2020-02-01 18:38:12 UTC. # GET /athena/me\" # => \"Jim\" # GET /athena/add/50/25\" # => 75 # GET /athena/event/foobar?time=1:1:1\" # => \"foobar occurred at 1:1:1\" # GET /athena/events\" # => {\"user_id\":null,\"page\":1} # GET /athena/events/17?user_id=19\" # => {\"user_id\":19,\"page\":17} # GET /athena/time/12:45:30\" # => \"12:45:30\" # GET /athena/time/12:aa:30\" # => 404 not found # GET /athena/no_content\" # => 204 no content # POST /athena/test/foo\", body: \"foo\" # => true","title":"Example"},{"location":"Routing/Controller/#methods","text":"","title":"Methods"},{"location":"Routing/Controller/#Athena::Routing::Controller#generate_url(route,params,reference_type)","text":"Generates a URL to the provided route with the provided params . See ART::URLGeneratorInterface#generate .","title":"#generate_url"},{"location":"Routing/Controller/#Athena::Routing::Controller#redirect(url,status)","text":"Returns an ART::RedirectResponse to the provided url , optionally with the provided status . class ExampleController < ART :: Controller @[ ART :: Get ( \"redirect_to_google\" ) ] def redirect_to_google : ART :: RedirectResponse self . redirect \"https://google.com\" end end","title":"#redirect"},{"location":"Routing/Controller/#Athena::Routing::Controller#redirect_to_route(route,params,status)","text":"Returns an ART::RedirectResponse to the provided route with the provided params . require \"athena\" class ExampleController < ART :: Controller # Define a route to redirect to, explicitly naming this route `add`. # The default route name is controller + method down snake-cased; e.x. `example_controller_add`. @[ ART :: Get ( \"/add/:value1/:value2\" , name : \"add\" ) ] def add ( value1 : Int32 , value2 : Int32 , negative : Bool = false ) : Int32 sum = value1 + value2 negative ? - sum : sum end # Define a route that redirects to the `add` route with fixed parameters. @[ ART :: Get ( \"/\" ) ] def redirect : ART :: RedirectResponse self . redirect_to_route \"add\" , { \"value1\" => 8 , \"value2\" => 2 } end end ART . run # GET / # => 10","title":"#redirect_to_route"},{"location":"Routing/Controller/#macros","text":"","title":"Macros"},{"location":"Routing/Controller/#Athena::Routing::Controller:delete(path,*args,**named_args,&)","text":"Helper DSL macro for creating DELETE actions. The first argument is the path that the action should handle; which maps to path on the HTTP method annotation. The second argument is a variable amount of arguments with a syntax similar to Crystal's record . There are also a few optional named arguments that map to the corresponding field on the HTTP method annotation. The macro simply defines a method based on the options passed to it. Additional annotations, such as for query params or a param converter can simply be added on top of the macro.","title":"delete"},{"location":"Routing/Controller/#Athena::Routing::Controller:delete(path,*args,**named_args,&)--optional-named-arguments","text":"return_type - The return type to set for the action. Defaults to String if not provided. constraints - Any constraints that should be applied to the route.","title":"Optional Named Arguments"},{"location":"Routing/Controller/#Athena::Routing::Controller:delete(path,*args,**named_args,&)--example","text":"class ExampleController < ART :: Controller delete \"values/:value1/:value2\" , value1 : Int32 , value2 : Float64 , constraints : { \"value1\" => /\\d+/ , \"value2\" => /\\d+\\.\\d+/ } do \"Value1: #{ value1 } - Value2: #{ value2 } \" end end","title":"Example"},{"location":"Routing/Controller/#Athena::Routing::Controller:get(path,*args,**named_args,&)","text":"Helper DSL macro for creating GET actions. The first argument is the path that the action should handle; which maps to path on the HTTP method annotation. The second argument is a variable amount of arguments with a syntax similar to Crystal's record . There are also a few optional named arguments that map to the corresponding field on the HTTP method annotation. The macro simply defines a method based on the options passed to it. Additional annotations, such as for query params or a param converter can simply be added on top of the macro.","title":"get"},{"location":"Routing/Controller/#Athena::Routing::Controller:get(path,*args,**named_args,&)--optional-named-arguments","text":"return_type - The return type to set for the action. Defaults to String if not provided. constraints - Any constraints that should be applied to the route.","title":"Optional Named Arguments"},{"location":"Routing/Controller/#Athena::Routing::Controller:get(path,*args,**named_args,&)--example","text":"class ExampleController < ART :: Controller get \"values/:value1/:value2\" , value1 : Int32 , value2 : Float64 , constraints : { \"value1\" => /\\d+/ , \"value2\" => /\\d+\\.\\d+/ } do \"Value1: #{ value1 } - Value2: #{ value2 } \" end end","title":"Example"},{"location":"Routing/Controller/#Athena::Routing::Controller:head(path,*args,**named_args,&)","text":"Helper DSL macro for creating HEAD actions. The first argument is the path that the action should handle; which maps to path on the HTTP method annotation. The second argument is a variable amount of arguments with a syntax similar to Crystal's record . There are also a few optional named arguments that map to the corresponding field on the HTTP method annotation. The macro simply defines a method based on the options passed to it. Additional annotations, such as for query params or a param converter can simply be added on top of the macro.","title":"head"},{"location":"Routing/Controller/#Athena::Routing::Controller:head(path,*args,**named_args,&)--optional-named-arguments","text":"return_type - The return type to set for the action. Defaults to String if not provided. constraints - Any constraints that should be applied to the route.","title":"Optional Named Arguments"},{"location":"Routing/Controller/#Athena::Routing::Controller:head(path,*args,**named_args,&)--example","text":"class ExampleController < ART :: Controller head \"values/:value1/:value2\" , value1 : Int32 , value2 : Float64 , constraints : { \"value1\" => /\\d+/ , \"value2\" => /\\d+\\.\\d+/ } do \"Value1: #{ value1 } - Value2: #{ value2 } \" end end","title":"Example"},{"location":"Routing/Controller/#Athena::Routing::Controller:link(path,*args,**named_args,&)","text":"Helper DSL macro for creating LINK actions. The first argument is the path that the action should handle; which maps to path on the HTTP method annotation. The second argument is a variable amount of arguments with a syntax similar to Crystal's record . There are also a few optional named arguments that map to the corresponding field on the HTTP method annotation. The macro simply defines a method based on the options passed to it. Additional annotations, such as for query params or a param converter can simply be added on top of the macro.","title":"link"},{"location":"Routing/Controller/#Athena::Routing::Controller:link(path,*args,**named_args,&)--optional-named-arguments","text":"return_type - The return type to set for the action. Defaults to String if not provided. constraints - Any constraints that should be applied to the route.","title":"Optional Named Arguments"},{"location":"Routing/Controller/#Athena::Routing::Controller:link(path,*args,**named_args,&)--example","text":"class ExampleController < ART :: Controller link \"values/:value1/:value2\" , value1 : Int32 , value2 : Float64 , constraints : { \"value1\" => /\\d+/ , \"value2\" => /\\d+\\.\\d+/ } do \"Value1: #{ value1 } - Value2: #{ value2 } \" end end","title":"Example"},{"location":"Routing/Controller/#Athena::Routing::Controller:patch(path,*args,**named_args,&)","text":"Helper DSL macro for creating PATCH actions. The first argument is the path that the action should handle; which maps to path on the HTTP method annotation. The second argument is a variable amount of arguments with a syntax similar to Crystal's record . There are also a few optional named arguments that map to the corresponding field on the HTTP method annotation. The macro simply defines a method based on the options passed to it. Additional annotations, such as for query params or a param converter can simply be added on top of the macro.","title":"patch"},{"location":"Routing/Controller/#Athena::Routing::Controller:patch(path,*args,**named_args,&)--optional-named-arguments","text":"return_type - The return type to set for the action. Defaults to String if not provided. constraints - Any constraints that should be applied to the route.","title":"Optional Named Arguments"},{"location":"Routing/Controller/#Athena::Routing::Controller:patch(path,*args,**named_args,&)--example","text":"class ExampleController < ART :: Controller patch \"values/:value1/:value2\" , value1 : Int32 , value2 : Float64 , constraints : { \"value1\" => /\\d+/ , \"value2\" => /\\d+\\.\\d+/ } do \"Value1: #{ value1 } - Value2: #{ value2 } \" end end","title":"Example"},{"location":"Routing/Controller/#Athena::Routing::Controller:post(path,*args,**named_args,&)","text":"Helper DSL macro for creating POST actions. The first argument is the path that the action should handle; which maps to path on the HTTP method annotation. The second argument is a variable amount of arguments with a syntax similar to Crystal's record . There are also a few optional named arguments that map to the corresponding field on the HTTP method annotation. The macro simply defines a method based on the options passed to it. Additional annotations, such as for query params or a param converter can simply be added on top of the macro.","title":"post"},{"location":"Routing/Controller/#Athena::Routing::Controller:post(path,*args,**named_args,&)--optional-named-arguments","text":"return_type - The return type to set for the action. Defaults to String if not provided. constraints - Any constraints that should be applied to the route.","title":"Optional Named Arguments"},{"location":"Routing/Controller/#Athena::Routing::Controller:post(path,*args,**named_args,&)--example","text":"class ExampleController < ART :: Controller post \"values/:value1/:value2\" , value1 : Int32 , value2 : Float64 , constraints : { \"value1\" => /\\d+/ , \"value2\" => /\\d+\\.\\d+/ } do \"Value1: #{ value1 } - Value2: #{ value2 } \" end end","title":"Example"},{"location":"Routing/Controller/#Athena::Routing::Controller:put(path,*args,**named_args,&)","text":"Helper DSL macro for creating PUT actions. The first argument is the path that the action should handle; which maps to path on the HTTP method annotation. The second argument is a variable amount of arguments with a syntax similar to Crystal's record . There are also a few optional named arguments that map to the corresponding field on the HTTP method annotation. The macro simply defines a method based on the options passed to it. Additional annotations, such as for query params or a param converter can simply be added on top of the macro.","title":"put"},{"location":"Routing/Controller/#Athena::Routing::Controller:put(path,*args,**named_args,&)--optional-named-arguments","text":"return_type - The return type to set for the action. Defaults to String if not provided. constraints - Any constraints that should be applied to the route.","title":"Optional Named Arguments"},{"location":"Routing/Controller/#Athena::Routing::Controller:put(path,*args,**named_args,&)--example","text":"class ExampleController < ART :: Controller put \"values/:value1/:value2\" , value1 : Int32 , value2 : Float64 , constraints : { \"value1\" => /\\d+/ , \"value2\" => /\\d+\\.\\d+/ } do \"Value1: #{ value1 } - Value2: #{ value2 } \" end end","title":"Example"},{"location":"Routing/Controller/#Athena::Routing::Controller:render(template)","text":"Renders a template. Uses ECR to render the template , creating an ART::Response with its rendered content and adding a text/html content-type header. The response can be modified further before returning it if needed. Variables used within the template must be defined within the action's body manually if they are not provided within the action's arguments. # greeting.ecr Greetings , <%= name %>! # example_controller.cr class ExampleController < ART :: Controller @[ ART :: Get ( \"/:name\" ) ] def greet ( name : String ) : ART :: Response render \"greeting.ecr\" end end ART . run # GET /Fred # => Greetings, Fred!","title":"render"},{"location":"Routing/Controller/#Athena::Routing::Controller:unlink(path,*args,**named_args,&)","text":"Helper DSL macro for creating UNLINK actions. The first argument is the path that the action should handle; which maps to path on the HTTP method annotation. The second argument is a variable amount of arguments with a syntax similar to Crystal's record . There are also a few optional named arguments that map to the corresponding field on the HTTP method annotation. The macro simply defines a method based on the options passed to it. Additional annotations, such as for query params or a param converter can simply be added on top of the macro.","title":"unlink"},{"location":"Routing/Controller/#Athena::Routing::Controller:unlink(path,*args,**named_args,&)--optional-named-arguments","text":"return_type - The return type to set for the action. Defaults to String if not provided. constraints - Any constraints that should be applied to the route.","title":"Optional Named Arguments"},{"location":"Routing/Controller/#Athena::Routing::Controller:unlink(path,*args,**named_args,&)--example","text":"class ExampleController < ART :: Controller unlink \"values/:value1/:value2\" , value1 : Int32 , value2 : Float64 , constraints : { \"value1\" => /\\d+/ , \"value2\" => /\\d+\\.\\d+/ } do \"Value1: #{ value1 } - Value2: #{ value2 } \" end end","title":"Example"},{"location":"Routing/Delete/","text":"annotation Athena::Routing::Delete Defines a DELETE endpoint. Fields path : String - The path for the endpoint, may also be provided as the first positional argument. name : String - The name of the route. Defaults to controller name + method name down snake-cased. constraints : Hash(String, Regex) - A mapping between a route's path parameters and its constraints. Example @[ ART :: Delete ( path : \"/users/:id\" ) ] def delete_user ( id : Int32 ) : Nil end","title":"Delete"},{"location":"Routing/Delete/#Athena::Routing::Delete","text":"Defines a DELETE endpoint.","title":"Delete"},{"location":"Routing/Delete/#Athena::Routing::Delete--fields","text":"path : String - The path for the endpoint, may also be provided as the first positional argument. name : String - The name of the route. Defaults to controller name + method name down snake-cased. constraints : Hash(String, Regex) - A mapping between a route's path parameters and its constraints.","title":"Fields"},{"location":"Routing/Delete/#Athena::Routing::Delete--example","text":"@[ ART :: Delete ( path : \"/users/:id\" ) ] def delete_user ( id : Int32 ) : Nil end","title":"Example"},{"location":"Routing/ErrorRenderer/","text":"struct Athena::Routing::ErrorRenderer inherits Struct The default ART::ErrorRendererInterface , JSON serializes the exception. Included modules Athena::Routing::ErrorRendererInterface Class methods .new Methods #render ( exception : Exception ) : ART::Response Renders the given exception into an ART::Response .","title":"ErrorRenderer"},{"location":"Routing/ErrorRenderer/#Athena::Routing::ErrorRenderer","text":"The default ART::ErrorRendererInterface , JSON serializes the exception.","title":"ErrorRenderer"},{"location":"Routing/ErrorRenderer/#included-modules","text":"Athena::Routing::ErrorRendererInterface","title":"Included modules"},{"location":"Routing/ErrorRenderer/#class-methods","text":"","title":"Class methods"},{"location":"Routing/ErrorRenderer/#Athena::Routing::ErrorRenderer.new()","text":"","title":".new"},{"location":"Routing/ErrorRenderer/#methods","text":"","title":"Methods"},{"location":"Routing/ErrorRenderer/#Athena::Routing::ErrorRenderer#render(exception)","text":"Renders the given exception into an ART::Response .","title":"#render"},{"location":"Routing/ErrorRendererInterface/","text":"module Athena::Routing::ErrorRendererInterface An ART::ErrorRendererInterface converts an ::Exception into an ART::Response . By default, exceptions are JSON serialized via ART::ErrorRenderer . However, it can be overridden to allow rendering errors differently, such as via HTML. require \"athena\" # Alias this service to be used when the `ART::ErrorRendererInterface` type is encountered. @[ ADI :: Register ( alias : ART :: ErrorRendererInterface ) ] struct Athena::Routing:: CustomErrorRenderer include Athena :: Routing :: ErrorRendererInterface # :inherit: def render ( exception : :: Exception ) : ART :: Response if exception . is_a? ART :: Exceptions :: HTTPException status = exception . status headers = exception . headers else status = HTTP :: Status :: INTERNAL_SERVER_ERROR headers = HTTP :: Headers . new end body = <<- HTML <html> <head> <title>Uh oh</title> </head> <body> <h1>Uh oh, something went wrong</h1> </body> </html> HTML headers [ \"content-type\" ] = \"text/html\" ART :: Response . new body , status , headers end end class TestController < ART :: Controller get \"/\" do raise \"some error\" end end ART . run # GET / # => <html><head><title>Uh oh</title></head><body><h1>Uh oh, something went wrong</h1></body></html> Direct including types Athena::Routing::ErrorRenderer Methods abstract #render ( exception : Exception ) : ART::Response Renders the given exception into an ART::Response .","title":"ErrorRendererInterface"},{"location":"Routing/ErrorRendererInterface/#Athena::Routing::ErrorRendererInterface","text":"An ART::ErrorRendererInterface converts an ::Exception into an ART::Response . By default, exceptions are JSON serialized via ART::ErrorRenderer . However, it can be overridden to allow rendering errors differently, such as via HTML. require \"athena\" # Alias this service to be used when the `ART::ErrorRendererInterface` type is encountered. @[ ADI :: Register ( alias : ART :: ErrorRendererInterface ) ] struct Athena::Routing:: CustomErrorRenderer include Athena :: Routing :: ErrorRendererInterface # :inherit: def render ( exception : :: Exception ) : ART :: Response if exception . is_a? ART :: Exceptions :: HTTPException status = exception . status headers = exception . headers else status = HTTP :: Status :: INTERNAL_SERVER_ERROR headers = HTTP :: Headers . new end body = <<- HTML <html> <head> <title>Uh oh</title> </head> <body> <h1>Uh oh, something went wrong</h1> </body> </html> HTML headers [ \"content-type\" ] = \"text/html\" ART :: Response . new body , status , headers end end class TestController < ART :: Controller get \"/\" do raise \"some error\" end end ART . run # GET / # => <html><head><title>Uh oh</title></head><body><h1>Uh oh, something went wrong</h1></body></html>","title":"ErrorRendererInterface"},{"location":"Routing/ErrorRendererInterface/#direct-including-types","text":"Athena::Routing::ErrorRenderer","title":"Direct including types"},{"location":"Routing/ErrorRendererInterface/#methods","text":"","title":"Methods"},{"location":"Routing/ErrorRendererInterface/#Athena::Routing::ErrorRendererInterface#render(exception)","text":"Renders the given exception into an ART::Response .","title":"#render"},{"location":"Routing/Events/","text":"module Athena::Routing::Events The AED::Event that are emitted via Athena::EventDispatcher to handle a request during its life-cycle. Custom events can also be defined and dispatched within a controller, listener, or some other service. See each specific event and the external documentation for more information.","title":"Events"},{"location":"Routing/Events/#Athena::Routing::Events","text":"The AED::Event that are emitted via Athena::EventDispatcher to handle a request during its life-cycle. Custom events can also be defined and dispatched within a controller, listener, or some other service. See each specific event and the external documentation for more information.","title":"Events"},{"location":"Routing/Events/Action/","text":"class Athena::Routing::Events::Action inherits Athena::EventDispatcher::Event Emitted after ART::Events::Request and the related ART::Action has been resolved, but before it has been executed. See the external documentation for more information. Included modules Athena::Routing::Events::RequestAware Class methods .new ( request : HTTP::Request , action : ART::ActionBase ) Methods #action : ART::ActionBase The related ART::Action that will be used to handle the current request.","title":"Action"},{"location":"Routing/Events/Action/#Athena::Routing::Events::Action","text":"Emitted after ART::Events::Request and the related ART::Action has been resolved, but before it has been executed. See the external documentation for more information.","title":"Action"},{"location":"Routing/Events/Action/#included-modules","text":"Athena::Routing::Events::RequestAware","title":"Included modules"},{"location":"Routing/Events/Action/#class-methods","text":"","title":"Class methods"},{"location":"Routing/Events/Action/#Athena::Routing::Events::Action.new(request,action)","text":"","title":".new"},{"location":"Routing/Events/Action/#methods","text":"","title":"Methods"},{"location":"Routing/Events/Action/#Athena::Routing::Events::Action#action()","text":"The related ART::Action that will be used to handle the current request.","title":"#action"},{"location":"Routing/Events/Exception/","text":"class Athena::Routing::Events::Exception inherits Athena::EventDispatcher::Event Emitted when an exception occurs. See ART::Exceptions for more information on how exception handling works in Athena. This event can be listened on to recover from errors or to modify the exception before it's rendered. See the external documentation for more information. Included modules Athena::Routing::Events::RequestAware Athena::Routing::Events::SettableResponse Class methods .new ( request : HTTP::Request , exception : :: Exception ) Methods #exception : :: Exception The ::Exception associated with self . Can be replaced by an ART::Listeners::Error . #exception= ( exception : :: Exception ) The ::Exception associated with self . Can be replaced by an ART::Listeners::Error .","title":"Exception"},{"location":"Routing/Events/Exception/#Athena::Routing::Events::Exception","text":"Emitted when an exception occurs. See ART::Exceptions for more information on how exception handling works in Athena. This event can be listened on to recover from errors or to modify the exception before it's rendered. See the external documentation for more information.","title":"Exception"},{"location":"Routing/Events/Exception/#included-modules","text":"Athena::Routing::Events::RequestAware Athena::Routing::Events::SettableResponse","title":"Included modules"},{"location":"Routing/Events/Exception/#class-methods","text":"","title":"Class methods"},{"location":"Routing/Events/Exception/#Athena::Routing::Events::Exception.new(request,exception)","text":"","title":".new"},{"location":"Routing/Events/Exception/#methods","text":"","title":"Methods"},{"location":"Routing/Events/Exception/#Athena::Routing::Events::Exception#exception()","text":"The ::Exception associated with self . Can be replaced by an ART::Listeners::Error .","title":"#exception"},{"location":"Routing/Events/Exception/#Athena::Routing::Events::Exception#exception=(exception)","text":"The ::Exception associated with self . Can be replaced by an ART::Listeners::Error .","title":"#exception="},{"location":"Routing/Events/Request/","text":"class Athena::Routing::Events::Request inherits Athena::EventDispatcher::Event Emitted very early in the request's life-cycle; before the corresponding ART::Action (if any) has been resolved. This event can be listened on in order to: * Add information to the request, via its ART::ParameterBag * Return a response immediately if there is enough information available; ART::Listeners::CORS is an example of this NOTE: If your listener logic requires that the the corresponding ART::Action has been resolved, use ART::Events::Action instead. See the external documentation for more information. Included modules Athena::Routing::Events::RequestAware Athena::Routing::Events::SettableResponse","title":"Request"},{"location":"Routing/Events/Request/#Athena::Routing::Events::Request","text":"Emitted very early in the request's life-cycle; before the corresponding ART::Action (if any) has been resolved. This event can be listened on in order to: * Add information to the request, via its ART::ParameterBag * Return a response immediately if there is enough information available; ART::Listeners::CORS is an example of this NOTE: If your listener logic requires that the the corresponding ART::Action has been resolved, use ART::Events::Action instead. See the external documentation for more information.","title":"Request"},{"location":"Routing/Events/Request/#included-modules","text":"Athena::Routing::Events::RequestAware Athena::Routing::Events::SettableResponse","title":"Included modules"},{"location":"Routing/Events/RequestAware/","text":"module Athena::Routing::Events::RequestAware Represents an event that has access to the current request object. Direct including types Athena::Routing::Events::Action Athena::Routing::Events::Exception Athena::Routing::Events::Request Athena::Routing::Events::Response Athena::Routing::Events::Terminate Athena::Routing::Events::View Class methods .new ( request : HTTP::Request ) Methods #request : HTTP::Request Returns the current request object.","title":"RequestAware"},{"location":"Routing/Events/RequestAware/#Athena::Routing::Events::RequestAware","text":"Represents an event that has access to the current request object.","title":"RequestAware"},{"location":"Routing/Events/RequestAware/#direct-including-types","text":"Athena::Routing::Events::Action Athena::Routing::Events::Exception Athena::Routing::Events::Request Athena::Routing::Events::Response Athena::Routing::Events::Terminate Athena::Routing::Events::View","title":"Direct including types"},{"location":"Routing/Events/RequestAware/#class-methods","text":"","title":"Class methods"},{"location":"Routing/Events/RequestAware/#Athena::Routing::Events::RequestAware.new(request)","text":"","title":".new"},{"location":"Routing/Events/RequestAware/#methods","text":"","title":"Methods"},{"location":"Routing/Events/RequestAware/#Athena::Routing::Events::RequestAware#request()","text":"Returns the current request object.","title":"#request"},{"location":"Routing/Events/Response/","text":"class Athena::Routing::Events::Response inherits Athena::EventDispatcher::Event Emitted after the route's action has been executed, but before the response has been returned to the client. This event can be listened on to modify the response object further before it is returned; such as adding headers/cookies, compressing the response, etc. See the external documentation for more information. Included modules Athena::Routing::Events::RequestAware Class methods .new ( request : HTTP::Request , response : ART::Response ) Methods #response : ART::Response The response object. #response= ( response : ART::Response ) The response object.","title":"Response"},{"location":"Routing/Events/Response/#Athena::Routing::Events::Response","text":"Emitted after the route's action has been executed, but before the response has been returned to the client. This event can be listened on to modify the response object further before it is returned; such as adding headers/cookies, compressing the response, etc. See the external documentation for more information.","title":"Response"},{"location":"Routing/Events/Response/#included-modules","text":"Athena::Routing::Events::RequestAware","title":"Included modules"},{"location":"Routing/Events/Response/#class-methods","text":"","title":"Class methods"},{"location":"Routing/Events/Response/#Athena::Routing::Events::Response.new(request,response)","text":"","title":".new"},{"location":"Routing/Events/Response/#methods","text":"","title":"Methods"},{"location":"Routing/Events/Response/#Athena::Routing::Events::Response#response()","text":"The response object.","title":"#response"},{"location":"Routing/Events/Response/#Athena::Routing::Events::Response#response=(response)","text":"The response object.","title":"#response="},{"location":"Routing/Events/SettableResponse/","text":"module Athena::Routing::Events::SettableResponse Represents an event where an ART::Response can be set on self to handle the original HTTP::Request . NOTE: Once #response= is called, propagation stops. Or in other words, listeners with lower priority will not be executed. Direct including types Athena::Routing::Events::Exception Athena::Routing::Events::Request Athena::Routing::Events::View Methods #response : ART::Response? The response object, if any. #response= ( response : ART::Response ) : Nil Sets the response that will be returned for the current HTTP::Request being handled. Propagation of self will stop once #response= is called.","title":"SettableResponse"},{"location":"Routing/Events/SettableResponse/#Athena::Routing::Events::SettableResponse","text":"Represents an event where an ART::Response can be set on self to handle the original HTTP::Request . NOTE: Once #response= is called, propagation stops. Or in other words, listeners with lower priority will not be executed.","title":"SettableResponse"},{"location":"Routing/Events/SettableResponse/#direct-including-types","text":"Athena::Routing::Events::Exception Athena::Routing::Events::Request Athena::Routing::Events::View","title":"Direct including types"},{"location":"Routing/Events/SettableResponse/#methods","text":"","title":"Methods"},{"location":"Routing/Events/SettableResponse/#Athena::Routing::Events::SettableResponse#response()","text":"The response object, if any.","title":"#response"},{"location":"Routing/Events/SettableResponse/#Athena::Routing::Events::SettableResponse#response=(response)","text":"Sets the response that will be returned for the current HTTP::Request being handled. Propagation of self will stop once #response= is called.","title":"#response="},{"location":"Routing/Events/Terminate/","text":"class Athena::Routing::Events::Terminate inherits Athena::EventDispatcher::Event Emitted very late in the request's life-cycle, after the response has been sent. This event can be listened on to perform tasks that are not required to finish before the response is sent; such as sending emails, or other \"heavy\" tasks. See the external documentation for more information. Included modules Athena::Routing::Events::RequestAware Class methods .new ( request : HTTP::Request , response : ART::Response ) Methods #response : ART::Response The response object.","title":"Terminate"},{"location":"Routing/Events/Terminate/#Athena::Routing::Events::Terminate","text":"Emitted very late in the request's life-cycle, after the response has been sent. This event can be listened on to perform tasks that are not required to finish before the response is sent; such as sending emails, or other \"heavy\" tasks. See the external documentation for more information.","title":"Terminate"},{"location":"Routing/Events/Terminate/#included-modules","text":"Athena::Routing::Events::RequestAware","title":"Included modules"},{"location":"Routing/Events/Terminate/#class-methods","text":"","title":"Class methods"},{"location":"Routing/Events/Terminate/#Athena::Routing::Events::Terminate.new(request,response)","text":"","title":".new"},{"location":"Routing/Events/Terminate/#methods","text":"","title":"Methods"},{"location":"Routing/Events/Terminate/#Athena::Routing::Events::Terminate#response()","text":"The response object.","title":"#response"},{"location":"Routing/Events/View/","text":"class Athena::Routing::Events::View inherits Athena::EventDispatcher::Event Emitted after the route's action has been executed, but only if it does NOT return an ART::Response . This event can be listened on to handle converting a non ART::Response into an ART::Response . See ART::Listeners::View and the external documentation for more information. Included modules Athena::Routing::Events::RequestAware Athena::Routing::Events::SettableResponse Class methods .new ( request : HTTP::Request , action_result : _ ) Methods #action_result Returns the value returned from the related controller action. #action_result= ( value : _ ) : Nil Overrides the return value of the related controller action. Can be used to mutate the controller action's returned value within a listener context; such as for pagination.","title":"View"},{"location":"Routing/Events/View/#Athena::Routing::Events::View","text":"Emitted after the route's action has been executed, but only if it does NOT return an ART::Response . This event can be listened on to handle converting a non ART::Response into an ART::Response . See ART::Listeners::View and the external documentation for more information.","title":"View"},{"location":"Routing/Events/View/#included-modules","text":"Athena::Routing::Events::RequestAware Athena::Routing::Events::SettableResponse","title":"Included modules"},{"location":"Routing/Events/View/#class-methods","text":"","title":"Class methods"},{"location":"Routing/Events/View/#Athena::Routing::Events::View.new(request,action_result)","text":"","title":".new"},{"location":"Routing/Events/View/#methods","text":"","title":"Methods"},{"location":"Routing/Events/View/#Athena::Routing::Events::View#action_result()","text":"Returns the value returned from the related controller action.","title":"#action_result"},{"location":"Routing/Events/View/#Athena::Routing::Events::View#action_result=(value)","text":"Overrides the return value of the related controller action. Can be used to mutate the controller action's returned value within a listener context; such as for pagination.","title":"#action_result="},{"location":"Routing/Exceptions/","text":"module Athena::Routing::Exceptions Exception handling in Athena is similar to exception handling in any Crystal program, with the addition of a new unique exception type, ART::Exceptions::HTTPException . When an exception is raised, Athena emits the ART::Events::Exception event to allow an opportunity for it to be handled. If the exception goes unhandled, i.e. no listener set an ART::Response on the event, then the request is finished and the exception is reraised. Otherwise, that response is returned, setting the status and merging the headers on the exceptions if it is an ART::Exceptions::HTTPException . See ART::Listeners::Error and ART::ErrorRendererInterface for more information on how exceptions are handled by default. To provide the best response to the client, non ART::Exceptions::HTTPException should be rescued and converted into a corresponding ART::Exceptions::HTTPException . Custom HTTP errors can also be defined by inheriting from ART::Exceptions::HTTPException or a child type. A use case for this could be allowing for additional data/context to be included within the exception that ultimately could be used in a ART::Events::Exception listener.","title":"Exceptions"},{"location":"Routing/Exceptions/#Athena::Routing::Exceptions","text":"Exception handling in Athena is similar to exception handling in any Crystal program, with the addition of a new unique exception type, ART::Exceptions::HTTPException . When an exception is raised, Athena emits the ART::Events::Exception event to allow an opportunity for it to be handled. If the exception goes unhandled, i.e. no listener set an ART::Response on the event, then the request is finished and the exception is reraised. Otherwise, that response is returned, setting the status and merging the headers on the exceptions if it is an ART::Exceptions::HTTPException . See ART::Listeners::Error and ART::ErrorRendererInterface for more information on how exceptions are handled by default. To provide the best response to the client, non ART::Exceptions::HTTPException should be rescued and converted into a corresponding ART::Exceptions::HTTPException . Custom HTTP errors can also be defined by inheriting from ART::Exceptions::HTTPException or a child type. A use case for this could be allowing for additional data/context to be included within the exception that ultimately could be used in a ART::Events::Exception listener.","title":"Exceptions"},{"location":"Routing/Exceptions/BadGateway/","text":"class Athena::Routing::Exceptions::BadGateway inherits Athena::Routing::Exceptions::HTTPException Class methods .new ( message : String , cause : Exception ? = nil , headers : HTTP :: Headers = HTTP :: Headers . new )","title":"BadGateway"},{"location":"Routing/Exceptions/BadGateway/#Athena::Routing::Exceptions::BadGateway","text":"","title":"BadGateway"},{"location":"Routing/Exceptions/BadGateway/#class-methods","text":"","title":"Class methods"},{"location":"Routing/Exceptions/BadGateway/#Athena::Routing::Exceptions::BadGateway.new(message,cause,headers)","text":"","title":".new"},{"location":"Routing/Exceptions/BadRequest/","text":"class Athena::Routing::Exceptions::BadRequest inherits Athena::Routing::Exceptions::HTTPException Class methods .new ( message : String , cause : Exception ? = nil , headers : HTTP :: Headers = HTTP :: Headers . new )","title":"BadRequest"},{"location":"Routing/Exceptions/BadRequest/#Athena::Routing::Exceptions::BadRequest","text":"","title":"BadRequest"},{"location":"Routing/Exceptions/BadRequest/#class-methods","text":"","title":"Class methods"},{"location":"Routing/Exceptions/BadRequest/#Athena::Routing::Exceptions::BadRequest.new(message,cause,headers)","text":"","title":".new"},{"location":"Routing/Exceptions/Conflict/","text":"class Athena::Routing::Exceptions::Conflict inherits Athena::Routing::Exceptions::HTTPException Class methods .new ( message : String , cause : Exception ? = nil , headers : HTTP :: Headers = HTTP :: Headers . new )","title":"Conflict"},{"location":"Routing/Exceptions/Conflict/#Athena::Routing::Exceptions::Conflict","text":"","title":"Conflict"},{"location":"Routing/Exceptions/Conflict/#class-methods","text":"","title":"Class methods"},{"location":"Routing/Exceptions/Conflict/#Athena::Routing::Exceptions::Conflict.new(message,cause,headers)","text":"","title":".new"},{"location":"Routing/Exceptions/Forbidden/","text":"class Athena::Routing::Exceptions::Forbidden inherits Athena::Routing::Exceptions::HTTPException Class methods .new ( message : String , cause : Exception ? = nil , headers : HTTP :: Headers = HTTP :: Headers . new )","title":"Forbidden"},{"location":"Routing/Exceptions/Forbidden/#Athena::Routing::Exceptions::Forbidden","text":"","title":"Forbidden"},{"location":"Routing/Exceptions/Forbidden/#class-methods","text":"","title":"Class methods"},{"location":"Routing/Exceptions/Forbidden/#Athena::Routing::Exceptions::Forbidden.new(message,cause,headers)","text":"","title":".new"},{"location":"Routing/Exceptions/Gone/","text":"class Athena::Routing::Exceptions::Gone inherits Athena::Routing::Exceptions::HTTPException Class methods .new ( message : String , cause : Exception ? = nil , headers : HTTP :: Headers = HTTP :: Headers . new )","title":"Gone"},{"location":"Routing/Exceptions/Gone/#Athena::Routing::Exceptions::Gone","text":"","title":"Gone"},{"location":"Routing/Exceptions/Gone/#class-methods","text":"","title":"Class methods"},{"location":"Routing/Exceptions/Gone/#Athena::Routing::Exceptions::Gone.new(message,cause,headers)","text":"","title":".new"},{"location":"Routing/Exceptions/HTTPException/","text":"class Athena::Routing::Exceptions::HTTPException inherits Exception Represents an HTTP error. Each child represents a specific HTTP error with the associated status code. Also optionally allows adding headers to the resulting response. Can be used directly/inherited from to represent non-typical HTTP errors/codes. Direct known subclasses Athena::Routing::Exceptions::BadGateway Athena::Routing::Exceptions::BadRequest Athena::Routing::Exceptions::Conflict Athena::Routing::Exceptions::Forbidden Athena::Routing::Exceptions::Gone Athena::Routing::Exceptions::LengthRequired Athena::Routing::Exceptions::MethodNotAllowed Athena::Routing::Exceptions::NotAcceptable Athena::Routing::Exceptions::NotFound Athena::Routing::Exceptions::NotImplemented Athena::Routing::Exceptions::PreconditionFailed Athena::Routing::Exceptions::ServiceUnavailable Athena::Routing::Exceptions::TooManyRequests Athena::Routing::Exceptions::Unauthorized Athena::Routing::Exceptions::UnprocessableEntity Athena::Routing::Exceptions::UnsupportedMediaType Class methods .new ( status : HTTP :: Status , message : String , cause : Exception ? = nil , headers : HTTP :: Headers = HTTP :: Headers . new ) Instantiates self with the given status and message . Optionally includes cause , and headers . .new ( status_code : Int32 , message : String , cause : Exception ? = nil , headers : HTTP :: Headers = HTTP :: Headers . new ) Instantiates self with the given status_code and message . Optionally includes cause , and headers . Methods #headers : HTTP :: Headers Any HTTP response headers associated with self . Some HTTP errors use response headers to give additional information about self . #headers= ( headers : HTTP :: Headers ) Any HTTP response headers associated with self . Some HTTP errors use response headers to give additional information about self . #status : HTTP :: Status The HTTP::Status associated with self . #status_code : Int32 Returns the HTTP status code of #status . #to_json ( builder : JSON :: Builder ) : Nil Serializes self to JSON in the format of {\"code\":400,\"message\":\"Exception message\"}","title":"HTTPException"},{"location":"Routing/Exceptions/HTTPException/#Athena::Routing::Exceptions::HTTPException","text":"Represents an HTTP error. Each child represents a specific HTTP error with the associated status code. Also optionally allows adding headers to the resulting response. Can be used directly/inherited from to represent non-typical HTTP errors/codes.","title":"HTTPException"},{"location":"Routing/Exceptions/HTTPException/#direct-known-subclasses","text":"Athena::Routing::Exceptions::BadGateway Athena::Routing::Exceptions::BadRequest Athena::Routing::Exceptions::Conflict Athena::Routing::Exceptions::Forbidden Athena::Routing::Exceptions::Gone Athena::Routing::Exceptions::LengthRequired Athena::Routing::Exceptions::MethodNotAllowed Athena::Routing::Exceptions::NotAcceptable Athena::Routing::Exceptions::NotFound Athena::Routing::Exceptions::NotImplemented Athena::Routing::Exceptions::PreconditionFailed Athena::Routing::Exceptions::ServiceUnavailable Athena::Routing::Exceptions::TooManyRequests Athena::Routing::Exceptions::Unauthorized Athena::Routing::Exceptions::UnprocessableEntity Athena::Routing::Exceptions::UnsupportedMediaType","title":"Direct known subclasses"},{"location":"Routing/Exceptions/HTTPException/#class-methods","text":"","title":"Class methods"},{"location":"Routing/Exceptions/HTTPException/#Athena::Routing::Exceptions::HTTPException.new(status,message,cause,headers)","text":"Instantiates self with the given status and message . Optionally includes cause , and headers .","title":".new"},{"location":"Routing/Exceptions/HTTPException/#methods","text":"","title":"Methods"},{"location":"Routing/Exceptions/HTTPException/#Athena::Routing::Exceptions::HTTPException#headers()","text":"Any HTTP response headers associated with self . Some HTTP errors use response headers to give additional information about self .","title":"#headers"},{"location":"Routing/Exceptions/HTTPException/#Athena::Routing::Exceptions::HTTPException#headers=(headers)","text":"Any HTTP response headers associated with self . Some HTTP errors use response headers to give additional information about self .","title":"#headers="},{"location":"Routing/Exceptions/HTTPException/#Athena::Routing::Exceptions::HTTPException#status()","text":"The HTTP::Status associated with self .","title":"#status"},{"location":"Routing/Exceptions/HTTPException/#Athena::Routing::Exceptions::HTTPException#status_code()","text":"Returns the HTTP status code of #status .","title":"#status_code"},{"location":"Routing/Exceptions/HTTPException/#Athena::Routing::Exceptions::HTTPException#to_json(builder)","text":"Serializes self to JSON in the format of {\"code\":400,\"message\":\"Exception message\"}","title":"#to_json"},{"location":"Routing/Exceptions/InvalidParameter/","text":"class Athena::Routing::Exceptions::InvalidParameter inherits Athena::Routing::Exceptions::UnprocessableEntity Class methods .new ( parameter : ART::Params::ParamInterface , violations : AVD::Violation::ConstraintViolationListInterface , message : String , cause : Exception ? = nil , headers : HTTP :: Headers = HTTP :: Headers . new ) .with_violations ( parameter : ART::Params::ParamInterface , violations : AVD::Violation::ConstraintViolationListInterface ) : self Methods #parameter : ART::Params::ParamInterface #violations : AVD::Violation::ConstraintViolationListInterface","title":"InvalidParameter"},{"location":"Routing/Exceptions/InvalidParameter/#Athena::Routing::Exceptions::InvalidParameter","text":"","title":"InvalidParameter"},{"location":"Routing/Exceptions/InvalidParameter/#class-methods","text":"","title":"Class methods"},{"location":"Routing/Exceptions/InvalidParameter/#Athena::Routing::Exceptions::InvalidParameter.new(parameter,violations,message,cause,headers)","text":"","title":".new"},{"location":"Routing/Exceptions/InvalidParameter/#Athena::Routing::Exceptions::InvalidParameter.with_violations(parameter,violations)","text":"","title":".with_violations"},{"location":"Routing/Exceptions/InvalidParameter/#methods","text":"","title":"Methods"},{"location":"Routing/Exceptions/InvalidParameter/#Athena::Routing::Exceptions::InvalidParameter#parameter()","text":"","title":"#parameter"},{"location":"Routing/Exceptions/InvalidParameter/#Athena::Routing::Exceptions::InvalidParameter#violations()","text":"","title":"#violations"},{"location":"Routing/Exceptions/LengthRequired/","text":"class Athena::Routing::Exceptions::LengthRequired inherits Athena::Routing::Exceptions::HTTPException Class methods .new ( message : String , cause : Exception ? = nil , headers : HTTP :: Headers = HTTP :: Headers . new )","title":"LengthRequired"},{"location":"Routing/Exceptions/LengthRequired/#Athena::Routing::Exceptions::LengthRequired","text":"","title":"LengthRequired"},{"location":"Routing/Exceptions/LengthRequired/#class-methods","text":"","title":"Class methods"},{"location":"Routing/Exceptions/LengthRequired/#Athena::Routing::Exceptions::LengthRequired.new(message,cause,headers)","text":"","title":".new"},{"location":"Routing/Exceptions/MethodNotAllowed/","text":"class Athena::Routing::Exceptions::MethodNotAllowed inherits Athena::Routing::Exceptions::HTTPException Class methods .new ( message : String , cause : Exception ? = nil , headers : HTTP :: Headers = HTTP :: Headers . new )","title":"MethodNotAllowed"},{"location":"Routing/Exceptions/MethodNotAllowed/#Athena::Routing::Exceptions::MethodNotAllowed","text":"","title":"MethodNotAllowed"},{"location":"Routing/Exceptions/MethodNotAllowed/#class-methods","text":"","title":"Class methods"},{"location":"Routing/Exceptions/MethodNotAllowed/#Athena::Routing::Exceptions::MethodNotAllowed.new(message,cause,headers)","text":"","title":".new"},{"location":"Routing/Exceptions/NotAcceptable/","text":"class Athena::Routing::Exceptions::NotAcceptable inherits Athena::Routing::Exceptions::HTTPException Class methods .new ( message : String , cause : Exception ? = nil , headers : HTTP :: Headers = HTTP :: Headers . new )","title":"NotAcceptable"},{"location":"Routing/Exceptions/NotAcceptable/#Athena::Routing::Exceptions::NotAcceptable","text":"","title":"NotAcceptable"},{"location":"Routing/Exceptions/NotAcceptable/#class-methods","text":"","title":"Class methods"},{"location":"Routing/Exceptions/NotAcceptable/#Athena::Routing::Exceptions::NotAcceptable.new(message,cause,headers)","text":"","title":".new"},{"location":"Routing/Exceptions/NotFound/","text":"class Athena::Routing::Exceptions::NotFound inherits Athena::Routing::Exceptions::HTTPException Class methods .new ( message : String , cause : Exception ? = nil , headers : HTTP :: Headers = HTTP :: Headers . new )","title":"NotFound"},{"location":"Routing/Exceptions/NotFound/#Athena::Routing::Exceptions::NotFound","text":"","title":"NotFound"},{"location":"Routing/Exceptions/NotFound/#class-methods","text":"","title":"Class methods"},{"location":"Routing/Exceptions/NotFound/#Athena::Routing::Exceptions::NotFound.new(message,cause,headers)","text":"","title":".new"},{"location":"Routing/Exceptions/NotImplemented/","text":"class Athena::Routing::Exceptions::NotImplemented inherits Athena::Routing::Exceptions::HTTPException Class methods .new ( message : String , cause : Exception ? = nil , headers : HTTP :: Headers = HTTP :: Headers . new )","title":"NotImplemented"},{"location":"Routing/Exceptions/NotImplemented/#Athena::Routing::Exceptions::NotImplemented","text":"","title":"NotImplemented"},{"location":"Routing/Exceptions/NotImplemented/#class-methods","text":"","title":"Class methods"},{"location":"Routing/Exceptions/NotImplemented/#Athena::Routing::Exceptions::NotImplemented.new(message,cause,headers)","text":"","title":".new"},{"location":"Routing/Exceptions/PreconditionFailed/","text":"class Athena::Routing::Exceptions::PreconditionFailed inherits Athena::Routing::Exceptions::HTTPException Class methods .new ( message : String , cause : Exception ? = nil , headers : HTTP :: Headers = HTTP :: Headers . new )","title":"PreconditionFailed"},{"location":"Routing/Exceptions/PreconditionFailed/#Athena::Routing::Exceptions::PreconditionFailed","text":"","title":"PreconditionFailed"},{"location":"Routing/Exceptions/PreconditionFailed/#class-methods","text":"","title":"Class methods"},{"location":"Routing/Exceptions/PreconditionFailed/#Athena::Routing::Exceptions::PreconditionFailed.new(message,cause,headers)","text":"","title":".new"},{"location":"Routing/Exceptions/ServiceUnavailable/","text":"class Athena::Routing::Exceptions::ServiceUnavailable inherits Athena::Routing::Exceptions::HTTPException Class methods .new ( message : String , retry_after : Number | String | Nil = nil , cause : Exception ? = nil , headers : HTTP :: Headers = HTTP :: Headers . new ) See Athena::Routing::Exceptions::HTTPException#new . If retry_after is provided, adds a retry-after header that represents the number of seconds or HTTP-date after which the request may be retried.","title":"ServiceUnavailable"},{"location":"Routing/Exceptions/ServiceUnavailable/#Athena::Routing::Exceptions::ServiceUnavailable","text":"","title":"ServiceUnavailable"},{"location":"Routing/Exceptions/ServiceUnavailable/#class-methods","text":"","title":"Class methods"},{"location":"Routing/Exceptions/ServiceUnavailable/#Athena::Routing::Exceptions::ServiceUnavailable.new(message,retry_after,cause,headers)","text":"See Athena::Routing::Exceptions::HTTPException#new . If retry_after is provided, adds a retry-after header that represents the number of seconds or HTTP-date after which the request may be retried.","title":".new"},{"location":"Routing/Exceptions/TooManyRequests/","text":"class Athena::Routing::Exceptions::TooManyRequests inherits Athena::Routing::Exceptions::HTTPException Class methods .new ( message : String , retry_after : Number | String | Nil = nil , cause : Exception ? = nil , headers : HTTP :: Headers = HTTP :: Headers . new ) See Athena::Routing::Exceptions::HTTPException#new . If retry_after is provided, adds a retry-after header that represents the number of seconds or HTTP-date after which the request may be retried.","title":"TooManyRequests"},{"location":"Routing/Exceptions/TooManyRequests/#Athena::Routing::Exceptions::TooManyRequests","text":"","title":"TooManyRequests"},{"location":"Routing/Exceptions/TooManyRequests/#class-methods","text":"","title":"Class methods"},{"location":"Routing/Exceptions/TooManyRequests/#Athena::Routing::Exceptions::TooManyRequests.new(message,retry_after,cause,headers)","text":"See Athena::Routing::Exceptions::HTTPException#new . If retry_after is provided, adds a retry-after header that represents the number of seconds or HTTP-date after which the request may be retried.","title":".new"},{"location":"Routing/Exceptions/Unauthorized/","text":"class Athena::Routing::Exceptions::Unauthorized inherits Athena::Routing::Exceptions::HTTPException Class methods .new ( message : String , challenge : String , cause : Exception ? = nil , headers : HTTP :: Headers = HTTP :: Headers . new ) See Athena::Routing::Exceptions::HTTPException#new . Includes a www-authenticate header with the provided challenge .","title":"Unauthorized"},{"location":"Routing/Exceptions/Unauthorized/#Athena::Routing::Exceptions::Unauthorized","text":"","title":"Unauthorized"},{"location":"Routing/Exceptions/Unauthorized/#class-methods","text":"","title":"Class methods"},{"location":"Routing/Exceptions/Unauthorized/#Athena::Routing::Exceptions::Unauthorized.new(message,challenge,cause,headers)","text":"See Athena::Routing::Exceptions::HTTPException#new . Includes a www-authenticate header with the provided challenge .","title":".new"},{"location":"Routing/Exceptions/UnprocessableEntity/","text":"class Athena::Routing::Exceptions::UnprocessableEntity inherits Athena::Routing::Exceptions::HTTPException Direct known subclasses Athena::Routing::Exceptions::InvalidParameter Athena::Validator::Exceptions::ValidationFailed Class methods .new ( message : String , cause : Exception ? = nil , headers : HTTP :: Headers = HTTP :: Headers . new )","title":"UnprocessableEntity"},{"location":"Routing/Exceptions/UnprocessableEntity/#Athena::Routing::Exceptions::UnprocessableEntity","text":"","title":"UnprocessableEntity"},{"location":"Routing/Exceptions/UnprocessableEntity/#direct-known-subclasses","text":"Athena::Routing::Exceptions::InvalidParameter Athena::Validator::Exceptions::ValidationFailed","title":"Direct known subclasses"},{"location":"Routing/Exceptions/UnprocessableEntity/#class-methods","text":"","title":"Class methods"},{"location":"Routing/Exceptions/UnprocessableEntity/#Athena::Routing::Exceptions::UnprocessableEntity.new(message,cause,headers)","text":"","title":".new"},{"location":"Routing/Exceptions/UnsupportedMediaType/","text":"class Athena::Routing::Exceptions::UnsupportedMediaType inherits Athena::Routing::Exceptions::HTTPException Class methods .new ( message : String , cause : Exception ? = nil , headers : HTTP :: Headers = HTTP :: Headers . new )","title":"UnsupportedMediaType"},{"location":"Routing/Exceptions/UnsupportedMediaType/#Athena::Routing::Exceptions::UnsupportedMediaType","text":"","title":"UnsupportedMediaType"},{"location":"Routing/Exceptions/UnsupportedMediaType/#class-methods","text":"","title":"Class methods"},{"location":"Routing/Exceptions/UnsupportedMediaType/#Athena::Routing::Exceptions::UnsupportedMediaType.new(message,cause,headers)","text":"","title":".new"},{"location":"Routing/Get/","text":"annotation Athena::Routing::Get Defines a GET endpoint. Fields path : String - The path for the endpoint, may also be provided as the first positional argument. name : String - The name of the route. Defaults to controller name + method name down snake-cased. constraints : Hash(String, Regex) - A mapping between a route's path parameters and its constraints. Example @[ ART :: Get ( path : \"/users/:id\" ) ] def get_user ( id : Int32 ) : Nil end","title":"Get"},{"location":"Routing/Get/#Athena::Routing::Get","text":"Defines a GET endpoint.","title":"Get"},{"location":"Routing/Get/#Athena::Routing::Get--fields","text":"path : String - The path for the endpoint, may also be provided as the first positional argument. name : String - The name of the route. Defaults to controller name + method name down snake-cased. constraints : Hash(String, Regex) - A mapping between a route's path parameters and its constraints.","title":"Fields"},{"location":"Routing/Get/#Athena::Routing::Get--example","text":"@[ ART :: Get ( path : \"/users/:id\" ) ] def get_user ( id : Int32 ) : Nil end","title":"Example"},{"location":"Routing/Head/","text":"annotation Athena::Routing::Head Defines a HEAD endpoint. Fields path : String - The path for the endpoint, may also be provided as the first positional argument. name : String - The name of the route. Defaults to controller name + method name down snake-cased. constraints : Hash(String, Regex) - A mapping between a route's path parameters and its constraints. Example @[ ART :: Head ( path : \"/users\" ) ] def head_user : Nil end","title":"Head"},{"location":"Routing/Head/#Athena::Routing::Head","text":"Defines a HEAD endpoint.","title":"Head"},{"location":"Routing/Head/#Athena::Routing::Head--fields","text":"path : String - The path for the endpoint, may also be provided as the first positional argument. name : String - The name of the route. Defaults to controller name + method name down snake-cased. constraints : Hash(String, Regex) - A mapping between a route's path parameters and its constraints.","title":"Fields"},{"location":"Routing/Head/#Athena::Routing::Head--example","text":"@[ ART :: Head ( path : \"/users\" ) ] def head_user : Nil end","title":"Example"},{"location":"Routing/Link/","text":"annotation Athena::Routing::Link Defines a LINK endpoint. Fields path : String - The path for the endpoint, may also be provided as the first positional argument. name : String - The name of the route. Defaults to controller name + method name down snake-cased. constraints : Hash(String, Regex) - A mapping between a route's path parameters and its constraints. Example @[ ART :: Link ( path : \"/users/:id\" ) ] def link_user ( id : Int32 ) : Nil end","title":"Link"},{"location":"Routing/Link/#Athena::Routing::Link","text":"Defines a LINK endpoint.","title":"Link"},{"location":"Routing/Link/#Athena::Routing::Link--fields","text":"path : String - The path for the endpoint, may also be provided as the first positional argument. name : String - The name of the route. Defaults to controller name + method name down snake-cased. constraints : Hash(String, Regex) - A mapping between a route's path parameters and its constraints.","title":"Fields"},{"location":"Routing/Link/#Athena::Routing::Link--example","text":"@[ ART :: Link ( path : \"/users/:id\" ) ] def link_user ( id : Int32 ) : Nil end","title":"Example"},{"location":"Routing/Listeners/","text":"module Athena::Routing::Listeners The AED::EventListenerInterface that act upon ART::Events to handle a request. Custom listeners can also be defined, see AED::EventListenerInterface . See each listener and the external documentation for more information. Constants TAG = \"athena.event_dispatcher.listener\" The tag name for Athena event listeners.","title":"Listeners"},{"location":"Routing/Listeners/#Athena::Routing::Listeners","text":"The AED::EventListenerInterface that act upon ART::Events to handle a request. Custom listeners can also be defined, see AED::EventListenerInterface . See each listener and the external documentation for more information.","title":"Listeners"},{"location":"Routing/Listeners/#constants","text":"","title":"Constants"},{"location":"Routing/Listeners/#Athena::Routing::Listeners::TAG","text":"The tag name for Athena event listeners.","title":"TAG"},{"location":"Routing/Listeners/CORS/","text":"struct Athena::Routing::Listeners::CORS inherits Struct Handles Cross-Origin Resource Sharing (CORS). Handles CORS preflight OPTIONS requests as well as adding CORS headers to each response. See ART::Config::CORS for information on configuring the listener. Included modules Athena::EventDispatcher::EventListenerInterface Constants SAFELISTED_HEADERS = [ \"accept\" , \"accept-language\" , \"content-language\" , \"content-type\" , \"origin\" ] The CORS-safelisted request-headers . SAFELISTED_METHODS = [ \"GET\" , \"POST\" , \"HEAD\" ] The CORS-safelisted methods . Class methods .subscribed_events : AED::SubscribedEvents .new ( configuration_resolver : ACF::ConfigurationResolverInterface ) Methods #call ( event : ART::Events::Request , dispatcher : AED::EventDispatcherInterface ) : Nil #call ( event : ART::Events::Response , dispatcher : AED::EventDispatcherInterface ) : Nil","title":"CORS"},{"location":"Routing/Listeners/CORS/#Athena::Routing::Listeners::CORS","text":"Handles Cross-Origin Resource Sharing (CORS). Handles CORS preflight OPTIONS requests as well as adding CORS headers to each response. See ART::Config::CORS for information on configuring the listener.","title":"CORS"},{"location":"Routing/Listeners/CORS/#included-modules","text":"Athena::EventDispatcher::EventListenerInterface","title":"Included modules"},{"location":"Routing/Listeners/CORS/#constants","text":"","title":"Constants"},{"location":"Routing/Listeners/CORS/#Athena::Routing::Listeners::CORS::SAFELISTED_HEADERS","text":"The CORS-safelisted request-headers .","title":"SAFELISTED_HEADERS"},{"location":"Routing/Listeners/CORS/#Athena::Routing::Listeners::CORS::SAFELISTED_METHODS","text":"The CORS-safelisted methods .","title":"SAFELISTED_METHODS"},{"location":"Routing/Listeners/CORS/#class-methods","text":"","title":"Class methods"},{"location":"Routing/Listeners/CORS/#Athena::Routing::Listeners::CORS.subscribed_events()","text":"","title":".subscribed_events"},{"location":"Routing/Listeners/CORS/#Athena::Routing::Listeners::CORS.new(configuration_resolver)","text":"","title":".new"},{"location":"Routing/Listeners/CORS/#methods","text":"","title":"Methods"},{"location":"Routing/Listeners/CORS/#Athena::Routing::Listeners::CORS#call(event,dispatcher)","text":"","title":"#call"},{"location":"Routing/Listeners/CORS/#Athena::Routing::Listeners::CORS#call(event,dispatcher)","text":"","title":"#call"},{"location":"Routing/Listeners/Error/","text":"struct Athena::Routing::Listeners::Error inherits Struct Handles an exception by converting it into an ART::Response via an ART::ErrorRendererInterface . This listener defines a log_exception protected method that determines how the exception gets logged. Non ART::Exceptions::HTTPException s and server errors are logged as errors. Validation errors ( ART::Exceptions::UnprocessableEntity ) are logged as notice. Everything else is logged as a warning. The method can be redefined if different logic is desired. class ART::Listeners:: Error # :inherit: protected def log_exception ( exception : Exception , & : -> String ) : Nil # Don't log anything if an exception is some specific type. return if exception . is_a? MyException # Exception types could also include modules to act as interfaces to determine their level, E.g. `include NoticeException`. if exception . is_a? NoticeException LOGGER . notice ( exception : exception ) { yield } return end # Otherwise fallback to the default implementation. previous_def end end Included modules Athena::EventDispatcher::EventListenerInterface Class methods .subscribed_events : AED::SubscribedEvents .new ( error_renderer : ART::ErrorRendererInterface ) Methods #call ( event : ART::Events::Exception , dispatcher : AED::EventDispatcherInterface ) : Nil","title":"Error"},{"location":"Routing/Listeners/Error/#Athena::Routing::Listeners::Error","text":"Handles an exception by converting it into an ART::Response via an ART::ErrorRendererInterface . This listener defines a log_exception protected method that determines how the exception gets logged. Non ART::Exceptions::HTTPException s and server errors are logged as errors. Validation errors ( ART::Exceptions::UnprocessableEntity ) are logged as notice. Everything else is logged as a warning. The method can be redefined if different logic is desired. class ART::Listeners:: Error # :inherit: protected def log_exception ( exception : Exception , & : -> String ) : Nil # Don't log anything if an exception is some specific type. return if exception . is_a? MyException # Exception types could also include modules to act as interfaces to determine their level, E.g. `include NoticeException`. if exception . is_a? NoticeException LOGGER . notice ( exception : exception ) { yield } return end # Otherwise fallback to the default implementation. previous_def end end","title":"Error"},{"location":"Routing/Listeners/Error/#included-modules","text":"Athena::EventDispatcher::EventListenerInterface","title":"Included modules"},{"location":"Routing/Listeners/Error/#class-methods","text":"","title":"Class methods"},{"location":"Routing/Listeners/Error/#Athena::Routing::Listeners::Error.subscribed_events()","text":"","title":".subscribed_events"},{"location":"Routing/Listeners/Error/#Athena::Routing::Listeners::Error.new(error_renderer)","text":"","title":".new"},{"location":"Routing/Listeners/Error/#methods","text":"","title":"Methods"},{"location":"Routing/Listeners/Error/#Athena::Routing::Listeners::Error#call(event,dispatcher)","text":"","title":"#call"},{"location":"Routing/Listeners/ParamConverter/","text":"struct Athena::Routing::Listeners::ParamConverter inherits Struct Applies any ART::ParamConverterInterface defined on a given ART::Action . Injects all ART::ParamConverterInterface tagged with ART::ParamConverterInterface::TAG . Included modules Athena::EventDispatcher::EventListenerInterface Class methods .subscribed_events : AED::SubscribedEvents .new ( param_converters : Array ( ART::ParamConverterInterface )) Methods #call ( event : ART::Events::Action , dispatcher : AED::EventDispatcherInterface ) : Nil","title":"ParamConverter"},{"location":"Routing/Listeners/ParamConverter/#Athena::Routing::Listeners::ParamConverter","text":"Applies any ART::ParamConverterInterface defined on a given ART::Action . Injects all ART::ParamConverterInterface tagged with ART::ParamConverterInterface::TAG .","title":"ParamConverter"},{"location":"Routing/Listeners/ParamConverter/#included-modules","text":"Athena::EventDispatcher::EventListenerInterface","title":"Included modules"},{"location":"Routing/Listeners/ParamConverter/#class-methods","text":"","title":"Class methods"},{"location":"Routing/Listeners/ParamConverter/#Athena::Routing::Listeners::ParamConverter.subscribed_events()","text":"","title":".subscribed_events"},{"location":"Routing/Listeners/ParamConverter/#Athena::Routing::Listeners::ParamConverter.new(param_converters)","text":"","title":".new"},{"location":"Routing/Listeners/ParamConverter/#methods","text":"","title":"Methods"},{"location":"Routing/Listeners/ParamConverter/#Athena::Routing::Listeners::ParamConverter#call(event,dispatcher)","text":"","title":"#call"},{"location":"Routing/Listeners/ParamFetcher/","text":"struct Athena::Routing::Listeners::ParamFetcher inherits Struct Included modules Athena::EventDispatcher::EventListenerInterface Class methods .subscribed_events : AED::SubscribedEvents .new ( param_fetcher : ART::Params::ParamFetcherInterface ) Methods #call ( event : ART::Events::Action , dispatcher : AED::EventDispatcherInterface ) : Nil","title":"ParamFetcher"},{"location":"Routing/Listeners/ParamFetcher/#Athena::Routing::Listeners::ParamFetcher","text":"","title":"ParamFetcher"},{"location":"Routing/Listeners/ParamFetcher/#included-modules","text":"Athena::EventDispatcher::EventListenerInterface","title":"Included modules"},{"location":"Routing/Listeners/ParamFetcher/#class-methods","text":"","title":"Class methods"},{"location":"Routing/Listeners/ParamFetcher/#Athena::Routing::Listeners::ParamFetcher.subscribed_events()","text":"","title":".subscribed_events"},{"location":"Routing/Listeners/ParamFetcher/#Athena::Routing::Listeners::ParamFetcher.new(param_fetcher)","text":"","title":".new"},{"location":"Routing/Listeners/ParamFetcher/#methods","text":"","title":"Methods"},{"location":"Routing/Listeners/ParamFetcher/#Athena::Routing::Listeners::ParamFetcher#call(event,dispatcher)","text":"","title":"#call"},{"location":"Routing/Listeners/Routing/","text":"struct Athena::Routing::Listeners::Routing inherits Struct Sets the related ART::Action on the current request via an ART::RequestMatcherInterface . Included modules Athena::EventDispatcher::EventListenerInterface Class methods .subscribed_events : AED::SubscribedEvents .new ( matcher : ART::RequestMatcherInterface ) Methods #call ( event : ART::Events::Request , dispatcher : AED::EventDispatcherInterface ) : Nil Assigns the resolved ART::Action and path parameters to the request. The resolved route is dupped to avoid mutating the master copy in the singleton.","title":"Routing"},{"location":"Routing/Listeners/Routing/#Athena::Routing::Listeners::Routing","text":"Sets the related ART::Action on the current request via an ART::RequestMatcherInterface .","title":"Routing"},{"location":"Routing/Listeners/Routing/#included-modules","text":"Athena::EventDispatcher::EventListenerInterface","title":"Included modules"},{"location":"Routing/Listeners/Routing/#class-methods","text":"","title":"Class methods"},{"location":"Routing/Listeners/Routing/#Athena::Routing::Listeners::Routing.subscribed_events()","text":"","title":".subscribed_events"},{"location":"Routing/Listeners/Routing/#Athena::Routing::Listeners::Routing.new(matcher)","text":"","title":".new"},{"location":"Routing/Listeners/Routing/#methods","text":"","title":"Methods"},{"location":"Routing/Listeners/Routing/#Athena::Routing::Listeners::Routing#call(event,dispatcher)","text":"Assigns the resolved ART::Action and path parameters to the request. The resolved route is dupped to avoid mutating the master copy in the singleton.","title":"#call"},{"location":"Routing/Listeners/View/","text":"struct Athena::Routing::Listeners::View inherits Struct The view listener attempts to resolve a non ART::Response into an ART::Response . Currently this is achieved by JSON serializing the controller action's resulting value; either via Object#to_json or ASR::Serializer , depending on what type the resulting value is. In the future this listener will handle executing the correct view handler based on the registered formats and the format that the initial HTTP::Request requires. TODO: Implement a format negotiation algorithm. Included modules Athena::EventDispatcher::EventListenerInterface Class methods .subscribed_events : AED::SubscribedEvents .new ( serializer : ASR::SerializerInterface ) Methods #call ( event : ART::Events::View , dispatcher : AED::EventDispatcherInterface ) : Nil","title":"View"},{"location":"Routing/Listeners/View/#Athena::Routing::Listeners::View","text":"The view listener attempts to resolve a non ART::Response into an ART::Response . Currently this is achieved by JSON serializing the controller action's resulting value; either via Object#to_json or ASR::Serializer , depending on what type the resulting value is. In the future this listener will handle executing the correct view handler based on the registered formats and the format that the initial HTTP::Request requires. TODO: Implement a format negotiation algorithm.","title":"View"},{"location":"Routing/Listeners/View/#included-modules","text":"Athena::EventDispatcher::EventListenerInterface","title":"Included modules"},{"location":"Routing/Listeners/View/#class-methods","text":"","title":"Class methods"},{"location":"Routing/Listeners/View/#Athena::Routing::Listeners::View.subscribed_events()","text":"","title":".subscribed_events"},{"location":"Routing/Listeners/View/#Athena::Routing::Listeners::View.new(serializer)","text":"","title":".new"},{"location":"Routing/Listeners/View/#methods","text":"","title":"Methods"},{"location":"Routing/Listeners/View/#Athena::Routing::Listeners::View#call(event,dispatcher)","text":"","title":"#call"},{"location":"Routing/ParamConverter/","text":"annotation Athena::Routing::ParamConverter Applies an ART::ParamConverterInterface to a given argument. See ART::ParamConverterInterface for more information on defining a param converter. Fields name : String - The name of the argument that should be converted, may also be provided as the first positional argument. converter : ART::ParamConverterInterface.class - The ART::ParamConverterInterface that should be used to convert this argument. Example @[ ART :: Get ( path : \"/multiply/:num\" ) ] @[ ART :: ParamConverter ( \"num\" , converter : MultiplyConverter ) ] def multiply ( num : Int32 ) : Int32 num end","title":"ParamConverter"},{"location":"Routing/ParamConverter/#Athena::Routing::ParamConverter","text":"Applies an ART::ParamConverterInterface to a given argument. See ART::ParamConverterInterface for more information on defining a param converter.","title":"ParamConverter"},{"location":"Routing/ParamConverter/#Athena::Routing::ParamConverter--fields","text":"name : String - The name of the argument that should be converted, may also be provided as the first positional argument. converter : ART::ParamConverterInterface.class - The ART::ParamConverterInterface that should be used to convert this argument.","title":"Fields"},{"location":"Routing/ParamConverter/#Athena::Routing::ParamConverter--example","text":"@[ ART :: Get ( path : \"/multiply/:num\" ) ] @[ ART :: ParamConverter ( \"num\" , converter : MultiplyConverter ) ] def multiply ( num : Int32 ) : Int32 num end","title":"Example"},{"location":"Routing/ParamConverterInterface/","text":"abstract struct Athena::Routing::ParamConverterInterface inherits Struct A param converter allows applying custom logic in order to convert a primitive request parameter into a more complex type. A few common examples could be converting a date-time string into a Time object, converting a user's id into an actual User object, or deserializing a request body into an instance of T. Examples Defining a custom param converter requires the usage of two (optionally three) things: An implementation of self to define the conversion logic. The ART::ParamConverter annotation applied to an action to specify what argument should be converted, and what converter should be used. An optional ART::ParamConverterInterface::ConfigurationInterface instance to define extra configuration options that can be used within the ART::ParamConverter annotation. Param converters are registered as services, and as such, may use any other registered services as a dependency via DI. require \"athena\" # Create a param converter struct to contain our conversion logic. @[ ADI :: Register ] struct MultiplyConverter < ART :: ParamConverterInterface # :inherit: def apply ( request : HTTP :: Request , configuration : Configuration ) : Nil arg_name = configuration . name # No need to continue if the request does not have a value for this argument. # The converter could also be setup to only set a value if it hasn't been set already. return unless request . attributes . has? arg_name # Retieve the argument from the request's attributes as an Int32. # Converters should also handle any errors that may occur, # such as type conversion, validation, or business logic errors. value = request . attributes . get arg_name , Int32 # Override the argument's value within the request attributes, restricted to `Int32` values. request . attributes . set arg_name , value * 2 , Int32 end end class ParamConverterController < ART :: Controller # Use the ART::ParamConverter annotation to specify we want to use a param converter for the `num` argument, and that we want to use the `MultiplyConverter` for the conversion. @[ ART :: Get ( path : \"/multiply/:num\" ) ] @[ ART :: ParamConverter ( \"num\" , converter : MultiplyConverter ) ] def multiply ( num : Int32 ) : Int32 num end end ART . run # GET /multiply/3 # => 6 Additional Configuration By default, the configuration argument to #apply contains the name of the argument that should be converted, and a reference to the class of self . However, it can be augmented with additional data by using the ART::ParamConverterInterface.configuration macro. For example, lets enhance the previous example to allow specifying the multiplier, versus it being hard-coded as 2 . require \"athena\" @[ ADI :: Register ] struct MultiplyConverter < ART :: ParamConverterInterface # Use the `configuration` macro to define the configuration object that `self` should use. # Adds an additional argument to allow specifying the multiplier. # # Configuration data can be made optional by setting default values. configuration by : Int32 # :inherit: def apply ( request : HTTP :: Request , configuration : Configuration ) : Nil arg_name = configuration . name return unless request . attributes . has? arg_name value = request . attributes . get arg_name , Int32 # Use the multiplier from the configuration object. request . attributes . set arg_name , value * configuration . by , Int32 end end class ParamConverterController < ART :: Controller # Specify the multiplier to use for the conversion; in this case `4`. @[ ART :: Get ( path : \"/multiply/:num\" ) ] @[ ART :: ParamConverter ( \"num\" , converter : MultiplyConverter , by : 4 ) ] def multiply ( num : Int32 ) : Int32 num end end ART . run # GET /multiply/3 # => 12 Direct known subclasses Athena::Routing::TimeConverter Constants TAG = \"athena.param_converter\" The tag name to apply to self in order for it to be registered with ART::Listeners::ParamConverter . Class methods .new Methods #apply ( request : HTTP::Request , configuration : Configuration ) : Nil Applies the conversion logic based on the provided request and configuration . Most commonly this involves setting/overriding a value stored in the request's ART::ParameterBag via request.attributes . Macros configuration ( * args ) Helper macro for defining an ART::ParamConverterInterface::ConfigurationInterface ; similar to the record macro. Accepts a variable amount of variable names, types, and optionally default values. See the Additional Configuration example for more information.","title":"ParamConverterInterface"},{"location":"Routing/ParamConverterInterface/#Athena::Routing::ParamConverterInterface","text":"A param converter allows applying custom logic in order to convert a primitive request parameter into a more complex type. A few common examples could be converting a date-time string into a Time object, converting a user's id into an actual User object, or deserializing a request body into an instance of T.","title":"ParamConverterInterface"},{"location":"Routing/ParamConverterInterface/#Athena::Routing::ParamConverterInterface--examples","text":"Defining a custom param converter requires the usage of two (optionally three) things: An implementation of self to define the conversion logic. The ART::ParamConverter annotation applied to an action to specify what argument should be converted, and what converter should be used. An optional ART::ParamConverterInterface::ConfigurationInterface instance to define extra configuration options that can be used within the ART::ParamConverter annotation. Param converters are registered as services, and as such, may use any other registered services as a dependency via DI. require \"athena\" # Create a param converter struct to contain our conversion logic. @[ ADI :: Register ] struct MultiplyConverter < ART :: ParamConverterInterface # :inherit: def apply ( request : HTTP :: Request , configuration : Configuration ) : Nil arg_name = configuration . name # No need to continue if the request does not have a value for this argument. # The converter could also be setup to only set a value if it hasn't been set already. return unless request . attributes . has? arg_name # Retieve the argument from the request's attributes as an Int32. # Converters should also handle any errors that may occur, # such as type conversion, validation, or business logic errors. value = request . attributes . get arg_name , Int32 # Override the argument's value within the request attributes, restricted to `Int32` values. request . attributes . set arg_name , value * 2 , Int32 end end class ParamConverterController < ART :: Controller # Use the ART::ParamConverter annotation to specify we want to use a param converter for the `num` argument, and that we want to use the `MultiplyConverter` for the conversion. @[ ART :: Get ( path : \"/multiply/:num\" ) ] @[ ART :: ParamConverter ( \"num\" , converter : MultiplyConverter ) ] def multiply ( num : Int32 ) : Int32 num end end ART . run # GET /multiply/3 # => 6","title":"Examples"},{"location":"Routing/ParamConverterInterface/#Athena::Routing::ParamConverterInterface--additional-configuration","text":"By default, the configuration argument to #apply contains the name of the argument that should be converted, and a reference to the class of self . However, it can be augmented with additional data by using the ART::ParamConverterInterface.configuration macro. For example, lets enhance the previous example to allow specifying the multiplier, versus it being hard-coded as 2 . require \"athena\" @[ ADI :: Register ] struct MultiplyConverter < ART :: ParamConverterInterface # Use the `configuration` macro to define the configuration object that `self` should use. # Adds an additional argument to allow specifying the multiplier. # # Configuration data can be made optional by setting default values. configuration by : Int32 # :inherit: def apply ( request : HTTP :: Request , configuration : Configuration ) : Nil arg_name = configuration . name return unless request . attributes . has? arg_name value = request . attributes . get arg_name , Int32 # Use the multiplier from the configuration object. request . attributes . set arg_name , value * configuration . by , Int32 end end class ParamConverterController < ART :: Controller # Specify the multiplier to use for the conversion; in this case `4`. @[ ART :: Get ( path : \"/multiply/:num\" ) ] @[ ART :: ParamConverter ( \"num\" , converter : MultiplyConverter , by : 4 ) ] def multiply ( num : Int32 ) : Int32 num end end ART . run # GET /multiply/3 # => 12","title":"Additional Configuration"},{"location":"Routing/ParamConverterInterface/#direct-known-subclasses","text":"Athena::Routing::TimeConverter","title":"Direct known subclasses"},{"location":"Routing/ParamConverterInterface/#constants","text":"","title":"Constants"},{"location":"Routing/ParamConverterInterface/#Athena::Routing::ParamConverterInterface::TAG","text":"The tag name to apply to self in order for it to be registered with ART::Listeners::ParamConverter .","title":"TAG"},{"location":"Routing/ParamConverterInterface/#class-methods","text":"","title":"Class methods"},{"location":"Routing/ParamConverterInterface/#Athena::Routing::ParamConverterInterface.new()","text":"","title":".new"},{"location":"Routing/ParamConverterInterface/#methods","text":"","title":"Methods"},{"location":"Routing/ParamConverterInterface/#Athena::Routing::ParamConverterInterface#apply(request,configuration)","text":"Applies the conversion logic based on the provided request and configuration . Most commonly this involves setting/overriding a value stored in the request's ART::ParameterBag via request.attributes .","title":"#apply"},{"location":"Routing/ParamConverterInterface/#macros","text":"","title":"Macros"},{"location":"Routing/ParamConverterInterface/#Athena::Routing::ParamConverterInterface:configuration(*args)","text":"Helper macro for defining an ART::ParamConverterInterface::ConfigurationInterface ; similar to the record macro. Accepts a variable amount of variable names, types, and optionally default values. See the Additional Configuration example for more information.","title":"configuration"},{"location":"Routing/ParamConverterInterface/Configuration/","text":"struct Athena::Routing::ParamConverterInterface::Configuration inherits Athena::Routing::ParamConverterInterface::ConfigurationInterface The default ART::ParamConverterInterface::ConfigurationInterface object to use if one was not defined via the ART::ParamConverterInterface.configuration macro.","title":"Configuration"},{"location":"Routing/ParamConverterInterface/Configuration/#Athena::Routing::ParamConverterInterface::Configuration","text":"The default ART::ParamConverterInterface::ConfigurationInterface object to use if one was not defined via the ART::ParamConverterInterface.configuration macro.","title":"Configuration"},{"location":"Routing/ParamConverterInterface/ConfigurationInterface/","text":"abstract struct Athena::Routing::ParamConverterInterface::ConfigurationInterface inherits Struct Allows defining extra configuration data that can be supplied within the ART::ParamConverter annotation. By default this type includes the name of the argument that should be converted and the the ART::ParamConverterInterface that should be used for the conversion. See the Additional Configuration example for more information. Direct known subclasses Athena::Routing::ParamConverterInterface::Configuration Athena::Routing::TimeConverter::Configuration Class methods .new ( name : String , converter : ART :: ParamConverterInterface . class ) Methods #converter : ART :: ParamConverterInterface . class The converter class that should be used to convert the argument. #name : String The name of the argument the converter should be applied to.","title":"ConfigurationInterface"},{"location":"Routing/ParamConverterInterface/ConfigurationInterface/#Athena::Routing::ParamConverterInterface::ConfigurationInterface","text":"Allows defining extra configuration data that can be supplied within the ART::ParamConverter annotation. By default this type includes the name of the argument that should be converted and the the ART::ParamConverterInterface that should be used for the conversion. See the Additional Configuration example for more information.","title":"ConfigurationInterface"},{"location":"Routing/ParamConverterInterface/ConfigurationInterface/#direct-known-subclasses","text":"Athena::Routing::ParamConverterInterface::Configuration Athena::Routing::TimeConverter::Configuration","title":"Direct known subclasses"},{"location":"Routing/ParamConverterInterface/ConfigurationInterface/#class-methods","text":"","title":"Class methods"},{"location":"Routing/ParamConverterInterface/ConfigurationInterface/#Athena::Routing::ParamConverterInterface::ConfigurationInterface.new(name,converter)","text":"","title":".new"},{"location":"Routing/ParamConverterInterface/ConfigurationInterface/#methods","text":"","title":"Methods"},{"location":"Routing/ParamConverterInterface/ConfigurationInterface/#Athena::Routing::ParamConverterInterface::ConfigurationInterface#converter()","text":"The converter class that should be used to convert the argument.","title":"#converter"},{"location":"Routing/ParamConverterInterface/ConfigurationInterface/#Athena::Routing::ParamConverterInterface::ConfigurationInterface#name()","text":"The name of the argument the converter should be applied to.","title":"#name"},{"location":"Routing/ParameterBag/","text":"struct Athena::Routing::ParameterBag inherits Struct A container for storing key/value pairs. Can be used to store arbitrary data within the context of a request. It can be accessed via HTTP::Request#attributes . Example For example, an artbirary value can be stored in the attributes, and later provided as an action argument. require \"athena\" # Define a request listener to add our value before the action is executed. @[ ADI :: Register ] struct TestListener include AED :: EventListenerInterface def self . subscribed_events : AED :: SubscribedEvents AED :: SubscribedEvents { ART :: Events :: Request => 0 , } end def call ( event : ART :: Events :: Request , dispatcher : AED :: EventDispatcherInterface ) : Nil # Store our value within the request's attributes, restricted to a `String`. event . request . attributes . set \"my_arg\" , \"foo\" , String end end class ExampleController < ART :: Controller # Define an action argument with the same name of the argument stored in attributes. # # The argument is resolved via `ART::Arguments::Resolvers::RequestAttribute`. get \"/\" , my_arg : String do my_arg end end ART . run # GET / # => \"foo\" Class methods .new Methods #get ( name : String , _type : Int8 . class ) : Int8 Returns the value of the parameter with the provided name as a Int8 . #get ( name : String , _type : Bool . class ) : Bool Returns the value of the parameter with the provided name as a Bool . #get ( name : String , _type : String . class ) : String Returns the value of the parameter with the provided name as a String . #get ( name : String , _type : Float32 . class ) : Float32 Returns the value of the parameter with the provided name as a Float32 . #get ( name : String , _type : Float64 . class ) : Float64 Returns the value of the parameter with the provided name as a Float64 . #get ( name : String , _type : Int128 . class ) : Int128 Returns the value of the parameter with the provided name as a Int128 . #get ( name : String , _type : Int16 . class ) : Int16 Returns the value of the parameter with the provided name as a Int16 . #get ( name : String , _type : Int32 . class ) : Int32 Returns the value of the parameter with the provided name as a Int32 . #get ( name : String , _type : Int64 . class ) : Int64 Returns the value of the parameter with the provided name as a Int64 . #get ( name : String ) Returns the value of the parameter with the provided name . Raises a KeyError if no parameter with that name exists. #get ( name : String , _type : UInt128 . class ) : UInt128 Returns the value of the parameter with the provided name as a UInt128 . #get ( name : String , _type : UInt16 . class ) : UInt16 Returns the value of the parameter with the provided name as a UInt16 . #get ( name : String , _type : UInt32 . class ) : UInt32 Returns the value of the parameter with the provided name as a UInt32 . #get ( name : String , _type : UInt64 . class ) : UInt64 Returns the value of the parameter with the provided name as a UInt64 . #get ( name : String , _type : UInt8 . class ) : UInt8 Returns the value of the parameter with the provided name as a UInt8 . #get? ( name : String ) Returns the value of the parameter with the provided name if it exists, otherwise nil . #has? ( name : String ) : Bool Returns true if a parameter with the provided name exists, otherwise false . #remove ( name : String ) : Nil Removes the parameter with the provided name . #set ( name : String , value : _ , type : T . class ) : Nil forall T Sets a parameter with the provided name to value , restricted to the given type . #set ( name : String , value : T ) : Nil forall T Sets a parameter with the provided name to value .","title":"ParameterBag"},{"location":"Routing/ParameterBag/#Athena::Routing::ParameterBag","text":"A container for storing key/value pairs. Can be used to store arbitrary data within the context of a request. It can be accessed via HTTP::Request#attributes .","title":"ParameterBag"},{"location":"Routing/ParameterBag/#Athena::Routing::ParameterBag--example","text":"For example, an artbirary value can be stored in the attributes, and later provided as an action argument. require \"athena\" # Define a request listener to add our value before the action is executed. @[ ADI :: Register ] struct TestListener include AED :: EventListenerInterface def self . subscribed_events : AED :: SubscribedEvents AED :: SubscribedEvents { ART :: Events :: Request => 0 , } end def call ( event : ART :: Events :: Request , dispatcher : AED :: EventDispatcherInterface ) : Nil # Store our value within the request's attributes, restricted to a `String`. event . request . attributes . set \"my_arg\" , \"foo\" , String end end class ExampleController < ART :: Controller # Define an action argument with the same name of the argument stored in attributes. # # The argument is resolved via `ART::Arguments::Resolvers::RequestAttribute`. get \"/\" , my_arg : String do my_arg end end ART . run # GET / # => \"foo\"","title":"Example"},{"location":"Routing/ParameterBag/#class-methods","text":"","title":"Class methods"},{"location":"Routing/ParameterBag/#Athena::Routing::ParameterBag.new()","text":"","title":".new"},{"location":"Routing/ParameterBag/#methods","text":"","title":"Methods"},{"location":"Routing/ParameterBag/#Athena::Routing::ParameterBag#get(name,_type)","text":"Returns the value of the parameter with the provided name as a Int8 .","title":"#get"},{"location":"Routing/ParameterBag/#Athena::Routing::ParameterBag#get(name,_type)","text":"Returns the value of the parameter with the provided name as a Bool .","title":"#get"},{"location":"Routing/ParameterBag/#Athena::Routing::ParameterBag#get(name,_type)","text":"Returns the value of the parameter with the provided name as a String .","title":"#get"},{"location":"Routing/ParameterBag/#Athena::Routing::ParameterBag#get(name,_type)","text":"Returns the value of the parameter with the provided name as a Float32 .","title":"#get"},{"location":"Routing/ParameterBag/#Athena::Routing::ParameterBag#get(name,_type)","text":"Returns the value of the parameter with the provided name as a Float64 .","title":"#get"},{"location":"Routing/ParameterBag/#Athena::Routing::ParameterBag#get(name,_type)","text":"Returns the value of the parameter with the provided name as a Int128 .","title":"#get"},{"location":"Routing/ParameterBag/#Athena::Routing::ParameterBag#get(name,_type)","text":"Returns the value of the parameter with the provided name as a Int16 .","title":"#get"},{"location":"Routing/ParameterBag/#Athena::Routing::ParameterBag#get(name,_type)","text":"Returns the value of the parameter with the provided name as a Int32 .","title":"#get"},{"location":"Routing/ParameterBag/#Athena::Routing::ParameterBag#get(name,_type)","text":"Returns the value of the parameter with the provided name as a Int64 .","title":"#get"},{"location":"Routing/ParameterBag/#Athena::Routing::ParameterBag#get(name,_type)","text":"Returns the value of the parameter with the provided name as a UInt128 .","title":"#get"},{"location":"Routing/ParameterBag/#Athena::Routing::ParameterBag#get(name,_type)","text":"Returns the value of the parameter with the provided name as a UInt16 .","title":"#get"},{"location":"Routing/ParameterBag/#Athena::Routing::ParameterBag#get(name,_type)","text":"Returns the value of the parameter with the provided name as a UInt32 .","title":"#get"},{"location":"Routing/ParameterBag/#Athena::Routing::ParameterBag#get(name,_type)","text":"Returns the value of the parameter with the provided name as a UInt64 .","title":"#get"},{"location":"Routing/ParameterBag/#Athena::Routing::ParameterBag#get(name,_type)","text":"Returns the value of the parameter with the provided name as a UInt8 .","title":"#get"},{"location":"Routing/ParameterBag/#Athena::Routing::ParameterBag#get?(name)","text":"Returns the value of the parameter with the provided name if it exists, otherwise nil .","title":"#get?"},{"location":"Routing/ParameterBag/#Athena::Routing::ParameterBag#has?(name)","text":"Returns true if a parameter with the provided name exists, otherwise false .","title":"#has?"},{"location":"Routing/ParameterBag/#Athena::Routing::ParameterBag#remove(name)","text":"Removes the parameter with the provided name .","title":"#remove"},{"location":"Routing/ParameterBag/#Athena::Routing::ParameterBag#set(name,value,type)","text":"Sets a parameter with the provided name to value , restricted to the given type .","title":"#set"},{"location":"Routing/Params/","text":"module Athena::Routing::Params Namespace for types related to request parameter processing. See ART::QueryParam and ART::RequestParam .","title":"Params"},{"location":"Routing/Params/#Athena::Routing::Params","text":"Namespace for types related to request parameter processing. See ART::QueryParam and ART::RequestParam .","title":"Params"},{"location":"Routing/Params/Param/","text":"abstract struct Athena::Routing::Params::Param inherits Struct Base implementation of ART::Params::ParamInterface . Direct known subclasses Athena::Routing::Params::ScalarParam Class methods .new ( name : String , has_default : Bool = false , incompatibles : Array ( String )? = nil , strict : Bool = true , nilable : Bool = false , key : String ? = nil , description : String ? = nil ) Methods #constraints : Array ( AVD::Constraint ) :inherit: #description : String ? :inherit: #has_default? : Bool If this argument has a default value. #incompatibles : Array ( String )? :inherit: #key : String Returns the key that should be used to access self from a given request. Defaults to #name , but may be customized. See ART::QueryParam@key . #name : String :inherit: #nilable? : Bool If nil is a valid value for the param. #strict? : Bool :inherit:","title":"Param"},{"location":"Routing/Params/Param/#Athena::Routing::Params::Param","text":"Base implementation of ART::Params::ParamInterface .","title":"Param"},{"location":"Routing/Params/Param/#direct-known-subclasses","text":"Athena::Routing::Params::ScalarParam","title":"Direct known subclasses"},{"location":"Routing/Params/Param/#class-methods","text":"","title":"Class methods"},{"location":"Routing/Params/Param/#Athena::Routing::Params::Param.new(name,has_default,incompatibles,strict,nilable,key,description)","text":"","title":".new"},{"location":"Routing/Params/Param/#methods","text":"","title":"Methods"},{"location":"Routing/Params/Param/#Athena::Routing::Params::Param#constraints()","text":":inherit:","title":"#constraints"},{"location":"Routing/Params/Param/#Athena::Routing::Params::Param#description()","text":":inherit:","title":"#description"},{"location":"Routing/Params/Param/#Athena::Routing::Params::Param#has_default?()","text":"If this argument has a default value.","title":"#has_default?"},{"location":"Routing/Params/Param/#Athena::Routing::Params::Param#incompatibles()","text":":inherit:","title":"#incompatibles"},{"location":"Routing/Params/Param/#Athena::Routing::Params::Param#key()","text":"Returns the key that should be used to access self from a given request. Defaults to #name , but may be customized. See ART::QueryParam@key .","title":"#key"},{"location":"Routing/Params/Param/#Athena::Routing::Params::Param#name()","text":":inherit:","title":"#name"},{"location":"Routing/Params/Param/#Athena::Routing::Params::Param#nilable?()","text":"If nil is a valid value for the param.","title":"#nilable?"},{"location":"Routing/Params/Param/#Athena::Routing::Params::Param#strict?()","text":":inherit:","title":"#strict?"},{"location":"Routing/Params/ParamFetcher/","text":"class Athena::Routing::Params::ParamFetcher inherits Reference Basic implementation of ART::Params::ParamFetcherInterface . NOTE: May only be used after the related ART::Action has been resolved. Included modules Athena::Routing::Params::ParamFetcherInterface Class methods .new ( request_store : ART::RequestStore , validator : AVD::Validator::ValidatorInterface ) Methods #each ( strict : Bool ? = nil , & ) : Nil Yields the name and value of each ART::Params::ParamInterface related to the current ART::Action#params . Optionally allows determing if the params should be validated strictly. See ART::QueryParam@strict . #get ( name : String , strict : Bool ? = nil ) Returns the value of the parameter with the provided name . Optionally allows determing if the params should be validated strictly. See ART::QueryParam@strict .","title":"ParamFetcher"},{"location":"Routing/Params/ParamFetcher/#Athena::Routing::Params::ParamFetcher","text":"Basic implementation of ART::Params::ParamFetcherInterface . NOTE: May only be used after the related ART::Action has been resolved.","title":"ParamFetcher"},{"location":"Routing/Params/ParamFetcher/#included-modules","text":"Athena::Routing::Params::ParamFetcherInterface","title":"Included modules"},{"location":"Routing/Params/ParamFetcher/#class-methods","text":"","title":"Class methods"},{"location":"Routing/Params/ParamFetcher/#Athena::Routing::Params::ParamFetcher.new(request_store,validator)","text":"","title":".new"},{"location":"Routing/Params/ParamFetcher/#methods","text":"","title":"Methods"},{"location":"Routing/Params/ParamFetcher/#Athena::Routing::Params::ParamFetcher#each(strict)","text":"Yields the name and value of each ART::Params::ParamInterface related to the current ART::Action#params . Optionally allows determing if the params should be validated strictly. See ART::QueryParam@strict .","title":"#each"},{"location":"Routing/Params/ParamFetcher/#Athena::Routing::Params::ParamFetcher#get(name,strict)","text":"Returns the value of the parameter with the provided name . Optionally allows determing if the params should be validated strictly. See ART::QueryParam@strict .","title":"#get"},{"location":"Routing/Params/ParamFetcherInterface/","text":"module Athena::Routing::Params::ParamFetcherInterface Provides an API to fetch parameters from the current request. Direct including types Athena::Routing::Params::ParamFetcher Methods abstract #each ( strict : Bool ? = nil , & : String , _ -> Nil ) : Nil Yields the name and value of each ART::Params::ParamInterface related to the current ART::Action#params . Optionally allows determing if the params should be validated strictly. See ART::QueryParam@strict . abstract #get ( name : String , strict : Bool ? = nil ) Returns the value of the parameter with the provided name . Optionally allows determing if the params should be validated strictly. See ART::QueryParam@strict .","title":"ParamFetcherInterface"},{"location":"Routing/Params/ParamFetcherInterface/#Athena::Routing::Params::ParamFetcherInterface","text":"Provides an API to fetch parameters from the current request.","title":"ParamFetcherInterface"},{"location":"Routing/Params/ParamFetcherInterface/#direct-including-types","text":"Athena::Routing::Params::ParamFetcher","title":"Direct including types"},{"location":"Routing/Params/ParamFetcherInterface/#methods","text":"","title":"Methods"},{"location":"Routing/Params/ParamFetcherInterface/#Athena::Routing::Params::ParamFetcherInterface#each(strict,&)","text":"Yields the name and value of each ART::Params::ParamInterface related to the current ART::Action#params . Optionally allows determing if the params should be validated strictly. See ART::QueryParam@strict .","title":"#each"},{"location":"Routing/Params/ParamFetcherInterface/#Athena::Routing::Params::ParamFetcherInterface#get(name,strict)","text":"Returns the value of the parameter with the provided name . Optionally allows determing if the params should be validated strictly. See ART::QueryParam@strict .","title":"#get"},{"location":"Routing/Params/ParamInterface/","text":"module Athena::Routing::Params::ParamInterface Represents a request parameter; e.x. query param, form data, a file, etc. See ART::QueryParam and ART::RequestParam . Direct including types Athena::Routing::Params::QueryParam(T) Athena::Routing::Params::RequestParam(T) Methods abstract #constraints : Array ( AVD::Constraint ) Returns the AVD::Constraint s that should be used to validate the parameter's value. abstract #default Returns the value that should be used if #strict? is false and the parameter was not provided, defaulting to nil . abstract #description : String ? Returns a human readable summary of what the parameter is used for. In the future this may be used to supplement auto generated endpoint documentation. abstract #extract_value ( request : HTTP::Request , default : _ = nil ) Returns the self 's value from the provided request , or default if it was not present. abstract #incompatibles : Array ( String )? Returns the parameters that may not be present at the same time as self . See ART::QueryParam@incompatibles . abstract #name : String Returns the name of the parameter, maps to the controller action argument name. abstract #strict? : Bool Denotes whether self should be processed strictly. See ART::QueryParam@strict .","title":"ParamInterface"},{"location":"Routing/Params/ParamInterface/#Athena::Routing::Params::ParamInterface","text":"Represents a request parameter; e.x. query param, form data, a file, etc. See ART::QueryParam and ART::RequestParam .","title":"ParamInterface"},{"location":"Routing/Params/ParamInterface/#direct-including-types","text":"Athena::Routing::Params::QueryParam(T) Athena::Routing::Params::RequestParam(T)","title":"Direct including types"},{"location":"Routing/Params/ParamInterface/#methods","text":"","title":"Methods"},{"location":"Routing/Params/ParamInterface/#Athena::Routing::Params::ParamInterface#constraints()","text":"Returns the AVD::Constraint s that should be used to validate the parameter's value.","title":"#constraints"},{"location":"Routing/Params/ParamInterface/#Athena::Routing::Params::ParamInterface#default()","text":"Returns the value that should be used if #strict? is false and the parameter was not provided, defaulting to nil .","title":"#default"},{"location":"Routing/Params/ParamInterface/#Athena::Routing::Params::ParamInterface#description()","text":"Returns a human readable summary of what the parameter is used for. In the future this may be used to supplement auto generated endpoint documentation.","title":"#description"},{"location":"Routing/Params/ParamInterface/#Athena::Routing::Params::ParamInterface#extract_value(request,default)","text":"Returns the self 's value from the provided request , or default if it was not present.","title":"#extract_value"},{"location":"Routing/Params/ParamInterface/#Athena::Routing::Params::ParamInterface#incompatibles()","text":"Returns the parameters that may not be present at the same time as self . See ART::QueryParam@incompatibles .","title":"#incompatibles"},{"location":"Routing/Params/ParamInterface/#Athena::Routing::Params::ParamInterface#name()","text":"Returns the name of the parameter, maps to the controller action argument name.","title":"#name"},{"location":"Routing/Params/ParamInterface/#Athena::Routing::Params::ParamInterface#strict?()","text":"Denotes whether self should be processed strictly. See ART::QueryParam@strict .","title":"#strict?"},{"location":"Routing/Params/QueryParam/","text":"struct Athena::Routing::Params::QueryParam(T) inherits Athena::Routing::Params::ScalarParam Represents a request's query parameter. See ART::QueryParam . Included modules Athena::Routing::Params::ParamInterface Class methods .new ( name : String , has_default : Bool = false , incompatibles : Array ( String )? = nil , requirements : AVD::Constraint | Array ( AVD::Constraint ) | Regex | Nil = nil , map : Bool = false , is_nilable : Bool = false , strict : Bool = true , key : String ? = nil , description : String ? = nil , default : T? = nil , type : T . class = T , converter : Nil ? = nil ) Methods #default : T? Returns the value that should be used if #strict? is false and the parameter was not provided, defaulting to nil . #extract_value ( request : HTTP::Request , default : _ = nil ) Returns the self 's value from the provided request , or default if it was not present. #type : T . class The type of the parameter, i.e. what its type restriction is.","title":"QueryParam"},{"location":"Routing/Params/QueryParam/#Athena::Routing::Params::QueryParam","text":"Represents a request's query parameter. See ART::QueryParam .","title":"QueryParam"},{"location":"Routing/Params/QueryParam/#included-modules","text":"Athena::Routing::Params::ParamInterface","title":"Included modules"},{"location":"Routing/Params/QueryParam/#class-methods","text":"","title":"Class methods"},{"location":"Routing/Params/QueryParam/#Athena::Routing::Params::QueryParam.new(name,has_default,incompatibles,requirements,map,is_nilable,strict,key,description,default,type,converter)","text":"","title":".new"},{"location":"Routing/Params/QueryParam/#methods","text":"","title":"Methods"},{"location":"Routing/Params/QueryParam/#Athena::Routing::Params::QueryParam#default()","text":"Returns the value that should be used if #strict? is false and the parameter was not provided, defaulting to nil .","title":"#default"},{"location":"Routing/Params/QueryParam/#Athena::Routing::Params::QueryParam#extract_value(request,default)","text":"Returns the self 's value from the provided request , or default if it was not present.","title":"#extract_value"},{"location":"Routing/Params/QueryParam/#Athena::Routing::Params::QueryParam#type()","text":"The type of the parameter, i.e. what its type restriction is.","title":"#type"},{"location":"Routing/Params/RequestParam/","text":"struct Athena::Routing::Params::RequestParam(T) inherits Athena::Routing::Params::ScalarParam Represents form data with a request's body. See ART::RequestParam . Included modules Athena::Routing::Params::ParamInterface Class methods .new ( name : String , has_default : Bool = false , incompatibles : Array ( String )? = nil , requirements : AVD::Constraint | Array ( AVD::Constraint ) | Regex | Nil = nil , map : Bool = false , is_nilable : Bool = false , strict : Bool = true , key : String ? = nil , description : String ? = nil , default : T? = nil , type : T . class = T , converter : Nil ? = nil ) Methods #default : T? Returns the value that should be used if #strict? is false and the parameter was not provided, defaulting to nil . #extract_value ( request : HTTP::Request , default : _ = nil ) Returns the self 's value from the provided request , or default if it was not present. #type : T . class The type of the parameter, i.e. what its type restriction is.","title":"RequestParam"},{"location":"Routing/Params/RequestParam/#Athena::Routing::Params::RequestParam","text":"Represents form data with a request's body. See ART::RequestParam .","title":"RequestParam"},{"location":"Routing/Params/RequestParam/#included-modules","text":"Athena::Routing::Params::ParamInterface","title":"Included modules"},{"location":"Routing/Params/RequestParam/#class-methods","text":"","title":"Class methods"},{"location":"Routing/Params/RequestParam/#Athena::Routing::Params::RequestParam.new(name,has_default,incompatibles,requirements,map,is_nilable,strict,key,description,default,type,converter)","text":"","title":".new"},{"location":"Routing/Params/RequestParam/#methods","text":"","title":"Methods"},{"location":"Routing/Params/RequestParam/#Athena::Routing::Params::RequestParam#default()","text":"Returns the value that should be used if #strict? is false and the parameter was not provided, defaulting to nil .","title":"#default"},{"location":"Routing/Params/RequestParam/#Athena::Routing::Params::RequestParam#extract_value(request,default)","text":"Returns the self 's value from the provided request , or default if it was not present.","title":"#extract_value"},{"location":"Routing/Params/RequestParam/#Athena::Routing::Params::RequestParam#type()","text":"The type of the parameter, i.e. what its type restriction is.","title":"#type"},{"location":"Routing/Params/ScalarParam/","text":"abstract struct Athena::Routing::Params::ScalarParam inherits Athena::Routing::Params::Param Extension of ART::Params::Param that allows for more granular validation of scalar parameters. Direct known subclasses Athena::Routing::Params::QueryParam(T) Athena::Routing::Params::RequestParam(T) Class methods .new ( name : String , has_default : Bool = false , incompatibles : Array ( String )? = nil , requirements : AVD::Constraint | Array ( AVD::Constraint ) | Regex | Nil = nil , map : Bool = false , strict : Bool = true , nilable : Bool = false , key : String ? = nil , description : String ? = nil ) Methods #constraints : Array ( AVD::Constraint ) :inherit: #map? : Bool Denotes whether the #requirements should be applied to the whole value, or to each item a part of the value. See ART::QueryParam@map . #requirements : AVD::Constraint | Array ( AVD::Constraint ) | Regex | Nil Returns the requirements that the value is required to pass in order to be considered valid. See ART::QueryParam@requirements .","title":"ScalarParam"},{"location":"Routing/Params/ScalarParam/#Athena::Routing::Params::ScalarParam","text":"Extension of ART::Params::Param that allows for more granular validation of scalar parameters.","title":"ScalarParam"},{"location":"Routing/Params/ScalarParam/#direct-known-subclasses","text":"Athena::Routing::Params::QueryParam(T) Athena::Routing::Params::RequestParam(T)","title":"Direct known subclasses"},{"location":"Routing/Params/ScalarParam/#class-methods","text":"","title":"Class methods"},{"location":"Routing/Params/ScalarParam/#Athena::Routing::Params::ScalarParam.new(name,has_default,incompatibles,requirements,map,strict,nilable,key,description)","text":"","title":".new"},{"location":"Routing/Params/ScalarParam/#methods","text":"","title":"Methods"},{"location":"Routing/Params/ScalarParam/#Athena::Routing::Params::ScalarParam#constraints()","text":":inherit:","title":"#constraints"},{"location":"Routing/Params/ScalarParam/#Athena::Routing::Params::ScalarParam#map?()","text":"Denotes whether the #requirements should be applied to the whole value, or to each item a part of the value. See ART::QueryParam@map .","title":"#map?"},{"location":"Routing/Params/ScalarParam/#Athena::Routing::Params::ScalarParam#requirements()","text":"Returns the requirements that the value is required to pass in order to be considered valid. See ART::QueryParam@requirements .","title":"#requirements"},{"location":"Routing/Patch/","text":"annotation Athena::Routing::Patch Defines a PATCH endpoint. Fields path : String - The path for the endpoint, may also be provided as the first positional argument. name : String - The name of the route. Defaults to controller name + method name down snake-cased. constraints : Hash(String, Regex) - A mapping between a route's path parameters and its constraints. Example @[ ART :: Patch ( path : \"/users/:id\" ) ] def partial_update_user ( id : Int32 ) : Nil end","title":"Patch"},{"location":"Routing/Patch/#Athena::Routing::Patch","text":"Defines a PATCH endpoint.","title":"Patch"},{"location":"Routing/Patch/#Athena::Routing::Patch--fields","text":"path : String - The path for the endpoint, may also be provided as the first positional argument. name : String - The name of the route. Defaults to controller name + method name down snake-cased. constraints : Hash(String, Regex) - A mapping between a route's path parameters and its constraints.","title":"Fields"},{"location":"Routing/Patch/#Athena::Routing::Patch--example","text":"@[ ART :: Patch ( path : \"/users/:id\" ) ] def partial_update_user ( id : Int32 ) : Nil end","title":"Example"},{"location":"Routing/Post/","text":"annotation Athena::Routing::Post Defines a POST endpoint. Fields path : String - The path for the endpoint, may also be provided as the first positional argument. name : String - The name of the route. Defaults to controller name + method name down snake-cased. constraints : Hash(String, Regex) - A mapping between a route's path parameters and its constraints. Example @[ ART :: Post ( path : \"/users\" ) ] def new_user : Nil end","title":"Post"},{"location":"Routing/Post/#Athena::Routing::Post","text":"Defines a POST endpoint.","title":"Post"},{"location":"Routing/Post/#Athena::Routing::Post--fields","text":"path : String - The path for the endpoint, may also be provided as the first positional argument. name : String - The name of the route. Defaults to controller name + method name down snake-cased. constraints : Hash(String, Regex) - A mapping between a route's path parameters and its constraints.","title":"Fields"},{"location":"Routing/Post/#Athena::Routing::Post--example","text":"@[ ART :: Post ( path : \"/users\" ) ] def new_user : Nil end","title":"Example"},{"location":"Routing/Prefix/","text":"annotation Athena::Routing::Prefix Apply a prefix to all actions within self . Can be a static string, but may also contain path arguments. Fields prefix : String - The path prefix to use, may also be provided as the first positional argument. Example @[ ART :: Prefix ( prefix : \"calendar\" ) ] class CalendarController < ART :: Controller # The route of this action would be `GET /calendar/events`. @[ ART :: Get ( path : \"events\" ) ] def events : String \"events\" end end","title":"Prefix"},{"location":"Routing/Prefix/#Athena::Routing::Prefix","text":"Apply a prefix to all actions within self . Can be a static string, but may also contain path arguments.","title":"Prefix"},{"location":"Routing/Prefix/#Athena::Routing::Prefix--fields","text":"prefix : String - The path prefix to use, may also be provided as the first positional argument.","title":"Fields"},{"location":"Routing/Prefix/#Athena::Routing::Prefix--example","text":"@[ ART :: Prefix ( prefix : \"calendar\" ) ] class CalendarController < ART :: Controller # The route of this action would be `GET /calendar/events`. @[ ART :: Get ( path : \"events\" ) ] def events : String \"events\" end end","title":"Example"},{"location":"Routing/Put/","text":"annotation Athena::Routing::Put Defines a PUT endpoint. Fields path : String - The path for the endpoint, may also be provided as the first positional argument. name : String - The name of the route. Defaults to controller name + method name down snake-cased. constraints : Hash(String, Regex) - A mapping between a route's path parameters and its constraints. Example @[ ART :: Put ( path : \"/users/:id\" ) ] def update_user ( id : Int32 ) : Nil end","title":"Put"},{"location":"Routing/Put/#Athena::Routing::Put","text":"Defines a PUT endpoint.","title":"Put"},{"location":"Routing/Put/#Athena::Routing::Put--fields","text":"path : String - The path for the endpoint, may also be provided as the first positional argument. name : String - The name of the route. Defaults to controller name + method name down snake-cased. constraints : Hash(String, Regex) - A mapping between a route's path parameters and its constraints.","title":"Fields"},{"location":"Routing/Put/#Athena::Routing::Put--example","text":"@[ ART :: Put ( path : \"/users/:id\" ) ] def update_user ( id : Int32 ) : Nil end","title":"Example"},{"location":"Routing/QueryParam/","text":"annotation Athena::Routing::QueryParam Used to define (and configure) a query parameter tied to a given argument. The type of the query param is derived from the type restriction of the associated controller action argument. Usage The most basic usage is adding an annotation to a controller action whose name matches a controller action argument. A description may also be included to describe what the query param is used for. In the future this may be used for generating OpenAPI documentation for the related parameter. A non-nilable type denotes it as required. If the parameter is not supplied, and no default value is assigned, an ART::Exceptions::BadRequest exception is raised. class ExampleController < ART :: Controller @[ ART :: Get ( \"/\" ) ] @[ ART :: QueryParam ( \"page\" , description : \"What page of results to return.\" ) ] # The name can also be supplied as a named argument like `@[ART::QueryParam(name: \"page\")]`. def index ( page : Int32 ) : Int32 page end end ART . run # GET /?page=2 # => 2 # GET / # => {\"code\":422,\"message\":\"Parameter 'page' of value '' violated a constraint: 'This value should not be null.'\\n\"} Key In the case of wanting the controller action argument to have a different name than the actual query parameter, the key option can be used. class ExampleController < ART :: Controller @[ ART :: Get ( \"/\" ) ] @[ ART :: QueryParam ( \"foo\" , key : \"bar\" ) ] def index ( foo : String ) : String foo end end ART . run # GET /?bar=value # => \"value\" Optional A nilable type denotes it as optional. If the parameter is not supplied, and no default value is assigned, it is nil . class ExampleController < ART :: Controller @[ ART :: Get ( \"/\" ) ] @[ ART :: QueryParam ( \"page\" ) ] # The name can also be supplied as a named argument like `@[ART::QueryParam(name: \"page\")]`. def index ( page : Int32 ?) : Int32 ? page end end ART . run # GET / # => null # GET /?page=2 # => 2 # GET /?page=bar # => {\"code\":400,\"message\":\"Required parameter 'page' with value 'bar' could not be converted into a valid '(Int32 | Nil)'.\"} Strict By default, parameters are validated strictly; this means an ART::Exceptions::BadRequest exception is raised when the value is considered invalid. Such as if the value does not satisfy the parameter's requirements , it's a required parameter and was not provided, or could not be converted into the desired type. An example of this is in the first usage example. A 400 bad request was returned when the required parameter was not provided. When strict mode is disabled, the default value (or nil ) will be used instead of raising an exception if the actual value is invalid. NOTE: When setting strict: false , the related controller action argument must be nilable or have a default value. class ExampleController < ART :: Controller @[ ART :: Get ( \"/\" ) ] @[ ART :: QueryParam ( \"page\" , strict : false ) ] def index ( page : Int32 ?) : Int32 ? page end end ART . run # GET / # => null # GET /?page=2 # => 2 # GET /?page=bar # => null If strict mode is enabled AND the argument is nilable, the value will only be checked strictly if it is provided and does not meet the parameter's requirements, or could not be converted. If it was not provided at all, nil , or the default value will be used. Requirements It's a common practice to validate incoming values before they reach the controller action. ART::QueryParam supports doing just that. It supports validating the value against a Regex pattern, an AVD::Constraint , or an array of AVD::Constraint s. The value is only considered valid if it satisfies the defined requirements. If the value does not match, and strict mode is enabled, a 422 response is returned; otherwise nil , or the default value is used instead. Regex The most basic form of validation is a Regex pattern that asserts a value matches the provided pattern. class ExampleController < ART :: Controller @[ ART :: Get ( \"/\" ) ] @[ ART :: QueryParam ( \"page\" , requirements : /\\d{2}/ ) ] def index ( page : Int32 ) : Int32 page end end ART . run # GET / # => {\"code\":422,\"message\":\"Parameter 'page' of value '' violated a constraint: 'This value should not be null.'\\n\"} # GET /?page=10 # => 10 # GET /?page=bar # => {\"code\":400,\"message\":\"Required parameter 'page' with value 'bar' could not be converted into a valid 'Int32'.\"} # GET /?page=5 # => {\"code\":422,\"message\":\"Parameter 'page' of value '5' violated a constraint: 'Parameter 'page' value does not match requirements: (?-imsx:^(?-imsx:\\\\d{2})$)'\\n\"} Constraint(s) In some cases validating a value may require more logic than is possible via a regular expression. A parameter's requirements can also be set to a specific, or array of, Assert AVD::Constraint annotations. class ExampleController < ART :: Controller @[ ART :: Get ( \"/\" ) ] @[ ART :: QueryParam ( \"page\" , requirements : @[ Assert :: PositiveOrZero ] ) ] def index ( page : Int32 ) : Int32 page end end ART . run # GET /?page=2 # => 2 # GET /?page=-5 # => {\"code\":422,\"message\":\"Parameter 'page' of value '-9' violated a constraint: 'This value should be positive or zero.'\\n\"} See the external documentation for more information. Map By default, the parameter's requirements are applied against the resulting value, which makes sense when working with scalar values. However, if the parameter is an Array of values, then it may make more sense to run the validations against each item in that array, as opposed to on the whole array itself. This behavior can be enabled by using the map: true option, which essentially wraps all the requirements within an AVD::Constraints::All constraint. class ExampleController < ART :: Controller @[ ART :: Get ( \"/\" ) ] @[ ART :: QueryParam ( \"ids\" , map : true , requirements : [@[ Assert :: Positive ] , @[ Assert :: Range ( - 3 .. 10 ) ]] ) ] def index ( ids : Array ( Int32 )) : Array ( Int32 ) ids end end ART . run # GET / # => {\"code\":422,\"message\":\"Parameter 'ids' of value '' violated a constraint: 'This value should not be null.'\\n\"} # GET /?ids=10&ids=2 # => [10,2] # GET /?ids=10&ids=-2 # => {\"code\":422,\"message\":\"Parameter 'ids[1]' of value '-2' violated a constraint: 'This value should be positive.'\\n\"} Incompatibles Incompatibles represent the parameters that can't be present at the same time. class ExampleController < ART :: Controller @[ ART :: Get ( \"/\" ) ] @[ ART :: QueryParam ( \"bar\" ) ] @[ ART :: QueryParam ( \"foo\" , incompatibles : [ \"bar\" ] ) ] def index ( foo : String ?, bar : String ?) : String \" #{ foo } - #{ bar } \" end end ART . run # GET /?bar=bar # => \"-bar\" # GET /?foo=foo # => \"foo-\" # GET /?foo=foo&bar=bar # => {\"code\":400,\"message\":\"Parameter 'foo' is incompatible with parameter 'bar'.\"} Param Converters While Athena is able to auto convert query parameters from their String representation to Bool , or Number types, it is unable to do that for more complex types, such as Time . In such cases an ART::ParamConverterInterface is required. For simple converters that do not require any additional configuration, you can just specify the ART::ParamConverterInterface.class you wish to use for this query parameter. Default and nilable values work as they do when not using a converter. class ExampleController < ART :: Controller @[ ART :: QueryParam ( \"start_time\" , converter : ART :: TimeConverter ) ] @[ ART :: Get ( \"/time\" ) ] def time ( start_time : Time = Time . utc ) : String \"Starting at: #{ start_time } \" end end ART . run # GET /time # => \"Starting at: 2020-11-25 20:29:55 UTC\" # GET /time?start_time=2020-04-07T12:34:56Z # => \"Starting at: 2020-04-07 12:34:56 UTC\" Extra Configuration In some cases a param converter may require additional configuration . In this case a NamedTuple may be provided as the value of converter . The named tuple must contain a name key that represents the ART::ParamConverterInterface.class you wish to use for this query parameter. Any additional key/value pairs will be passed to the param converter. class ExampleController < ART :: Controller @[ ART :: QueryParam ( \"start_time\" , converter : { name : ART :: TimeConverter , format : \"%Y--%m//%d %T\" }) ] @[ ART :: Get ( \"/time\" ) ] def time ( start_time : Time ) : String \"Starting at: #{ start_time } \" end end ART . run # GET /time?start_time=\"2020--04//07 12:34:56\" # => \"Starting at: 2020-04-07 12:34:56 UTC\" NOTE: The dedicated ART::ParamConverter annotation may be used as well, just be sure to give it and the query parameter the same name.","title":"QueryParam"},{"location":"Routing/QueryParam/#Athena::Routing::QueryParam","text":"Used to define (and configure) a query parameter tied to a given argument. The type of the query param is derived from the type restriction of the associated controller action argument.","title":"QueryParam"},{"location":"Routing/QueryParam/#Athena::Routing::QueryParam--usage","text":"The most basic usage is adding an annotation to a controller action whose name matches a controller action argument. A description may also be included to describe what the query param is used for. In the future this may be used for generating OpenAPI documentation for the related parameter. A non-nilable type denotes it as required. If the parameter is not supplied, and no default value is assigned, an ART::Exceptions::BadRequest exception is raised. class ExampleController < ART :: Controller @[ ART :: Get ( \"/\" ) ] @[ ART :: QueryParam ( \"page\" , description : \"What page of results to return.\" ) ] # The name can also be supplied as a named argument like `@[ART::QueryParam(name: \"page\")]`. def index ( page : Int32 ) : Int32 page end end ART . run # GET /?page=2 # => 2 # GET / # => {\"code\":422,\"message\":\"Parameter 'page' of value '' violated a constraint: 'This value should not be null.'\\n\"}","title":"Usage"},{"location":"Routing/QueryParam/#Athena::Routing::QueryParam--key","text":"In the case of wanting the controller action argument to have a different name than the actual query parameter, the key option can be used. class ExampleController < ART :: Controller @[ ART :: Get ( \"/\" ) ] @[ ART :: QueryParam ( \"foo\" , key : \"bar\" ) ] def index ( foo : String ) : String foo end end ART . run # GET /?bar=value # => \"value\"","title":"Key"},{"location":"Routing/QueryParam/#Athena::Routing::QueryParam--optional","text":"A nilable type denotes it as optional. If the parameter is not supplied, and no default value is assigned, it is nil . class ExampleController < ART :: Controller @[ ART :: Get ( \"/\" ) ] @[ ART :: QueryParam ( \"page\" ) ] # The name can also be supplied as a named argument like `@[ART::QueryParam(name: \"page\")]`. def index ( page : Int32 ?) : Int32 ? page end end ART . run # GET / # => null # GET /?page=2 # => 2 # GET /?page=bar # => {\"code\":400,\"message\":\"Required parameter 'page' with value 'bar' could not be converted into a valid '(Int32 | Nil)'.\"}","title":"Optional"},{"location":"Routing/QueryParam/#Athena::Routing::QueryParam--strict","text":"By default, parameters are validated strictly; this means an ART::Exceptions::BadRequest exception is raised when the value is considered invalid. Such as if the value does not satisfy the parameter's requirements , it's a required parameter and was not provided, or could not be converted into the desired type. An example of this is in the first usage example. A 400 bad request was returned when the required parameter was not provided. When strict mode is disabled, the default value (or nil ) will be used instead of raising an exception if the actual value is invalid. NOTE: When setting strict: false , the related controller action argument must be nilable or have a default value. class ExampleController < ART :: Controller @[ ART :: Get ( \"/\" ) ] @[ ART :: QueryParam ( \"page\" , strict : false ) ] def index ( page : Int32 ?) : Int32 ? page end end ART . run # GET / # => null # GET /?page=2 # => 2 # GET /?page=bar # => null If strict mode is enabled AND the argument is nilable, the value will only be checked strictly if it is provided and does not meet the parameter's requirements, or could not be converted. If it was not provided at all, nil , or the default value will be used.","title":"Strict"},{"location":"Routing/QueryParam/#Athena::Routing::QueryParam--requirements","text":"It's a common practice to validate incoming values before they reach the controller action. ART::QueryParam supports doing just that. It supports validating the value against a Regex pattern, an AVD::Constraint , or an array of AVD::Constraint s. The value is only considered valid if it satisfies the defined requirements. If the value does not match, and strict mode is enabled, a 422 response is returned; otherwise nil , or the default value is used instead.","title":"Requirements"},{"location":"Routing/QueryParam/#Athena::Routing::QueryParam--regex","text":"The most basic form of validation is a Regex pattern that asserts a value matches the provided pattern. class ExampleController < ART :: Controller @[ ART :: Get ( \"/\" ) ] @[ ART :: QueryParam ( \"page\" , requirements : /\\d{2}/ ) ] def index ( page : Int32 ) : Int32 page end end ART . run # GET / # => {\"code\":422,\"message\":\"Parameter 'page' of value '' violated a constraint: 'This value should not be null.'\\n\"} # GET /?page=10 # => 10 # GET /?page=bar # => {\"code\":400,\"message\":\"Required parameter 'page' with value 'bar' could not be converted into a valid 'Int32'.\"} # GET /?page=5 # => {\"code\":422,\"message\":\"Parameter 'page' of value '5' violated a constraint: 'Parameter 'page' value does not match requirements: (?-imsx:^(?-imsx:\\\\d{2})$)'\\n\"}","title":"Regex"},{"location":"Routing/QueryParam/#Athena::Routing::QueryParam--constraints","text":"In some cases validating a value may require more logic than is possible via a regular expression. A parameter's requirements can also be set to a specific, or array of, Assert AVD::Constraint annotations. class ExampleController < ART :: Controller @[ ART :: Get ( \"/\" ) ] @[ ART :: QueryParam ( \"page\" , requirements : @[ Assert :: PositiveOrZero ] ) ] def index ( page : Int32 ) : Int32 page end end ART . run # GET /?page=2 # => 2 # GET /?page=-5 # => {\"code\":422,\"message\":\"Parameter 'page' of value '-9' violated a constraint: 'This value should be positive or zero.'\\n\"} See the external documentation for more information.","title":"Constraint(s)"},{"location":"Routing/QueryParam/#Athena::Routing::QueryParam--map","text":"By default, the parameter's requirements are applied against the resulting value, which makes sense when working with scalar values. However, if the parameter is an Array of values, then it may make more sense to run the validations against each item in that array, as opposed to on the whole array itself. This behavior can be enabled by using the map: true option, which essentially wraps all the requirements within an AVD::Constraints::All constraint. class ExampleController < ART :: Controller @[ ART :: Get ( \"/\" ) ] @[ ART :: QueryParam ( \"ids\" , map : true , requirements : [@[ Assert :: Positive ] , @[ Assert :: Range ( - 3 .. 10 ) ]] ) ] def index ( ids : Array ( Int32 )) : Array ( Int32 ) ids end end ART . run # GET / # => {\"code\":422,\"message\":\"Parameter 'ids' of value '' violated a constraint: 'This value should not be null.'\\n\"} # GET /?ids=10&ids=2 # => [10,2] # GET /?ids=10&ids=-2 # => {\"code\":422,\"message\":\"Parameter 'ids[1]' of value '-2' violated a constraint: 'This value should be positive.'\\n\"}","title":"Map"},{"location":"Routing/QueryParam/#Athena::Routing::QueryParam--incompatibles","text":"Incompatibles represent the parameters that can't be present at the same time. class ExampleController < ART :: Controller @[ ART :: Get ( \"/\" ) ] @[ ART :: QueryParam ( \"bar\" ) ] @[ ART :: QueryParam ( \"foo\" , incompatibles : [ \"bar\" ] ) ] def index ( foo : String ?, bar : String ?) : String \" #{ foo } - #{ bar } \" end end ART . run # GET /?bar=bar # => \"-bar\" # GET /?foo=foo # => \"foo-\" # GET /?foo=foo&bar=bar # => {\"code\":400,\"message\":\"Parameter 'foo' is incompatible with parameter 'bar'.\"}","title":"Incompatibles"},{"location":"Routing/QueryParam/#Athena::Routing::QueryParam--param-converters","text":"While Athena is able to auto convert query parameters from their String representation to Bool , or Number types, it is unable to do that for more complex types, such as Time . In such cases an ART::ParamConverterInterface is required. For simple converters that do not require any additional configuration, you can just specify the ART::ParamConverterInterface.class you wish to use for this query parameter. Default and nilable values work as they do when not using a converter. class ExampleController < ART :: Controller @[ ART :: QueryParam ( \"start_time\" , converter : ART :: TimeConverter ) ] @[ ART :: Get ( \"/time\" ) ] def time ( start_time : Time = Time . utc ) : String \"Starting at: #{ start_time } \" end end ART . run # GET /time # => \"Starting at: 2020-11-25 20:29:55 UTC\" # GET /time?start_time=2020-04-07T12:34:56Z # => \"Starting at: 2020-04-07 12:34:56 UTC\"","title":"Param Converters"},{"location":"Routing/QueryParam/#Athena::Routing::QueryParam--extra-configuration","text":"In some cases a param converter may require additional configuration . In this case a NamedTuple may be provided as the value of converter . The named tuple must contain a name key that represents the ART::ParamConverterInterface.class you wish to use for this query parameter. Any additional key/value pairs will be passed to the param converter. class ExampleController < ART :: Controller @[ ART :: QueryParam ( \"start_time\" , converter : { name : ART :: TimeConverter , format : \"%Y--%m//%d %T\" }) ] @[ ART :: Get ( \"/time\" ) ] def time ( start_time : Time ) : String \"Starting at: #{ start_time } \" end end ART . run # GET /time?start_time=\"2020--04//07 12:34:56\" # => \"Starting at: 2020-04-07 12:34:56 UTC\" NOTE: The dedicated ART::ParamConverter annotation may be used as well, just be sure to give it and the query parameter the same name.","title":"Extra Configuration"},{"location":"Routing/RedirectResponse/","text":"class Athena::Routing::RedirectResponse inherits Athena::Routing::Response Represents an HTTP response that does a redirect. Can be used as an easier way to handle redirects as well as providing type safety that a route should redirect. require \"athena\" class RedirectController < ART :: Controller @[ ART :: Get ( path : \"/go_to_crystal\" ) ] def redirect_to_crystal : ART :: RedirectResponse ART :: RedirectResponse . new \"https://crystal-lang.org\" end end ART . run # GET /go_to_crystal # => (redirected to https://crystal-lang.org) Class methods .new ( url : String , status : HTTP :: Status | Int32 = HTTP :: Status :: FOUND , headers : HTTP :: Headers = HTTP :: Headers . new ) Creates a response that should redirect to the provided url with the provided status , defaults to 302. An ArgumentError is raised if url is blank, or if status is not a valid redirection status code. Methods #url : String The url that the request will be redirected to.","title":"RedirectResponse"},{"location":"Routing/RedirectResponse/#Athena::Routing::RedirectResponse","text":"Represents an HTTP response that does a redirect. Can be used as an easier way to handle redirects as well as providing type safety that a route should redirect. require \"athena\" class RedirectController < ART :: Controller @[ ART :: Get ( path : \"/go_to_crystal\" ) ] def redirect_to_crystal : ART :: RedirectResponse ART :: RedirectResponse . new \"https://crystal-lang.org\" end end ART . run # GET /go_to_crystal # => (redirected to https://crystal-lang.org)","title":"RedirectResponse"},{"location":"Routing/RedirectResponse/#class-methods","text":"","title":"Class methods"},{"location":"Routing/RedirectResponse/#Athena::Routing::RedirectResponse.new(url,status,headers)","text":"Creates a response that should redirect to the provided url with the provided status , defaults to 302. An ArgumentError is raised if url is blank, or if status is not a valid redirection status code.","title":".new"},{"location":"Routing/RedirectResponse/#methods","text":"","title":"Methods"},{"location":"Routing/RedirectResponse/#Athena::Routing::RedirectResponse#url()","text":"The url that the request will be redirected to.","title":"#url"},{"location":"Routing/RequestMatcherInterface/","text":"module Athena::Routing::RequestMatcherInterface Direct including types Athena::Routing::RouterInterface Methods abstract #match ( request : HTTP::Request ) : Amber :: Router :: RoutedResult ( Athena::Routing::ActionBase ) Matches the provided request with its related ART::Action .","title":"RequestMatcherInterface"},{"location":"Routing/RequestMatcherInterface/#Athena::Routing::RequestMatcherInterface","text":"","title":"RequestMatcherInterface"},{"location":"Routing/RequestMatcherInterface/#direct-including-types","text":"Athena::Routing::RouterInterface","title":"Direct including types"},{"location":"Routing/RequestMatcherInterface/#methods","text":"","title":"Methods"},{"location":"Routing/RequestMatcherInterface/#Athena::Routing::RequestMatcherInterface#match(request)","text":"Matches the provided request with its related ART::Action .","title":"#match"},{"location":"Routing/RequestParam/","text":"annotation Athena::Routing::RequestParam Represents a form data request parameter. See ART::QueryParam for configuration options/arguments. NOTE: The entire request body is consumed to parse the form data. class ExampleController < ART :: Controller @[ ART :: Post ( path : \"/login\" ) ] @[ ART :: RequestParam ( \"username\" ) ] @[ ART :: RequestParam ( \"password\" ) ] def login ( username : String , password : String ) : Nil # ... end end ART . run # POST /login, body: \"username=George&password=abc123\"","title":"RequestParam"},{"location":"Routing/RequestParam/#Athena::Routing::RequestParam","text":"Represents a form data request parameter. See ART::QueryParam for configuration options/arguments. NOTE: The entire request body is consumed to parse the form data. class ExampleController < ART :: Controller @[ ART :: Post ( path : \"/login\" ) ] @[ ART :: RequestParam ( \"username\" ) ] @[ ART :: RequestParam ( \"password\" ) ] def login ( username : String , password : String ) : Nil # ... end end ART . run # POST /login, body: \"username=George&password=abc123\"","title":"RequestParam"},{"location":"Routing/RequestStore/","text":"class Athena::Routing::RequestStore inherits Reference Stores the current HTTP::Request object. Can be injected to access the request from a non controller context. require \"athena\" @[ ADI :: Register ( public : true ) ] class ExampleController < ART :: Controller def initialize ( @request_store : ART :: RequestStore ); end get \"/\" do @request_store . method end end ART . run # GET / # => GET Methods #request : HTTP::Request #request= ( request : HTTP::Request ) #request? : HTTP::Request?","title":"RequestStore"},{"location":"Routing/RequestStore/#Athena::Routing::RequestStore","text":"Stores the current HTTP::Request object. Can be injected to access the request from a non controller context. require \"athena\" @[ ADI :: Register ( public : true ) ] class ExampleController < ART :: Controller def initialize ( @request_store : ART :: RequestStore ); end get \"/\" do @request_store . method end end ART . run # GET / # => GET","title":"RequestStore"},{"location":"Routing/RequestStore/#methods","text":"","title":"Methods"},{"location":"Routing/RequestStore/#Athena::Routing::RequestStore#request()","text":"","title":"#request"},{"location":"Routing/RequestStore/#Athena::Routing::RequestStore#request=(request)","text":"","title":"#request="},{"location":"Routing/RequestStore/#Athena::Routing::RequestStore#request?()","text":"","title":"#request?"},{"location":"Routing/Response/","text":"class Athena::Routing::Response inherits Reference Represents an HTTP response that should be returned to the client. Contains the content, status, and headers that should be applied to the actual HTTP::Server::Response . This type is used to allow the content, status, and headers to be mutated by ART::Listeners before being returned to the client. The #content is written all at once to the server response's IO . Direct known subclasses Athena::Routing::RedirectResponse Athena::Routing::StreamedResponse Class methods .new ( status : HTTP :: Status | Int32 = HTTP :: Status :: OK , headers : HTTP :: Headers = HTTP :: Headers . new , & block : IO -> Nil ) : ART::StreamedResponse .new ( content : String ? = nil , status : HTTP :: Status | Int32 = HTTP :: Status :: OK , headers : HTTP :: Headers = HTTP :: Headers . new ) Creates a new response with optional content , status , and headers arguments. Methods #content : String Returns the contents of this response. #content= ( content : String ?) Sets the response content. #headers : HTTP :: Headers Returns the response headers of this response. #status : HTTP :: Status Returns the HTTP::Status of this response. #status= ( code : HTTP :: Status | Int32 ) : Nil Sets the status of this response. #write ( output : IO ) : Nil Writes the #content to the provided output . How the output gets written can be customized via an ART::Response::Writer . #writer= ( writer : ART::Response::Writer ) See ART::Response::Writer .","title":"Response"},{"location":"Routing/Response/#Athena::Routing::Response","text":"Represents an HTTP response that should be returned to the client. Contains the content, status, and headers that should be applied to the actual HTTP::Server::Response . This type is used to allow the content, status, and headers to be mutated by ART::Listeners before being returned to the client. The #content is written all at once to the server response's IO .","title":"Response"},{"location":"Routing/Response/#direct-known-subclasses","text":"Athena::Routing::RedirectResponse Athena::Routing::StreamedResponse","title":"Direct known subclasses"},{"location":"Routing/Response/#class-methods","text":"","title":"Class methods"},{"location":"Routing/Response/#Athena::Routing::Response.new(status,headers,&)","text":"","title":".new"},{"location":"Routing/Response/#methods","text":"","title":"Methods"},{"location":"Routing/Response/#Athena::Routing::Response#content()","text":"Returns the contents of this response.","title":"#content"},{"location":"Routing/Response/#Athena::Routing::Response#content=(content)","text":"Sets the response content.","title":"#content="},{"location":"Routing/Response/#Athena::Routing::Response#headers()","text":"Returns the response headers of this response.","title":"#headers"},{"location":"Routing/Response/#Athena::Routing::Response#status()","text":"Returns the HTTP::Status of this response.","title":"#status"},{"location":"Routing/Response/#Athena::Routing::Response#status=(code)","text":"Sets the status of this response.","title":"#status="},{"location":"Routing/Response/#Athena::Routing::Response#write(output)","text":"Writes the #content to the provided output . How the output gets written can be customized via an ART::Response::Writer .","title":"#write"},{"location":"Routing/Response/#Athena::Routing::Response#writer=(writer)","text":"See ART::Response::Writer .","title":"#writer="},{"location":"Routing/Response/DirectWriter/","text":"struct Athena::Routing::Response::DirectWriter inherits Athena::Routing::Response::Writer The default ART::Response::Writer for an ART::Response . Writes directly to the output IO . Methods #write ( output : IO , & : IO -> Nil ) : Nil Accepts an output IO that the content of the response should be written to. The output IO is yielded directly.","title":"DirectWriter"},{"location":"Routing/Response/DirectWriter/#Athena::Routing::Response::DirectWriter","text":"The default ART::Response::Writer for an ART::Response . Writes directly to the output IO .","title":"DirectWriter"},{"location":"Routing/Response/DirectWriter/#methods","text":"","title":"Methods"},{"location":"Routing/Response/DirectWriter/#Athena::Routing::Response::DirectWriter#write(output,&)","text":"Accepts an output IO that the content of the response should be written to. The output IO is yielded directly.","title":"#write"},{"location":"Routing/Response/Writer/","text":"abstract struct Athena::Routing::Response::Writer inherits Struct Determines how the content of an ART::Response will be written to the requests' response IO . By default the content is written directly to the requests' response IO via ART::Response::DirectWriter . However, custom writers can be implemented to customize that behavior. The most common use case would be for compression. Writers can also be defined as services and injected into a listener if they require additional external dependencies. Example require \"athena\" require \"compress/gzip\" # Define a custom writer to gzip the response struct GzipWriter < ART :: Response :: Writer def write ( output : IO , & : IO -> Nil ) : Nil Compress :: Gzip :: Writer . open ( output ) do | gzip_io | yield gzip_io end end end # Define a new event listener to handle applying this writer @[ ADI :: Register ] struct CompressionListener include AED :: EventListenerInterface def self . subscribed_events : AED :: SubscribedEvents AED :: SubscribedEvents { ART :: Events :: Response => - 256 , # Listen on the Response event with a very low priority } end def call ( event : ART :: Events :: Response , dispatcher : AED :: EventDispatcherInterface ) : Nil # If the request supports gzip encoding if event . request . headers . includes_word? ( \"accept-encoding\" , \"gzip\" ) # Change the `ART::Response` object's writer to be our `GzipWriter` event . response . writer = GzipWriter . new # Set the encoding of the response to gzip event . response . headers [ \"content-encoding\" ] = \"gzip\" end end end class ExampleController < ART :: Controller @[ ART :: Get ( \"/users\" ) ] def users : Array ( User ) User . all end end ART . run # GET /users # => [{\"id\":1,...},...] (gzipped) Direct known subclasses Athena::Routing::Response::DirectWriter Class methods .new Methods abstract #write ( output : IO , & : IO -> Nil ) : Nil Accepts an output IO that the content of the response should be written to.","title":"Writer"},{"location":"Routing/Response/Writer/#Athena::Routing::Response::Writer","text":"Determines how the content of an ART::Response will be written to the requests' response IO . By default the content is written directly to the requests' response IO via ART::Response::DirectWriter . However, custom writers can be implemented to customize that behavior. The most common use case would be for compression. Writers can also be defined as services and injected into a listener if they require additional external dependencies.","title":"Writer"},{"location":"Routing/Response/Writer/#Athena::Routing::Response::Writer--example","text":"require \"athena\" require \"compress/gzip\" # Define a custom writer to gzip the response struct GzipWriter < ART :: Response :: Writer def write ( output : IO , & : IO -> Nil ) : Nil Compress :: Gzip :: Writer . open ( output ) do | gzip_io | yield gzip_io end end end # Define a new event listener to handle applying this writer @[ ADI :: Register ] struct CompressionListener include AED :: EventListenerInterface def self . subscribed_events : AED :: SubscribedEvents AED :: SubscribedEvents { ART :: Events :: Response => - 256 , # Listen on the Response event with a very low priority } end def call ( event : ART :: Events :: Response , dispatcher : AED :: EventDispatcherInterface ) : Nil # If the request supports gzip encoding if event . request . headers . includes_word? ( \"accept-encoding\" , \"gzip\" ) # Change the `ART::Response` object's writer to be our `GzipWriter` event . response . writer = GzipWriter . new # Set the encoding of the response to gzip event . response . headers [ \"content-encoding\" ] = \"gzip\" end end end class ExampleController < ART :: Controller @[ ART :: Get ( \"/users\" ) ] def users : Array ( User ) User . all end end ART . run # GET /users # => [{\"id\":1,...},...] (gzipped)","title":"Example"},{"location":"Routing/Response/Writer/#direct-known-subclasses","text":"Athena::Routing::Response::DirectWriter","title":"Direct known subclasses"},{"location":"Routing/Response/Writer/#class-methods","text":"","title":"Class methods"},{"location":"Routing/Response/Writer/#Athena::Routing::Response::Writer.new()","text":"","title":".new"},{"location":"Routing/Response/Writer/#methods","text":"","title":"Methods"},{"location":"Routing/Response/Writer/#Athena::Routing::Response::Writer#write(output,&)","text":"Accepts an output IO that the content of the response should be written to.","title":"#write"},{"location":"Routing/Route/","text":"annotation Athena::Routing::Route Defines an endpoint with an arbitrary HTTP method. Can be used for defining non-standard HTTP method routes. Fields path : String - The path for the endpoint, may also be provided as the first positional argument. name : String - The name of the route. Defaults to controller name + method name down snake-cased. method : String - The HTTP method to use for the endpoint. constraints : Hash(String, Regex) - A mapping between a route's path parameters and its constraints. Example @[ ART :: Route ( \"/some/path\" , method : \"TRACE\" ) ] def trace_route : Nil end","title":"Route"},{"location":"Routing/Route/#Athena::Routing::Route","text":"Defines an endpoint with an arbitrary HTTP method. Can be used for defining non-standard HTTP method routes.","title":"Route"},{"location":"Routing/Route/#Athena::Routing::Route--fields","text":"path : String - The path for the endpoint, may also be provided as the first positional argument. name : String - The name of the route. Defaults to controller name + method name down snake-cased. method : String - The HTTP method to use for the endpoint. constraints : Hash(String, Regex) - A mapping between a route's path parameters and its constraints.","title":"Fields"},{"location":"Routing/Route/#Athena::Routing::Route--example","text":"@[ ART :: Route ( \"/some/path\" , method : \"TRACE\" ) ] def trace_route : Nil end","title":"Example"},{"location":"Routing/RouteCollection/","text":"class Athena::Routing::RouteCollection inherits Reference Wrapper around all the registered routes of an application. Routes are cached as a class variables since they're immutable once the program has been built. Included modules Enumerable Iterable Direct known subclasses Athena::Routing::Spec::MockRouteCollection Methods #each ( & ) : Nil Yields the name and ART::Action object for each registered route. #each Returns an Iterator for each registered route. #get ( name : String ) : ART::ActionBase Returns the ART::Action with the provided name . Raises a KeyError if a route with the provided name does not exist. #get? ( name : String ) : ART::ActionBase? Returns the ART::Action with the provided name , or nil if it does not exist. #routes : Hash ( String , ART::ActionBase ) Returns the routes hash.","title":"RouteCollection"},{"location":"Routing/RouteCollection/#Athena::Routing::RouteCollection","text":"Wrapper around all the registered routes of an application. Routes are cached as a class variables since they're immutable once the program has been built.","title":"RouteCollection"},{"location":"Routing/RouteCollection/#included-modules","text":"Enumerable Iterable","title":"Included modules"},{"location":"Routing/RouteCollection/#direct-known-subclasses","text":"Athena::Routing::Spec::MockRouteCollection","title":"Direct known subclasses"},{"location":"Routing/RouteCollection/#methods","text":"","title":"Methods"},{"location":"Routing/RouteCollection/#Athena::Routing::RouteCollection#each()","text":"Yields the name and ART::Action object for each registered route.","title":"#each"},{"location":"Routing/RouteCollection/#Athena::Routing::RouteCollection#each()","text":"Returns an Iterator for each registered route.","title":"#each"},{"location":"Routing/RouteCollection/#Athena::Routing::RouteCollection#get(name)","text":"Returns the ART::Action with the provided name . Raises a KeyError if a route with the provided name does not exist.","title":"#get"},{"location":"Routing/RouteCollection/#Athena::Routing::RouteCollection#get?(name)","text":"Returns the ART::Action with the provided name , or nil if it does not exist.","title":"#get?"},{"location":"Routing/RouteCollection/#Athena::Routing::RouteCollection#routes()","text":"Returns the routes hash.","title":"#routes"},{"location":"Routing/RouteHandler/","text":"struct Athena::Routing::RouteHandler inherits Struct The entry-point into Athena::Routing . Emits events that handle a given request. Class methods .new ( event_dispatcher : AED::EventDispatcherInterface , request_store : ART::RequestStore , argument_resolver : ART::Arguments::ArgumentResolverInterface ) Methods #handle ( context : HTTP :: Server :: Context ) : Nil","title":"RouteHandler"},{"location":"Routing/RouteHandler/#Athena::Routing::RouteHandler","text":"The entry-point into Athena::Routing . Emits events that handle a given request.","title":"RouteHandler"},{"location":"Routing/RouteHandler/#class-methods","text":"","title":"Class methods"},{"location":"Routing/RouteHandler/#Athena::Routing::RouteHandler.new(event_dispatcher,request_store,argument_resolver)","text":"","title":".new"},{"location":"Routing/RouteHandler/#methods","text":"","title":"Methods"},{"location":"Routing/RouteHandler/#Athena::Routing::RouteHandler#handle(context)","text":"","title":"#handle"},{"location":"Routing/Router/","text":"class Athena::Routing::Router inherits Reference Default implementation of ART::RouterInterface . Included modules Athena::Routing::RouterInterface Class methods .new ( request_store : ART::RequestStore ) Methods #generate ( route : String , params : Hash ( String , _ )? = nil , reference_type : ART::URLGeneratorInterface::ReferenceType = :absolute_path ) : String Generates a URL to the provided route with the provided params . By default the path is an ART::URLGeneratorInterface::ReferenceType::Absolute_Path , but can be changed via the reference_type argument. Any params not related to an argument for the provided route will be added as query params. require \"athena\" class ExampleController < ART :: Controller @[ ART :: Get ( \"/add/:value1/:value2\" , name : \"add\" ) ] def add ( value1 : Int32 , value2 : Int32 , negative : Bool = false ) : Int32 0 end @[ ART :: Get ( \"/\" ) ] def get_link : String \"\" end end generator . generate \"add\" , value1 : 10 , value2 : 5 # => /add/10/5 #match ( request : HTTP::Request ) : Amber :: Router :: RoutedResult ( Athena::Routing::ActionBase ) Matches the provided request with its related ART::Action . OPTIMIZE: Possibly raise a non ART::Exceptions::HTTPException here to allow caller to determine what to do. #route_collection : ART::RouteCollection Returns the ART::RouteCollection associated with this router.","title":"Router"},{"location":"Routing/Router/#Athena::Routing::Router","text":"Default implementation of ART::RouterInterface .","title":"Router"},{"location":"Routing/Router/#included-modules","text":"Athena::Routing::RouterInterface","title":"Included modules"},{"location":"Routing/Router/#class-methods","text":"","title":"Class methods"},{"location":"Routing/Router/#Athena::Routing::Router.new(request_store)","text":"","title":".new"},{"location":"Routing/Router/#methods","text":"","title":"Methods"},{"location":"Routing/Router/#Athena::Routing::Router#generate(route,params,reference_type)","text":"Generates a URL to the provided route with the provided params . By default the path is an ART::URLGeneratorInterface::ReferenceType::Absolute_Path , but can be changed via the reference_type argument. Any params not related to an argument for the provided route will be added as query params. require \"athena\" class ExampleController < ART :: Controller @[ ART :: Get ( \"/add/:value1/:value2\" , name : \"add\" ) ] def add ( value1 : Int32 , value2 : Int32 , negative : Bool = false ) : Int32 0 end @[ ART :: Get ( \"/\" ) ] def get_link : String \"\" end end generator . generate \"add\" , value1 : 10 , value2 : 5 # => /add/10/5","title":"#generate"},{"location":"Routing/Router/#Athena::Routing::Router#match(request)","text":"Matches the provided request with its related ART::Action . OPTIMIZE: Possibly raise a non ART::Exceptions::HTTPException here to allow caller to determine what to do.","title":"#match"},{"location":"Routing/Router/#Athena::Routing::Router#route_collection()","text":"Returns the ART::RouteCollection associated with this router.","title":"#route_collection"},{"location":"Routing/RouterInterface/","text":"module Athena::Routing::RouterInterface Interface for routing types. A router instance must also implement both ART::RequestMatcherInterface and ART:URLGeneratorInterface as well as expose the routes via an #route_collection` method. Included modules Athena::Routing::RequestMatcherInterface Athena::Routing::URLGeneratorInterface Direct including types Athena::Routing::Router Methods abstract #route_collection : ART::RouteCollection Returns the ART::RouteCollection associated with this router.","title":"RouterInterface"},{"location":"Routing/RouterInterface/#Athena::Routing::RouterInterface","text":"Interface for routing types. A router instance must also implement both ART::RequestMatcherInterface and ART:URLGeneratorInterface as well as expose the routes via an #route_collection` method.","title":"RouterInterface"},{"location":"Routing/RouterInterface/#included-modules","text":"Athena::Routing::RequestMatcherInterface Athena::Routing::URLGeneratorInterface","title":"Included modules"},{"location":"Routing/RouterInterface/#direct-including-types","text":"Athena::Routing::Router","title":"Direct including types"},{"location":"Routing/RouterInterface/#methods","text":"","title":"Methods"},{"location":"Routing/RouterInterface/#Athena::Routing::RouterInterface#route_collection()","text":"Returns the ART::RouteCollection associated with this router.","title":"#route_collection"},{"location":"Routing/Spec/","text":"module Athena::Routing::Spec A set of testing utilities/types to aid in testing Athena::Routing related types. Getting Started Require this module in your spec_helper.cr file. # This also requires \"spec\" and \"athena-spec\". require \"athena/spec\" Add Athena::Spec as a development dependency, then run a shards install . See the individual types for more information.","title":"Spec"},{"location":"Routing/Spec/#Athena::Routing::Spec","text":"A set of testing utilities/types to aid in testing Athena::Routing related types.","title":"Spec"},{"location":"Routing/Spec/#Athena::Routing::Spec--getting-started","text":"Require this module in your spec_helper.cr file. # This also requires \"spec\" and \"athena-spec\". require \"athena/spec\" Add Athena::Spec as a development dependency, then run a shards install . See the individual types for more information.","title":"Getting Started"},{"location":"Routing/Spec/APITestCase/","text":"abstract struct Athena::Routing::Spec::APITestCase inherits Athena::Routing::Spec::WebTestCase A WebTestCase implementation with the intent of testing API controllers. Can be extended to add additional application specific configuration, such as setting up an authenticated user to make the request as. Usage Say we want to test the following controller: class ExampleController < ART :: Controller @[ ART :: QueryParam ( \"negative\" ) ] @[ ART :: Get ( \"/add/:value1/:value2\" ) ] def add ( value1 : Int32 , value2 : Int32 , negative : Bool = false ) : Int32 sum = value1 + value2 negative ? - sum : sum end end We can define a struct inheriting from self to implement our test logic: struct ExampleControllerTest < ART :: Spec :: APITestCase def test_add_positive : Nil self . request ( \"GET\" , \"/add/5/3\" ) . body . should eq \"8\" end def test_add_negative : Nil self . request ( \"GET\" , \"/add/5/3?negative=true\" ) . body . should eq \"-8\" end end The #request method is used to make our requests to the API, then we run are assertions against the resulting HTTP::Server::Response . A key thing to point out is that there is no HTTP::Server involved, thus resulting in more performant specs. NOTE: Be sure to call Athena::Spec.run_all to your spec_helper.cr to ensure all test case instances are executed. Mocking External Dependencies The previous example was quite simple. However, most likely a controller is going to have dependencies on various other services; such as an API client to make requests to a third party API. By default each test will be executed with the same services as it would normally, i.e. those requests to the third party API would actually be made. To solve this we can create a mock implementation of the API client and make it so that implementation is injected when the test runs. # Create an example API client. @[ ADI :: Register ] class APIClient def fetch_latest_data : String # Assume this method actually makes an HTTP request to get the latest data. \"DATA\" end end # Define a mock implementation of our APIClient that does not make a request and just returns mock data. class MockAPIClient < APIClient def fetch_latest_data : String # This could also be an instance variable that gets set when this mock is created. \"MOCK_DATA\" end end # Enable our API client to be replaced in the service container. class ADI::Spec:: MockableServiceContainer # Use the block version of the `property` macro to use our mocked client by default, while still allowing it to be replaced at runtime. # # The block version of `getter` could also be used if you don't need to set it at runtime. # The `setter` macro could be also if you only want to allow replacing it at runtime. property ( api_client ) { MockAPIClient . new } end @[ ADI :: Register ( public : true ) ] class ExampleServiceController < ART :: Controller def initialize ( @api_client : APIClient ); end @[ ART :: Post ( \"/sync\" ) ] def sync_data : String # Use the injected api client to get the latest data to sync. data = @api_client . fetch_latest_data # ... data end end struct ExampleServiceControllerTest < ART :: Spec :: APITestCase def initialize super # Our API client could also have been replaced at runtime; # such as if you wanted provide it what data it should return on a test by test basis. # self.client.container.api_client = MockAPIClient.new end def test_sync_data : Nil self . request ( \"POST\" , \"/sync\" ) . body . should eq %(\"MOCK_DATA\") end end NOTE: See ADI::Spec::MockableServiceContainer for more details on mocking services. Each test_* method has its own service container instance. Any services that are mutated/replaced within the initialize method will affect all test_* methods. However, services can also be mutated/replaced within specific test_* methods to scope it that particular test; just be sure that you do it before calling #request . Class methods .new Methods #client : AbstractBrowser Returns a reference to the AbstractBrowser being used for the test. #request ( method : String , path : String , body : String | Bytes | IO | Nil = nil , headers : HTTP :: Headers = HTTP :: Headers . new ) : HTTP :: Server :: Response See AbstractBrowser#request .","title":"APITestCase"},{"location":"Routing/Spec/APITestCase/#Athena::Routing::Spec::APITestCase","text":"A WebTestCase implementation with the intent of testing API controllers. Can be extended to add additional application specific configuration, such as setting up an authenticated user to make the request as.","title":"APITestCase"},{"location":"Routing/Spec/APITestCase/#Athena::Routing::Spec::APITestCase--usage","text":"Say we want to test the following controller: class ExampleController < ART :: Controller @[ ART :: QueryParam ( \"negative\" ) ] @[ ART :: Get ( \"/add/:value1/:value2\" ) ] def add ( value1 : Int32 , value2 : Int32 , negative : Bool = false ) : Int32 sum = value1 + value2 negative ? - sum : sum end end We can define a struct inheriting from self to implement our test logic: struct ExampleControllerTest < ART :: Spec :: APITestCase def test_add_positive : Nil self . request ( \"GET\" , \"/add/5/3\" ) . body . should eq \"8\" end def test_add_negative : Nil self . request ( \"GET\" , \"/add/5/3?negative=true\" ) . body . should eq \"-8\" end end The #request method is used to make our requests to the API, then we run are assertions against the resulting HTTP::Server::Response . A key thing to point out is that there is no HTTP::Server involved, thus resulting in more performant specs. NOTE: Be sure to call Athena::Spec.run_all to your spec_helper.cr to ensure all test case instances are executed.","title":"Usage"},{"location":"Routing/Spec/APITestCase/#Athena::Routing::Spec::APITestCase--mocking-external-dependencies","text":"The previous example was quite simple. However, most likely a controller is going to have dependencies on various other services; such as an API client to make requests to a third party API. By default each test will be executed with the same services as it would normally, i.e. those requests to the third party API would actually be made. To solve this we can create a mock implementation of the API client and make it so that implementation is injected when the test runs. # Create an example API client. @[ ADI :: Register ] class APIClient def fetch_latest_data : String # Assume this method actually makes an HTTP request to get the latest data. \"DATA\" end end # Define a mock implementation of our APIClient that does not make a request and just returns mock data. class MockAPIClient < APIClient def fetch_latest_data : String # This could also be an instance variable that gets set when this mock is created. \"MOCK_DATA\" end end # Enable our API client to be replaced in the service container. class ADI::Spec:: MockableServiceContainer # Use the block version of the `property` macro to use our mocked client by default, while still allowing it to be replaced at runtime. # # The block version of `getter` could also be used if you don't need to set it at runtime. # The `setter` macro could be also if you only want to allow replacing it at runtime. property ( api_client ) { MockAPIClient . new } end @[ ADI :: Register ( public : true ) ] class ExampleServiceController < ART :: Controller def initialize ( @api_client : APIClient ); end @[ ART :: Post ( \"/sync\" ) ] def sync_data : String # Use the injected api client to get the latest data to sync. data = @api_client . fetch_latest_data # ... data end end struct ExampleServiceControllerTest < ART :: Spec :: APITestCase def initialize super # Our API client could also have been replaced at runtime; # such as if you wanted provide it what data it should return on a test by test basis. # self.client.container.api_client = MockAPIClient.new end def test_sync_data : Nil self . request ( \"POST\" , \"/sync\" ) . body . should eq %(\"MOCK_DATA\") end end NOTE: See ADI::Spec::MockableServiceContainer for more details on mocking services. Each test_* method has its own service container instance. Any services that are mutated/replaced within the initialize method will affect all test_* methods. However, services can also be mutated/replaced within specific test_* methods to scope it that particular test; just be sure that you do it before calling #request .","title":"Mocking External Dependencies"},{"location":"Routing/Spec/APITestCase/#class-methods","text":"","title":"Class methods"},{"location":"Routing/Spec/APITestCase/#Athena::Routing::Spec::APITestCase.new()","text":"","title":".new"},{"location":"Routing/Spec/APITestCase/#methods","text":"","title":"Methods"},{"location":"Routing/Spec/APITestCase/#Athena::Routing::Spec::APITestCase#client()","text":"Returns a reference to the AbstractBrowser being used for the test.","title":"#client"},{"location":"Routing/Spec/APITestCase/#Athena::Routing::Spec::APITestCase#request(method,path,body,headers)","text":"See AbstractBrowser#request .","title":"#request"},{"location":"Routing/Spec/AbstractBrowser/","text":"abstract struct Athena::Routing::Spec::AbstractBrowser inherits Struct Simulates a browser to make requests to some destination. NOTE: Currently just acts as a client to make HTTP requests. This type exists to allow for introduction of other functionality in the future. Direct known subclasses Athena::Routing::Spec::HTTPBrowser Class methods .new Methods #request ( method : String , path : String , headers : HTTP :: Headers , body : String | Bytes | IO | Nil ) : HTTP :: Server :: Response Makes an HTTP request with the provided method , at the provided path , with the provided body and/or headers and returns the resulting response.","title":"AbstractBrowser"},{"location":"Routing/Spec/AbstractBrowser/#Athena::Routing::Spec::AbstractBrowser","text":"Simulates a browser to make requests to some destination. NOTE: Currently just acts as a client to make HTTP requests. This type exists to allow for introduction of other functionality in the future.","title":"AbstractBrowser"},{"location":"Routing/Spec/AbstractBrowser/#direct-known-subclasses","text":"Athena::Routing::Spec::HTTPBrowser","title":"Direct known subclasses"},{"location":"Routing/Spec/AbstractBrowser/#class-methods","text":"","title":"Class methods"},{"location":"Routing/Spec/AbstractBrowser/#Athena::Routing::Spec::AbstractBrowser.new()","text":"","title":".new"},{"location":"Routing/Spec/AbstractBrowser/#methods","text":"","title":"Methods"},{"location":"Routing/Spec/AbstractBrowser/#Athena::Routing::Spec::AbstractBrowser#request(method,path,headers,body)","text":"Makes an HTTP request with the provided method , at the provided path , with the provided body and/or headers and returns the resulting response.","title":"#request"},{"location":"Routing/Spec/HTTPBrowser/","text":"struct Athena::Routing::Spec::HTTPBrowser inherits Athena::Routing::Spec::AbstractBrowser Simulates a browser and makes a requests to ART::RouteHandler . Methods #container : ADI::Spec::MockableServiceContainer Returns a reference to an ADI::Spec::MockableServiceContainer to allow configuring the container before a test.","title":"HTTPBrowser"},{"location":"Routing/Spec/HTTPBrowser/#Athena::Routing::Spec::HTTPBrowser","text":"Simulates a browser and makes a requests to ART::RouteHandler .","title":"HTTPBrowser"},{"location":"Routing/Spec/HTTPBrowser/#methods","text":"","title":"Methods"},{"location":"Routing/Spec/HTTPBrowser/#Athena::Routing::Spec::HTTPBrowser#container()","text":"Returns a reference to an ADI::Spec::MockableServiceContainer to allow configuring the container before a test.","title":"#container"},{"location":"Routing/Spec/MockRouteCollection/","text":"class Athena::Routing::Spec::MockRouteCollection inherits Athena::Routing::RouteCollection Test implementation of ART::RouteCollection that allows routes to be scoped to a specific instance and added manually. Methods #add ( name : String , route : ART::ActionBase ) : Nil #add ( route : ART::ActionBase ) : Nil #routes : Hash ( String , ART::ActionBase ) Returns the routes hash.","title":"MockRouteCollection"},{"location":"Routing/Spec/MockRouteCollection/#Athena::Routing::Spec::MockRouteCollection","text":"Test implementation of ART::RouteCollection that allows routes to be scoped to a specific instance and added manually.","title":"MockRouteCollection"},{"location":"Routing/Spec/MockRouteCollection/#methods","text":"","title":"Methods"},{"location":"Routing/Spec/MockRouteCollection/#Athena::Routing::Spec::MockRouteCollection#add(name,route)","text":"","title":"#add"},{"location":"Routing/Spec/MockRouteCollection/#Athena::Routing::Spec::MockRouteCollection#routes()","text":"Returns the routes hash.","title":"#routes"},{"location":"Routing/Spec/WebTestCase/","text":"abstract struct Athena::Routing::Spec::WebTestCase inherits Athena::Spec::TestCase Base ASPEC::TestCase for web based integration tests. NOTE: Currently only API based tests are supported. This type exists to allow for introduction of other types in the future. Direct known subclasses Athena::Routing::Spec::APITestCase Methods #create_client : AbstractBrowser Returns the AbstractBrowser instance to which requests should be made against.","title":"WebTestCase"},{"location":"Routing/Spec/WebTestCase/#Athena::Routing::Spec::WebTestCase","text":"Base ASPEC::TestCase for web based integration tests. NOTE: Currently only API based tests are supported. This type exists to allow for introduction of other types in the future.","title":"WebTestCase"},{"location":"Routing/Spec/WebTestCase/#direct-known-subclasses","text":"Athena::Routing::Spec::APITestCase","title":"Direct known subclasses"},{"location":"Routing/Spec/WebTestCase/#methods","text":"","title":"Methods"},{"location":"Routing/Spec/WebTestCase/#Athena::Routing::Spec::WebTestCase#create_client()","text":"Returns the AbstractBrowser instance to which requests should be made against.","title":"#create_client"},{"location":"Routing/StreamedResponse/","text":"class Athena::Routing::StreamedResponse inherits Athena::Routing::Response Represents an ART::Response whose content should be streamed to the client as opposed to being written all at once. This can be useful in cases where the response content is too large to fit into memory. The content is stored in a proc that gets called when self is being written to the response IO. How the output gets written can be customized via an ART::Response::Writer . Class methods .new ( status : HTTP :: Status | Int32 = HTTP :: Status :: OK , headers : HTTP :: Headers = HTTP :: Headers . new , & block : IO -> Nil ) Creates a new response with optional status , and headers arguments. The block is captured and called when self is being written to the response's IO . This can be useful to reduce memory overhead when needing to return large responses. require \"athena\" class ExampleController < ART :: Controller @[ ART :: Get ( \"/users\" ) ] def users : ART :: Response ART :: StreamedResponse . new headers : HTTP :: Headers { \"content-type\" => \"application/json; charset=UTF-8\" } do | io | User . all . to_json io end end end ART . run # GET /users # => [{\"id\":1,...},...] .new ( callback : Proc ( IO , Nil ), status : HTTP :: Status | Int32 = HTTP :: Status :: OK , headers : HTTP :: Headers = HTTP :: Headers . new ) Creates a new response with the provided callback and optional status , and headers arguments. The proc is called when self is being written to the response's IO . Methods #content= ( callback : Proc ( IO , Nil )) Updates the callback of self . #write ( output : IO ) : Nil Streams the data in the stored Proc to the provided output . How the output gets written can be customized via an ART::Response::Writer .","title":"StreamedResponse"},{"location":"Routing/StreamedResponse/#Athena::Routing::StreamedResponse","text":"Represents an ART::Response whose content should be streamed to the client as opposed to being written all at once. This can be useful in cases where the response content is too large to fit into memory. The content is stored in a proc that gets called when self is being written to the response IO. How the output gets written can be customized via an ART::Response::Writer .","title":"StreamedResponse"},{"location":"Routing/StreamedResponse/#class-methods","text":"","title":"Class methods"},{"location":"Routing/StreamedResponse/#Athena::Routing::StreamedResponse.new(status,headers,&)","text":"Creates a new response with optional status , and headers arguments. The block is captured and called when self is being written to the response's IO . This can be useful to reduce memory overhead when needing to return large responses. require \"athena\" class ExampleController < ART :: Controller @[ ART :: Get ( \"/users\" ) ] def users : ART :: Response ART :: StreamedResponse . new headers : HTTP :: Headers { \"content-type\" => \"application/json; charset=UTF-8\" } do | io | User . all . to_json io end end end ART . run # GET /users # => [{\"id\":1,...},...]","title":".new"},{"location":"Routing/StreamedResponse/#methods","text":"","title":"Methods"},{"location":"Routing/StreamedResponse/#Athena::Routing::StreamedResponse#content=(callback)","text":"Updates the callback of self .","title":"#content="},{"location":"Routing/StreamedResponse/#Athena::Routing::StreamedResponse#write(output)","text":"Streams the data in the stored Proc to the provided output . How the output gets written can be customized via an ART::Response::Writer .","title":"#write"},{"location":"Routing/TimeConverter/","text":"struct Athena::Routing::TimeConverter inherits Athena::Routing::ParamConverterInterface Converts a date(time) string into a Time instance. Optionally allows specifying the format and location to use when parsing the string. If no format is specified, defaults to Time.rfc_3339 . Defaults to UTC if no location is specified with the format. Raises an ART::Exceptions::BadRequest if the date(time) string could not be parsed. NOTE: The format can be anything supported via Time::Format . Example require \"athena\" class ExampleController < ART :: Controller @[ ART :: Get ( path : \"/event/:start_time/:end_time\" ) ] @[ ART :: ParamConverter ( \"start_time\" , converter : ART :: TimeConverter , format : \"%F\" , location : Time :: Location . load ( \"Europe/Berlin\" )) ] @[ ART :: ParamConverter ( \"end_time\" , converter : ART :: TimeConverter ) ] def event ( start_time : Time , end_time : Time ) : Nil start_time # => 2020-04-07 00:00:00.0 +02:00 Europe/Berlin end_time # => 2020-04-08 12:34:56.0 UTC end end ART . run # GET /event/2020-04-07/2020-04-08T12:34:56Z Methods #apply ( request : HTTP::Request , configuration : Configuration ) : Nil Applies the conversion logic based on the provided request and configuration . Most commonly this involves setting/overriding a value stored in the request's ART::ParameterBag via request.attributes .","title":"TimeConverter"},{"location":"Routing/TimeConverter/#Athena::Routing::TimeConverter","text":"Converts a date(time) string into a Time instance. Optionally allows specifying the format and location to use when parsing the string. If no format is specified, defaults to Time.rfc_3339 . Defaults to UTC if no location is specified with the format. Raises an ART::Exceptions::BadRequest if the date(time) string could not be parsed. NOTE: The format can be anything supported via Time::Format .","title":"TimeConverter"},{"location":"Routing/TimeConverter/#Athena::Routing::TimeConverter--example","text":"require \"athena\" class ExampleController < ART :: Controller @[ ART :: Get ( path : \"/event/:start_time/:end_time\" ) ] @[ ART :: ParamConverter ( \"start_time\" , converter : ART :: TimeConverter , format : \"%F\" , location : Time :: Location . load ( \"Europe/Berlin\" )) ] @[ ART :: ParamConverter ( \"end_time\" , converter : ART :: TimeConverter ) ] def event ( start_time : Time , end_time : Time ) : Nil start_time # => 2020-04-07 00:00:00.0 +02:00 Europe/Berlin end_time # => 2020-04-08 12:34:56.0 UTC end end ART . run # GET /event/2020-04-07/2020-04-08T12:34:56Z","title":"Example"},{"location":"Routing/TimeConverter/#methods","text":"","title":"Methods"},{"location":"Routing/TimeConverter/#Athena::Routing::TimeConverter#apply(request,configuration)","text":"Applies the conversion logic based on the provided request and configuration . Most commonly this involves setting/overriding a value stored in the request's ART::ParameterBag via request.attributes .","title":"#apply"},{"location":"Routing/TimeConverter/Configuration/","text":"struct Athena::Routing::TimeConverter::Configuration inherits Athena::Routing::ParamConverterInterface::ConfigurationInterface Class methods .new ( name : String , converter : ART :: ParamConverterInterface . class , format : String ? = nil , location : Time :: Location = Time :: Location :: UTC ) Methods #format : String ? #location : Time :: Location","title":"Configuration"},{"location":"Routing/TimeConverter/Configuration/#Athena::Routing::TimeConverter::Configuration","text":"","title":"Configuration"},{"location":"Routing/TimeConverter/Configuration/#class-methods","text":"","title":"Class methods"},{"location":"Routing/TimeConverter/Configuration/#Athena::Routing::TimeConverter::Configuration.new(name,converter,format,location)","text":"","title":".new"},{"location":"Routing/TimeConverter/Configuration/#methods","text":"","title":"Methods"},{"location":"Routing/TimeConverter/Configuration/#Athena::Routing::TimeConverter::Configuration#format()","text":"","title":"#format"},{"location":"Routing/TimeConverter/Configuration/#Athena::Routing::TimeConverter::Configuration#location()","text":"","title":"#location"},{"location":"Routing/URLGenerator/","text":"class Athena::Routing::URLGenerator inherits Reference Default implementation of ART::URLGeneratorInterface . Included modules Athena::Routing::URLGeneratorInterface Class methods .new ( routes : ART::RouteCollection , request : HTTP::Request ) Methods #generate ( route : String , params : Hash ( String , _ )? = nil , reference_type : ART::URLGeneratorInterface::ReferenceType = :absolute_path ) : String Generates a URL to the provided route with the provided params . By default the path is an ART::URLGeneratorInterface::ReferenceType::Absolute_Path , but can be changed via the reference_type argument. Any params not related to an argument for the provided route will be added as query params. require \"athena\" class ExampleController < ART :: Controller @[ ART :: Get ( \"/add/:value1/:value2\" , name : \"add\" ) ] def add ( value1 : Int32 , value2 : Int32 , negative : Bool = false ) : Int32 0 end @[ ART :: Get ( \"/\" ) ] def get_link : String \"\" end end generator . generate \"add\" , value1 : 10 , value2 : 5 # => /add/10/5 params are validated to ensure they are all provided, and meet any route constraints defined on the action. OPTIMIZE: Make URL generation more robust. ameba:disable Metrics/CyclomaticComplexity","title":"URLGenerator"},{"location":"Routing/URLGenerator/#Athena::Routing::URLGenerator","text":"Default implementation of ART::URLGeneratorInterface .","title":"URLGenerator"},{"location":"Routing/URLGenerator/#included-modules","text":"Athena::Routing::URLGeneratorInterface","title":"Included modules"},{"location":"Routing/URLGenerator/#class-methods","text":"","title":"Class methods"},{"location":"Routing/URLGenerator/#Athena::Routing::URLGenerator.new(routes,request)","text":"","title":".new"},{"location":"Routing/URLGenerator/#methods","text":"","title":"Methods"},{"location":"Routing/URLGenerator/#Athena::Routing::URLGenerator#generate(route,params,reference_type)","text":"Generates a URL to the provided route with the provided params . By default the path is an ART::URLGeneratorInterface::ReferenceType::Absolute_Path , but can be changed via the reference_type argument. Any params not related to an argument for the provided route will be added as query params. require \"athena\" class ExampleController < ART :: Controller @[ ART :: Get ( \"/add/:value1/:value2\" , name : \"add\" ) ] def add ( value1 : Int32 , value2 : Int32 , negative : Bool = false ) : Int32 0 end @[ ART :: Get ( \"/\" ) ] def get_link : String \"\" end end generator . generate \"add\" , value1 : 10 , value2 : 5 # => /add/10/5 params are validated to ensure they are all provided, and meet any route constraints defined on the action. OPTIMIZE: Make URL generation more robust. ameba:disable Metrics/CyclomaticComplexity","title":"#generate"},{"location":"Routing/URLGeneratorInterface/","text":"module Athena::Routing::URLGeneratorInterface Interface for URL generation types. Implementors must define a #generate method that accepts the route name, any params, and what type of URL should be generated and return the URL string. Direct including types Athena::Routing::RouterInterface Athena::Routing::URLGenerator Methods abstract #generate ( route : String , params : Hash ( String , _ )? = nil , reference_type : ART::URLGeneratorInterface::ReferenceType = :absolute_path ) : String Generates a URL to the provided route with the provided params . By default the path is an ART::URLGeneratorInterface::ReferenceType::Absolute_Path , but can be changed via the reference_type argument. Any params not related to an argument for the provided route will be added as query params. require \"athena\" class ExampleController < ART :: Controller @[ ART :: Get ( \"/add/:value1/:value2\" , name : \"add\" ) ] def add ( value1 : Int32 , value2 : Int32 , negative : Bool = false ) : Int32 0 end @[ ART :: Get ( \"/\" ) ] def get_link : String \"\" end end generator . generate \"add\" , value1 : 10 , value2 : 5 # => /add/10/5","title":"URLGeneratorInterface"},{"location":"Routing/URLGeneratorInterface/#Athena::Routing::URLGeneratorInterface","text":"Interface for URL generation types. Implementors must define a #generate method that accepts the route name, any params, and what type of URL should be generated and return the URL string.","title":"URLGeneratorInterface"},{"location":"Routing/URLGeneratorInterface/#direct-including-types","text":"Athena::Routing::RouterInterface Athena::Routing::URLGenerator","title":"Direct including types"},{"location":"Routing/URLGeneratorInterface/#methods","text":"","title":"Methods"},{"location":"Routing/URLGeneratorInterface/#Athena::Routing::URLGeneratorInterface#generate(route,params,reference_type)","text":"Generates a URL to the provided route with the provided params . By default the path is an ART::URLGeneratorInterface::ReferenceType::Absolute_Path , but can be changed via the reference_type argument. Any params not related to an argument for the provided route will be added as query params. require \"athena\" class ExampleController < ART :: Controller @[ ART :: Get ( \"/add/:value1/:value2\" , name : \"add\" ) ] def add ( value1 : Int32 , value2 : Int32 , negative : Bool = false ) : Int32 0 end @[ ART :: Get ( \"/\" ) ] def get_link : String \"\" end end generator . generate \"add\" , value1 : 10 , value2 : 5 # => /add/10/5","title":"#generate"},{"location":"Routing/URLGeneratorInterface/ReferenceType/","text":"enum Athena::Routing::URLGeneratorInterface::ReferenceType Represents the type of URLs that are able to be generated via an ART::URLGeneratorInterface . Members Absolute_URL = 0 Includes an absolute URL including protocol, hostname, and path: https://api.example.com/add/10/5 . NOTE: The generated URL's protocol is always https . Absolute_Path = 1 The default type, includes an absolute path from the root to the generated route: /add/10/5 . Relative_Path = 2 TODO: Implement this. Network_Path = 3 Similar to Absolute_URL , but reuses the current protocol: //api.example.com/add/10/5 . Methods #absolute_path? #absolute_url? #network_path? #relative_path?","title":"ReferenceType"},{"location":"Routing/URLGeneratorInterface/ReferenceType/#Athena::Routing::URLGeneratorInterface::ReferenceType","text":"Represents the type of URLs that are able to be generated via an ART::URLGeneratorInterface .","title":"ReferenceType"},{"location":"Routing/URLGeneratorInterface/ReferenceType/#members","text":"","title":"Members"},{"location":"Routing/URLGeneratorInterface/ReferenceType/#Athena::Routing::URLGeneratorInterface::ReferenceType::Absolute_URL","text":"Includes an absolute URL including protocol, hostname, and path: https://api.example.com/add/10/5 . NOTE: The generated URL's protocol is always https .","title":"Absolute_URL"},{"location":"Routing/URLGeneratorInterface/ReferenceType/#Athena::Routing::URLGeneratorInterface::ReferenceType::Absolute_Path","text":"The default type, includes an absolute path from the root to the generated route: /add/10/5 .","title":"Absolute_Path"},{"location":"Routing/URLGeneratorInterface/ReferenceType/#Athena::Routing::URLGeneratorInterface::ReferenceType::Relative_Path","text":"TODO: Implement this.","title":"Relative_Path"},{"location":"Routing/URLGeneratorInterface/ReferenceType/#Athena::Routing::URLGeneratorInterface::ReferenceType::Network_Path","text":"Similar to Absolute_URL , but reuses the current protocol: //api.example.com/add/10/5 .","title":"Network_Path"},{"location":"Routing/URLGeneratorInterface/ReferenceType/#methods","text":"","title":"Methods"},{"location":"Routing/URLGeneratorInterface/ReferenceType/#Athena::Routing::URLGeneratorInterface::ReferenceType#absolute_path?()","text":"","title":"#absolute_path?"},{"location":"Routing/URLGeneratorInterface/ReferenceType/#Athena::Routing::URLGeneratorInterface::ReferenceType#absolute_url?()","text":"","title":"#absolute_url?"},{"location":"Routing/URLGeneratorInterface/ReferenceType/#Athena::Routing::URLGeneratorInterface::ReferenceType#network_path?()","text":"","title":"#network_path?"},{"location":"Routing/URLGeneratorInterface/ReferenceType/#Athena::Routing::URLGeneratorInterface::ReferenceType#relative_path?()","text":"","title":"#relative_path?"},{"location":"Routing/Unlink/","text":"annotation Athena::Routing::Unlink Defines an UNLINK endpoint. Fields path : String - The path for the endpoint, may also be provided as the first positional argument. name : String - The name of the route. Defaults to controller name + method name down snake-cased. constraints : Hash(String, Regex) - A mapping between a route's path parameters and its constraints. Example @[ ART :: Unlink ( path : \"/users/:id\" ) ] def unlink_user ( id : Int32 ) : Nil end","title":"Unlink"},{"location":"Routing/Unlink/#Athena::Routing::Unlink","text":"Defines an UNLINK endpoint.","title":"Unlink"},{"location":"Routing/Unlink/#Athena::Routing::Unlink--fields","text":"path : String - The path for the endpoint, may also be provided as the first positional argument. name : String - The name of the route. Defaults to controller name + method name down snake-cased. constraints : Hash(String, Regex) - A mapping between a route's path parameters and its constraints.","title":"Fields"},{"location":"Routing/Unlink/#Athena::Routing::Unlink--example","text":"@[ ART :: Unlink ( path : \"/users/:id\" ) ] def unlink_user ( id : Int32 ) : Nil end","title":"Example"},{"location":"Routing/View/","text":"annotation Athena::Routing::View Configures how the endpoint should be rendered. See ART::Action::ViewContext . Fields status : HTTP::Status - The HTTP::Status the endpoint should return. Defaults to HTTP::Status::OK (200). serialization_groups : Array(String)? - The serialization groups to use for this route as part of ASR::ExclusionStrategies::Groups . validation_groups : Array(String)? - Groups that should be used to validate any objects related to this route; see AVD::Constraint@validation-groups . emit_nil : Bool - If nil values should be serialized. Defaults to false . Example @[ ART :: Post ( path : \"/publish/:id\" ) ] @[ ART :: View ( status : :accepted , serialization_groups : [ \"default\" , \"detailed\" ] ) ] def publish ( id : Int32 ) : Article article = Article . find id article . published = true article end See the external documentation for more information.","title":"View"},{"location":"Routing/View/#Athena::Routing::View","text":"Configures how the endpoint should be rendered. See ART::Action::ViewContext .","title":"View"},{"location":"Routing/View/#Athena::Routing::View--fields","text":"status : HTTP::Status - The HTTP::Status the endpoint should return. Defaults to HTTP::Status::OK (200). serialization_groups : Array(String)? - The serialization groups to use for this route as part of ASR::ExclusionStrategies::Groups . validation_groups : Array(String)? - Groups that should be used to validate any objects related to this route; see AVD::Constraint@validation-groups . emit_nil : Bool - If nil values should be serialized. Defaults to false .","title":"Fields"},{"location":"Routing/View/#Athena::Routing::View--example","text":"@[ ART :: Post ( path : \"/publish/:id\" ) ] @[ ART :: View ( status : :accepted , serialization_groups : [ \"default\" , \"detailed\" ] ) ] def publish ( id : Int32 ) : Article article = Article . find id article . published = true article end See the external documentation for more information.","title":"Example"},{"location":"Serializer/","text":"alias ASR Convenience alias to make referencing Athena::Serializer types easier. Alias definition Athena::Serializer module Athena::Serializer Athena's Serializer component, ASR for short, adds enhanced (de)serialization features to your project. Getting Started The serializer component utilizes a module to specify that a type is serializable, as well as annotations to control how it gets (de)serialized. Installation Add the dependency to your shard.yml : dependencies : athena-serializer : github : athena-framework/serializer version : ~> 0.2.0 Run shards install . Usage See the ASR::Annotations namespace a complete list of annotations, as well as each annotation for more detailed information. # ExclusionPolicy specifies that all properties should not be (de)serialized # unless exposed via the `ASRA::Expose` annotation. @[ ASRA :: ExclusionPolicy ( :all ) ] @[ ASRA :: AccessorOrder ( :alphabetical ) ] class Example include ASR :: Serializable # Groups can be used to create different \"views\" of a type. @[ ASRA :: Expose ] @[ ASRA :: Groups ( \"details\" ) ] property name : String # The `ASRA::Name` controls the name that this property # should be deserialized from or be serialized to. # It can also be used to set the default serialized naming strategy on the type. @[ ASRA :: Expose ] @[ ASRA :: Name ( deserialize : \"a_prop\" , serialize : \"a_prop\" ) ] property some_prop : String # Define a custom accessor used to get the value for serialization. @[ ASRA :: Expose ] @[ ASRA :: Groups ( \"default\" , \"details\" ) ] @[ ASRA :: Accessor ( getter : get_title ) ] property title : String # ReadOnly properties cannot be set on deserialization @[ ASRA :: Expose ] @[ ASRA :: ReadOnly ] property created_at : Time = Time . utc # Allows the property to be set via deserialization, # but not exposed when serialized. @[ ASRA :: IgnoreOnSerialize ] property password : String ? # Because of the `:all` exclusion policy, and not having the `ASRA::Expose` annotation, # these properties are not exposed. getter first_name : String ? getter last_name : String ? # Runs directly after `self` is deserialized @[ ASRA :: PostDeserialize ] def split_name : Nil @first_name , @last_name = @name . split ( ' ' ) end # Allows using the return value of a method as a key/value in the serialized output. @[ ASRA :: VirtualProperty ] def get_val : String \"VAL\" end private def get_title : String @title . downcase end end obj = ASR . serializer . deserialize Example , %({\"name\":\"FIRST LAST\",\"a_prop\":\"STR\",\"title\":\"TITLE\",\"password\":\"monkey123\",\"created_at\":\"2020-10-10T12:34:56Z\"}) , :json obj # => #<Example:0x7f3e3b106740 @created_at=2020-07-05 23:06:58.943298289 UTC, @name=\"FIRST LAST\", @some_prop=\"STR\", @title=\"TITLE\", @password=\"monkey123\", @first_name=\"FIRST\", @last_name=\"LAST\"> ASR . serializer . serialize obj , :json # => {\"a_prop\":\"STR\",\"created_at\":\"2020-07-05T23:06:58.94Z\",\"get_val\":\"VAL\",\"name\":\"FIRST LAST\",\"title\":\"title\"} ASR . serializer . serialize obj , :json , ASR :: SerializationContext . new . groups = [ \"details\" ] # => {\"name\":\"FIRST LAST\",\"title\":\"title\"} Class methods .serializer Returns an ASR::SerializerInterface instance for ad-hoc (de)serialization. The serializer is cached and only instantiated once.","title":"Serializer"},{"location":"Serializer/#ASR","text":"Convenience alias to make referencing Athena::Serializer types easier.","title":"ASR"},{"location":"Serializer/#alias-definition","text":"Athena::Serializer","title":"Alias definition"},{"location":"Serializer/#Athena::Serializer","text":"Athena's Serializer component, ASR for short, adds enhanced (de)serialization features to your project.","title":"Serializer"},{"location":"Serializer/#Athena::Serializer--getting-started","text":"The serializer component utilizes a module to specify that a type is serializable, as well as annotations to control how it gets (de)serialized.","title":"Getting Started"},{"location":"Serializer/#Athena::Serializer--installation","text":"Add the dependency to your shard.yml : dependencies : athena-serializer : github : athena-framework/serializer version : ~> 0.2.0 Run shards install .","title":"Installation"},{"location":"Serializer/#Athena::Serializer--usage","text":"See the ASR::Annotations namespace a complete list of annotations, as well as each annotation for more detailed information. # ExclusionPolicy specifies that all properties should not be (de)serialized # unless exposed via the `ASRA::Expose` annotation. @[ ASRA :: ExclusionPolicy ( :all ) ] @[ ASRA :: AccessorOrder ( :alphabetical ) ] class Example include ASR :: Serializable # Groups can be used to create different \"views\" of a type. @[ ASRA :: Expose ] @[ ASRA :: Groups ( \"details\" ) ] property name : String # The `ASRA::Name` controls the name that this property # should be deserialized from or be serialized to. # It can also be used to set the default serialized naming strategy on the type. @[ ASRA :: Expose ] @[ ASRA :: Name ( deserialize : \"a_prop\" , serialize : \"a_prop\" ) ] property some_prop : String # Define a custom accessor used to get the value for serialization. @[ ASRA :: Expose ] @[ ASRA :: Groups ( \"default\" , \"details\" ) ] @[ ASRA :: Accessor ( getter : get_title ) ] property title : String # ReadOnly properties cannot be set on deserialization @[ ASRA :: Expose ] @[ ASRA :: ReadOnly ] property created_at : Time = Time . utc # Allows the property to be set via deserialization, # but not exposed when serialized. @[ ASRA :: IgnoreOnSerialize ] property password : String ? # Because of the `:all` exclusion policy, and not having the `ASRA::Expose` annotation, # these properties are not exposed. getter first_name : String ? getter last_name : String ? # Runs directly after `self` is deserialized @[ ASRA :: PostDeserialize ] def split_name : Nil @first_name , @last_name = @name . split ( ' ' ) end # Allows using the return value of a method as a key/value in the serialized output. @[ ASRA :: VirtualProperty ] def get_val : String \"VAL\" end private def get_title : String @title . downcase end end obj = ASR . serializer . deserialize Example , %({\"name\":\"FIRST LAST\",\"a_prop\":\"STR\",\"title\":\"TITLE\",\"password\":\"monkey123\",\"created_at\":\"2020-10-10T12:34:56Z\"}) , :json obj # => #<Example:0x7f3e3b106740 @created_at=2020-07-05 23:06:58.943298289 UTC, @name=\"FIRST LAST\", @some_prop=\"STR\", @title=\"TITLE\", @password=\"monkey123\", @first_name=\"FIRST\", @last_name=\"LAST\"> ASR . serializer . serialize obj , :json # => {\"a_prop\":\"STR\",\"created_at\":\"2020-07-05T23:06:58.94Z\",\"get_val\":\"VAL\",\"name\":\"FIRST LAST\",\"title\":\"title\"} ASR . serializer . serialize obj , :json , ASR :: SerializationContext . new . groups = [ \"details\" ] # => {\"name\":\"FIRST LAST\",\"title\":\"title\"}","title":"Usage"},{"location":"Serializer/#class-methods","text":"","title":"Class methods"},{"location":"Serializer/#Athena::Serializer.serializer()","text":"Returns an ASR::SerializerInterface instance for ad-hoc (de)serialization. The serializer is cached and only instantiated once.","title":".serializer"},{"location":"Serializer/Annotations/","text":"alias ASRA Convenience alias to make referencing Athena::Serializer::Annotations types easier. Alias definition Athena::Serializer::Annotations module Athena::Serializer::Annotations Athena::Serializer uses annotations to control how an object gets serialized and deserialized. This module includes all the default serialization and deserialization annotations. The ASRA alias can be used as a shorthand when applying the annotations.","title":"Annotations"},{"location":"Serializer/Annotations/#ASRA","text":"Convenience alias to make referencing Athena::Serializer::Annotations types easier.","title":"ASRA"},{"location":"Serializer/Annotations/#alias-definition","text":"Athena::Serializer::Annotations","title":"Alias definition"},{"location":"Serializer/Annotations/#Athena::Serializer::Annotations","text":"Athena::Serializer uses annotations to control how an object gets serialized and deserialized. This module includes all the default serialization and deserialization annotations. The ASRA alias can be used as a shorthand when applying the annotations.","title":"Annotations"},{"location":"Serializer/Annotations/Accessor/","text":"annotation Athena::Serializer::Annotations::Accessor Allows using methods/modules to control how a property is retrieved/set. Fields getter - A method name whose return value will be used as the serialized value. setter - A method name that accepts the deserialized value. Can be used to apply additional logic before setting the properties value. converter - A module that defines a .deserialize method. Can be used to share common deserialization between types. path : Tuple - A set of keys used to navigate to a value during deserialization. The value of the last key will be used as the property's value. Example Getter/Setter class AccessorExample include ASR :: Serializable def initialize ; end @[ ASRA :: Accessor ( getter : get_foo , setter : set_foo ) ] property foo : String = \"foo\" private def set_foo ( foo : String ) : String @foo = foo . upcase end private def get_foo : String @foo . upcase end end ASR . serializer . serialize AccessorExample . new , :json # => {\"foo\":\"FOO\"} ASR . serializer . deserialize AccessorExample , %({\"foo\":\"bar\"}) , :json # => #<AccessorExample:0x7f5915e25c20 @foo=\"BAR\"> Converter module ReverseConverter def self . deserialize ( navigator : ASR :: Navigators :: DeserializationNavigatorInterface , metadata : ASR :: PropertyMetadataBase , data : ASR :: Any ) : String data . as_s . reverse end end class ConverterExample include ASR :: Serializable @[ ASRA :: Accessor ( converter : ReverseConverter ) ] getter str : String end ASR . serializer . deserialize ConverterExample , %({\"str\":\"jim\"}) , :json # => #<ConverterExample:0x7f9745fa6d60 @str=\"mij\"> Path class Example include ASR :: Serializable getter id : Int64 @[ ASRA :: Accessor ( path : { \"stats\" , \"HP\" }) ] getter hp : Int32 @[ ASRA :: Accessor ( path : { \"stats\" , \"Attack\" }) ] getter attack : Int32 @[ ASRA :: Accessor ( path : { \"downs\" , - 1 , \"last_down\" }) ] getter last_down : Time end DATA = <<- JSON { \"id\": 1, \"stats\": { \"HP\": 45, \"Attack\": 49 }, \"downs\": [ { \"id\": 1, \"last_down\": \"2020-05-019T05:23:17Z\" }, { \"id\": 2, \"last_down\": \"2020-04-07T12:34:56Z\" } ] } JSON ASR . serializer . deserialize Example , DATA , :json # #<Example:0x7f43c4ddf580 # @attack=49, # @hp=45, # @id=1, # @last_down=2020-04-07 12:34:56.0 UTC>","title":"Accessor"},{"location":"Serializer/Annotations/Accessor/#Athena::Serializer::Annotations::Accessor","text":"Allows using methods/modules to control how a property is retrieved/set.","title":"Accessor"},{"location":"Serializer/Annotations/Accessor/#Athena::Serializer::Annotations::Accessor--fields","text":"getter - A method name whose return value will be used as the serialized value. setter - A method name that accepts the deserialized value. Can be used to apply additional logic before setting the properties value. converter - A module that defines a .deserialize method. Can be used to share common deserialization between types. path : Tuple - A set of keys used to navigate to a value during deserialization. The value of the last key will be used as the property's value.","title":"Fields"},{"location":"Serializer/Annotations/Accessor/#Athena::Serializer::Annotations::Accessor--example","text":"","title":"Example"},{"location":"Serializer/Annotations/Accessor/#Athena::Serializer::Annotations::Accessor--gettersetter","text":"class AccessorExample include ASR :: Serializable def initialize ; end @[ ASRA :: Accessor ( getter : get_foo , setter : set_foo ) ] property foo : String = \"foo\" private def set_foo ( foo : String ) : String @foo = foo . upcase end private def get_foo : String @foo . upcase end end ASR . serializer . serialize AccessorExample . new , :json # => {\"foo\":\"FOO\"} ASR . serializer . deserialize AccessorExample , %({\"foo\":\"bar\"}) , :json # => #<AccessorExample:0x7f5915e25c20 @foo=\"BAR\">","title":"Getter/Setter"},{"location":"Serializer/Annotations/Accessor/#Athena::Serializer::Annotations::Accessor--converter","text":"module ReverseConverter def self . deserialize ( navigator : ASR :: Navigators :: DeserializationNavigatorInterface , metadata : ASR :: PropertyMetadataBase , data : ASR :: Any ) : String data . as_s . reverse end end class ConverterExample include ASR :: Serializable @[ ASRA :: Accessor ( converter : ReverseConverter ) ] getter str : String end ASR . serializer . deserialize ConverterExample , %({\"str\":\"jim\"}) , :json # => #<ConverterExample:0x7f9745fa6d60 @str=\"mij\">","title":"Converter"},{"location":"Serializer/Annotations/Accessor/#Athena::Serializer::Annotations::Accessor--path","text":"class Example include ASR :: Serializable getter id : Int64 @[ ASRA :: Accessor ( path : { \"stats\" , \"HP\" }) ] getter hp : Int32 @[ ASRA :: Accessor ( path : { \"stats\" , \"Attack\" }) ] getter attack : Int32 @[ ASRA :: Accessor ( path : { \"downs\" , - 1 , \"last_down\" }) ] getter last_down : Time end DATA = <<- JSON { \"id\": 1, \"stats\": { \"HP\": 45, \"Attack\": 49 }, \"downs\": [ { \"id\": 1, \"last_down\": \"2020-05-019T05:23:17Z\" }, { \"id\": 2, \"last_down\": \"2020-04-07T12:34:56Z\" } ] } JSON ASR . serializer . deserialize Example , DATA , :json # #<Example:0x7f43c4ddf580 # @attack=49, # @hp=45, # @id=1, # @last_down=2020-04-07 12:34:56.0 UTC>","title":"Path"},{"location":"Serializer/Annotations/AccessorOrder/","text":"annotation Athena::Serializer::Annotations::AccessorOrder Can be applied to a type to control the order of properties when serialized. Valid values: :alphabetical , and :custom . By default properties are ordered in the order in which they are defined. Fields order - Used to specify the order of the properties when using :custom ordering. Example class Default include ASR :: Serializable def initialize ; end property a : String = \"A\" property z : String = \"Z\" property two : String = \"two\" property one : String = \"one\" property a_a : Int32 = 123 @[ ASRA :: VirtualProperty ] def get_val : String \"VAL\" end end ASR . serializer . serialize Default . new , :json # => {\"a\":\"A\",\"z\":\"Z\",\"two\":\"two\",\"one\":\"one\",\"a_a\":123,\"get_val\":\"VAL\"} @[ ASRA :: AccessorOrder ( :alphabetical ) ] class Abc include ASR :: Serializable def initialize ; end property a : String = \"A\" property z : String = \"Z\" property two : String = \"two\" property one : String = \"one\" property a_a : Int32 = 123 @[ ASRA :: VirtualProperty ] def get_val : String \"VAL\" end end ASR . serializer . serialize Abc . new , :json # => {\"a\":\"A\",\"a_a\":123,\"get_val\":\"VAL\",\"one\":\"one\",\"two\":\"two\",\"z\":\"Z\"} @[ ASRA :: AccessorOrder ( :custom , order : [ \"two\" , \"z\" , \"get_val\" , \"a\" , \"one\" , \"a_a\" ] ) ] class Custom include ASR :: Serializable def initialize ; end property a : String = \"A\" property z : String = \"Z\" property two : String = \"two\" property one : String = \"one\" property a_a : Int32 = 123 @[ ASRA :: VirtualProperty ] def get_val : String \"VAL\" end end ASR . serializer . serialize Custom . new , :json # => {\"two\":\"two\",\"z\":\"Z\",\"get_val\":\"VAL\",\"a\":\"A\",\"one\":\"one\",\"a_a\":123}","title":"AccessorOrder"},{"location":"Serializer/Annotations/AccessorOrder/#Athena::Serializer::Annotations::AccessorOrder","text":"Can be applied to a type to control the order of properties when serialized. Valid values: :alphabetical , and :custom . By default properties are ordered in the order in which they are defined.","title":"AccessorOrder"},{"location":"Serializer/Annotations/AccessorOrder/#Athena::Serializer::Annotations::AccessorOrder--fields","text":"order - Used to specify the order of the properties when using :custom ordering.","title":"Fields"},{"location":"Serializer/Annotations/AccessorOrder/#Athena::Serializer::Annotations::AccessorOrder--example","text":"class Default include ASR :: Serializable def initialize ; end property a : String = \"A\" property z : String = \"Z\" property two : String = \"two\" property one : String = \"one\" property a_a : Int32 = 123 @[ ASRA :: VirtualProperty ] def get_val : String \"VAL\" end end ASR . serializer . serialize Default . new , :json # => {\"a\":\"A\",\"z\":\"Z\",\"two\":\"two\",\"one\":\"one\",\"a_a\":123,\"get_val\":\"VAL\"} @[ ASRA :: AccessorOrder ( :alphabetical ) ] class Abc include ASR :: Serializable def initialize ; end property a : String = \"A\" property z : String = \"Z\" property two : String = \"two\" property one : String = \"one\" property a_a : Int32 = 123 @[ ASRA :: VirtualProperty ] def get_val : String \"VAL\" end end ASR . serializer . serialize Abc . new , :json # => {\"a\":\"A\",\"a_a\":123,\"get_val\":\"VAL\",\"one\":\"one\",\"two\":\"two\",\"z\":\"Z\"} @[ ASRA :: AccessorOrder ( :custom , order : [ \"two\" , \"z\" , \"get_val\" , \"a\" , \"one\" , \"a_a\" ] ) ] class Custom include ASR :: Serializable def initialize ; end property a : String = \"A\" property z : String = \"Z\" property two : String = \"two\" property one : String = \"one\" property a_a : Int32 = 123 @[ ASRA :: VirtualProperty ] def get_val : String \"VAL\" end end ASR . serializer . serialize Custom . new , :json # => {\"two\":\"two\",\"z\":\"Z\",\"get_val\":\"VAL\",\"a\":\"A\",\"one\":\"one\",\"a_a\":123}","title":"Example"},{"location":"Serializer/Annotations/Discriminator/","text":"annotation Athena::Serializer::Annotations::Discriminator Allows deserializing an object based on the value of a specific field. Fields key : String - The field that should be read from the data to determine the correct type. map : Hash | NamedTuple - Maps the possible key values to their corresponding types. Example @[ ASRA :: Discriminator ( key : \"type\" , map : { point : Point , circle : Circle }) ] abstract class Shape include ASR :: Serializable property type : String end class Point < Shape property x : Int32 property y : Int32 end class Circle < Shape property x : Int32 property y : Int32 property radius : Int32 end ASR . serializer . deserialize Shape , %({\"type\":\"point\",\"x\":10,\"y\":20}) , :json # => #<Point:0x7fbbf7f8bc20 @type=\"point\", @x=10, @y=20> ASR . serializer . deserialize Shape , %({\"type\":\"circle\",\"x\":30,\"y\":40,\"radius\":12}) , :json # => #<Circle:0x7fbbf7f93c60 @radius=12, @type=\"circle\", @x=30, @y=40>","title":"Discriminator"},{"location":"Serializer/Annotations/Discriminator/#Athena::Serializer::Annotations::Discriminator","text":"Allows deserializing an object based on the value of a specific field.","title":"Discriminator"},{"location":"Serializer/Annotations/Discriminator/#Athena::Serializer::Annotations::Discriminator--fields","text":"key : String - The field that should be read from the data to determine the correct type. map : Hash | NamedTuple - Maps the possible key values to their corresponding types.","title":"Fields"},{"location":"Serializer/Annotations/Discriminator/#Athena::Serializer::Annotations::Discriminator--example","text":"@[ ASRA :: Discriminator ( key : \"type\" , map : { point : Point , circle : Circle }) ] abstract class Shape include ASR :: Serializable property type : String end class Point < Shape property x : Int32 property y : Int32 end class Circle < Shape property x : Int32 property y : Int32 property radius : Int32 end ASR . serializer . deserialize Shape , %({\"type\":\"point\",\"x\":10,\"y\":20}) , :json # => #<Point:0x7fbbf7f8bc20 @type=\"point\", @x=10, @y=20> ASR . serializer . deserialize Shape , %({\"type\":\"circle\",\"x\":30,\"y\":40,\"radius\":12}) , :json # => #<Circle:0x7fbbf7f93c60 @radius=12, @type=\"circle\", @x=30, @y=40>","title":"Example"},{"location":"Serializer/Annotations/Exclude/","text":"annotation Athena::Serializer::Annotations::Exclude Indicates that a property should not be serialized/deserialized when used with :none ASRA::ExclusionPolicy . Also see, ASRA::IgnoreOnDeserialize and ASRA::IgnoreOnSerialize . Example @[ ASRA :: ExclusionPolicy ( :none ) ] class Example include ASR :: Serializable def initialize ; end property name : String = \"Jim\" @[ ASRA :: Exclude ] property password : String = \"monkey\" end ASR . serializer . serialize Example . new , :json # => {\"name\":\"Jim\"} ASR . serializer . deserialize Example , %({\"name\":\"Jim\",\"password\":\"password1!\"}) , :json # => #<Example:0x7f6eec4b6a60 @name=\"Jim\", @password=\"monkey\"> NOTE: On deserialization, the excluded property must be nilable, or have a default value.","title":"Exclude"},{"location":"Serializer/Annotations/Exclude/#Athena::Serializer::Annotations::Exclude","text":"Indicates that a property should not be serialized/deserialized when used with :none ASRA::ExclusionPolicy . Also see, ASRA::IgnoreOnDeserialize and ASRA::IgnoreOnSerialize .","title":"Exclude"},{"location":"Serializer/Annotations/Exclude/#Athena::Serializer::Annotations::Exclude--example","text":"@[ ASRA :: ExclusionPolicy ( :none ) ] class Example include ASR :: Serializable def initialize ; end property name : String = \"Jim\" @[ ASRA :: Exclude ] property password : String = \"monkey\" end ASR . serializer . serialize Example . new , :json # => {\"name\":\"Jim\"} ASR . serializer . deserialize Example , %({\"name\":\"Jim\",\"password\":\"password1!\"}) , :json # => #<Example:0x7f6eec4b6a60 @name=\"Jim\", @password=\"monkey\"> NOTE: On deserialization, the excluded property must be nilable, or have a default value.","title":"Example"},{"location":"Serializer/Annotations/ExclusionPolicy/","text":"annotation Athena::Serializer::Annotations::ExclusionPolicy Defines the default exclusion policy to use on a class. Valid values: :none , and :all . Used with ASRA::Expose and ASRA::Exclude .","title":"ExclusionPolicy"},{"location":"Serializer/Annotations/ExclusionPolicy/#Athena::Serializer::Annotations::ExclusionPolicy","text":"Defines the default exclusion policy to use on a class. Valid values: :none , and :all . Used with ASRA::Expose and ASRA::Exclude .","title":"ExclusionPolicy"},{"location":"Serializer/Annotations/Expose/","text":"annotation Athena::Serializer::Annotations::Expose Indicates that a property should be serialized/deserialized when used with :all ASRA::ExclusionPolicy . Also see, ASRA::IgnoreOnDeserialize and ASRA::IgnoreOnSerialize . Example @[ ASRA :: ExclusionPolicy ( :all ) ] class Example include ASR :: Serializable def initialize ; end @[ ASRA :: Expose ] property name : String = \"Jim\" property password : String = \"monkey\" end ASR . serializer . serialize Example . new , :json # => {\"name\":\"Jim\"} ASR . serializer . deserialize Example , %({\"name\":\"Jim\",\"password\":\"password1!\"}) , :json # => #<Example:0x7f6eec4b6a60 @name=\"Jim\", @password=\"monkey\"> NOTE: On deserialization, the excluded property must be nilable, or have a default value.","title":"Expose"},{"location":"Serializer/Annotations/Expose/#Athena::Serializer::Annotations::Expose","text":"Indicates that a property should be serialized/deserialized when used with :all ASRA::ExclusionPolicy . Also see, ASRA::IgnoreOnDeserialize and ASRA::IgnoreOnSerialize .","title":"Expose"},{"location":"Serializer/Annotations/Expose/#Athena::Serializer::Annotations::Expose--example","text":"@[ ASRA :: ExclusionPolicy ( :all ) ] class Example include ASR :: Serializable def initialize ; end @[ ASRA :: Expose ] property name : String = \"Jim\" property password : String = \"monkey\" end ASR . serializer . serialize Example . new , :json # => {\"name\":\"Jim\"} ASR . serializer . deserialize Example , %({\"name\":\"Jim\",\"password\":\"password1!\"}) , :json # => #<Example:0x7f6eec4b6a60 @name=\"Jim\", @password=\"monkey\"> NOTE: On deserialization, the excluded property must be nilable, or have a default value.","title":"Example"},{"location":"Serializer/Annotations/Groups/","text":"annotation Athena::Serializer::Annotations::Groups Defines the group(s) a property belongs to. Properties are automatically added to the default group if no groups are explicitly defined. See ASR::ExclusionStrategies::Groups .","title":"Groups"},{"location":"Serializer/Annotations/Groups/#Athena::Serializer::Annotations::Groups","text":"Defines the group(s) a property belongs to. Properties are automatically added to the default group if no groups are explicitly defined. See ASR::ExclusionStrategies::Groups .","title":"Groups"},{"location":"Serializer/Annotations/IgnoreOnDeserialize/","text":"annotation Athena::Serializer::Annotations::IgnoreOnDeserialize Indicates that a property should not be set on deserialization, but should be serialized. Example class Example include ASR :: Serializable property name : String @[ ASRA :: IgnoreOnDeserialize ] property password : String ? end obj = ASR . serializer . deserialize Example , %({\"name\":\"Jim\",\"password\":\"monkey123\"}) , :json obj . password # => nil obj . name # => Jim obj . password = \"foobar\" ASR . serializer . serialize obj , :json # => {\"name\":\"Jim\",\"password\":\"foobar\"}","title":"IgnoreOnDeserialize"},{"location":"Serializer/Annotations/IgnoreOnDeserialize/#Athena::Serializer::Annotations::IgnoreOnDeserialize","text":"Indicates that a property should not be set on deserialization, but should be serialized.","title":"IgnoreOnDeserialize"},{"location":"Serializer/Annotations/IgnoreOnDeserialize/#Athena::Serializer::Annotations::IgnoreOnDeserialize--example","text":"class Example include ASR :: Serializable property name : String @[ ASRA :: IgnoreOnDeserialize ] property password : String ? end obj = ASR . serializer . deserialize Example , %({\"name\":\"Jim\",\"password\":\"monkey123\"}) , :json obj . password # => nil obj . name # => Jim obj . password = \"foobar\" ASR . serializer . serialize obj , :json # => {\"name\":\"Jim\",\"password\":\"foobar\"}","title":"Example"},{"location":"Serializer/Annotations/IgnoreOnSerialize/","text":"annotation Athena::Serializer::Annotations::IgnoreOnSerialize Indicates that a property should be set on deserialization, but should not be serialized. Example class Example include ASR :: Serializable property name : String @[ ASRA :: IgnoreOnSerialize ] property password : String ? end obj = ASR . serializer . deserialize Example , %({\"name\":\"Jim\",\"password\":\"monkey123\"}) , :json obj . password # => monkey123 obj . name # => Jim obj . password = \"foobar\" ASR . serializer . serialize obj , :json # => {\"name\":\"Jim\"}","title":"IgnoreOnSerialize"},{"location":"Serializer/Annotations/IgnoreOnSerialize/#Athena::Serializer::Annotations::IgnoreOnSerialize","text":"Indicates that a property should be set on deserialization, but should not be serialized.","title":"IgnoreOnSerialize"},{"location":"Serializer/Annotations/IgnoreOnSerialize/#Athena::Serializer::Annotations::IgnoreOnSerialize--example","text":"class Example include ASR :: Serializable property name : String @[ ASRA :: IgnoreOnSerialize ] property password : String ? end obj = ASR . serializer . deserialize Example , %({\"name\":\"Jim\",\"password\":\"monkey123\"}) , :json obj . password # => monkey123 obj . name # => Jim obj . password = \"foobar\" ASR . serializer . serialize obj , :json # => {\"name\":\"Jim\"}","title":"Example"},{"location":"Serializer/Annotations/Name/","text":"annotation Athena::Serializer::Annotations::Name Defines the key to use during (de)serialization. If not provided, the name of the property is used. Also allows defining aliases that can be used for that property when deserializing. Fields serialize : String - The key to use for this property during serialization. deserialize : String - The key to use for this property during deserialization. key : String - The key to use for this property during (de)serialization. aliases : Array(String) - A set of keys to use for this property during deserialization; is equivalent to multiple deserialize keys. serialization_strategy : Symbol - Defines the default serialization naming strategy for this type. Can be overridden using the serialize or key field. deserialization_strategy : Symbol - Defines the default deserialization naming strategy for this type. Can be overridden using the deserialize or key field. strategy : Symbol - Defines the default (de)serialization naming strategy for this type. Can be overridden using the serialize , deserialize or key fields. Example class Example include ASR :: Serializable def initialize ; end @[ ASRA :: Name ( serialize : \"myAddress\" ) ] property my_home_address : String = \"123 Fake Street\" @[ ASRA :: Name ( deserialize : \"some_key\" , serialize : \"a_value\" ) ] property both_names : String = \"str\" @[ ASRA :: Name ( key : \"same\" ) ] property same_in_both_directions : String = \"same for both\" @[ ASRA :: Name ( aliases : [ \"val\" , \"value\" , \"some_value\" ] ) ] property some_value : String = \"some_val\" end ASR . serializer . serialize Example . new , :json # => {\"myAddress\":\"123 Fake Street\",\"a_value\":\"str\",\"same\":\"same for both\",\"some_value\":\"some_val\"} obj = ASR . serializer . deserialize Example , %({\"my_home_address\":\"555 Mason Ave\",\"some_key\":\"deserialized from diff key\",\"same\":\"same again\",\"value\":\"some_other_val\"}) , :json obj . my_home_address # => \"555 Mason Ave\" obj . both_names # => \"deserialized from diff key\" obj . same_in_both_directions # => \"same again\" obj . some_value # => \"some_other_val\" Naming Strategies By default the keys in the serialized data match exactly to the name of the property. Naming strategies allow changing this behavior for all properties within the type. The serialized name can still be overridden on a per-property basis via using the ASRA::Name annotation with the serialize , deserialize or key field. The strategy will be applied on serialization, deserialization or both, depending on whether serialization_strategy , deserialization_strategy or strategy is used. The available naming strategies include: * :camelcase * :underscore * :identical @[ ASRA :: Name ( strategy : :camelcase ) ] class User include ASR :: Serializable def initialize ; end property id : Int32 = 1 property first_name : String = \"Jon\" property last_name : String = \"Snow\" end ASR . serializer . serialize User . new , :json # => {\"id\":1,\"firstName\":\"Jon\",\"lastName\":\"Snow\"}","title":"Name"},{"location":"Serializer/Annotations/Name/#Athena::Serializer::Annotations::Name","text":"Defines the key to use during (de)serialization. If not provided, the name of the property is used. Also allows defining aliases that can be used for that property when deserializing.","title":"Name"},{"location":"Serializer/Annotations/Name/#Athena::Serializer::Annotations::Name--fields","text":"serialize : String - The key to use for this property during serialization. deserialize : String - The key to use for this property during deserialization. key : String - The key to use for this property during (de)serialization. aliases : Array(String) - A set of keys to use for this property during deserialization; is equivalent to multiple deserialize keys. serialization_strategy : Symbol - Defines the default serialization naming strategy for this type. Can be overridden using the serialize or key field. deserialization_strategy : Symbol - Defines the default deserialization naming strategy for this type. Can be overridden using the deserialize or key field. strategy : Symbol - Defines the default (de)serialization naming strategy for this type. Can be overridden using the serialize , deserialize or key fields.","title":"Fields"},{"location":"Serializer/Annotations/Name/#Athena::Serializer::Annotations::Name--example","text":"class Example include ASR :: Serializable def initialize ; end @[ ASRA :: Name ( serialize : \"myAddress\" ) ] property my_home_address : String = \"123 Fake Street\" @[ ASRA :: Name ( deserialize : \"some_key\" , serialize : \"a_value\" ) ] property both_names : String = \"str\" @[ ASRA :: Name ( key : \"same\" ) ] property same_in_both_directions : String = \"same for both\" @[ ASRA :: Name ( aliases : [ \"val\" , \"value\" , \"some_value\" ] ) ] property some_value : String = \"some_val\" end ASR . serializer . serialize Example . new , :json # => {\"myAddress\":\"123 Fake Street\",\"a_value\":\"str\",\"same\":\"same for both\",\"some_value\":\"some_val\"} obj = ASR . serializer . deserialize Example , %({\"my_home_address\":\"555 Mason Ave\",\"some_key\":\"deserialized from diff key\",\"same\":\"same again\",\"value\":\"some_other_val\"}) , :json obj . my_home_address # => \"555 Mason Ave\" obj . both_names # => \"deserialized from diff key\" obj . same_in_both_directions # => \"same again\" obj . some_value # => \"some_other_val\"","title":"Example"},{"location":"Serializer/Annotations/Name/#Athena::Serializer::Annotations::Name--naming-strategies","text":"By default the keys in the serialized data match exactly to the name of the property. Naming strategies allow changing this behavior for all properties within the type. The serialized name can still be overridden on a per-property basis via using the ASRA::Name annotation with the serialize , deserialize or key field. The strategy will be applied on serialization, deserialization or both, depending on whether serialization_strategy , deserialization_strategy or strategy is used. The available naming strategies include: * :camelcase * :underscore * :identical @[ ASRA :: Name ( strategy : :camelcase ) ] class User include ASR :: Serializable def initialize ; end property id : Int32 = 1 property first_name : String = \"Jon\" property last_name : String = \"Snow\" end ASR . serializer . serialize User . new , :json # => {\"id\":1,\"firstName\":\"Jon\",\"lastName\":\"Snow\"}","title":"Naming Strategies"},{"location":"Serializer/Annotations/PostDeserialize/","text":"annotation Athena::Serializer::Annotations::PostDeserialize Defines a callback method(s) that are ran directly after the object has been deserialized. Example record Example , name : String , first_name : String ?, last_name : String ? do include ASR :: Serializable @[ ASRA :: PostDeserialize ] private def split_name : Nil @first_name , @last_name = @name . split ( ' ' ) end end obj = ASR . serializer . deserialize Example , %({\"name\":\"Jon Snow\"}) , :json obj . name # => Jon Snow obj . first_name # => Jon obj . last_name # => Snow","title":"PostDeserialize"},{"location":"Serializer/Annotations/PostDeserialize/#Athena::Serializer::Annotations::PostDeserialize","text":"Defines a callback method(s) that are ran directly after the object has been deserialized.","title":"PostDeserialize"},{"location":"Serializer/Annotations/PostDeserialize/#Athena::Serializer::Annotations::PostDeserialize--example","text":"record Example , name : String , first_name : String ?, last_name : String ? do include ASR :: Serializable @[ ASRA :: PostDeserialize ] private def split_name : Nil @first_name , @last_name = @name . split ( ' ' ) end end obj = ASR . serializer . deserialize Example , %({\"name\":\"Jon Snow\"}) , :json obj . name # => Jon Snow obj . first_name # => Jon obj . last_name # => Snow","title":"Example"},{"location":"Serializer/Annotations/PostSerialize/","text":"annotation Athena::Serializer::Annotations::PostSerialize Defines a callback method that is executed directly after the object has been serialized. Example @[ ASRA :: ExclusionPolicy ( :all ) ] class Example include ASR :: Serializable def initialize ; end @[ ASRA :: Expose ] @name : String ? property first_name : String = \"Jon\" property last_name : String = \"Snow\" @[ ASRA :: PreSerialize ] private def pre_ser : Nil @name = \" #{ first_name } #{ last_name } \" end @[ ASRA :: PostSerialize ] private def post_ser : Nil @name = nil end end ASR . serializer . serialize Example . new , :json # => {\"name\":\"Jon Snow\"}","title":"PostSerialize"},{"location":"Serializer/Annotations/PostSerialize/#Athena::Serializer::Annotations::PostSerialize","text":"Defines a callback method that is executed directly after the object has been serialized.","title":"PostSerialize"},{"location":"Serializer/Annotations/PostSerialize/#Athena::Serializer::Annotations::PostSerialize--example","text":"@[ ASRA :: ExclusionPolicy ( :all ) ] class Example include ASR :: Serializable def initialize ; end @[ ASRA :: Expose ] @name : String ? property first_name : String = \"Jon\" property last_name : String = \"Snow\" @[ ASRA :: PreSerialize ] private def pre_ser : Nil @name = \" #{ first_name } #{ last_name } \" end @[ ASRA :: PostSerialize ] private def post_ser : Nil @name = nil end end ASR . serializer . serialize Example . new , :json # => {\"name\":\"Jon Snow\"}","title":"Example"},{"location":"Serializer/Annotations/PreSerialize/","text":"annotation Athena::Serializer::Annotations::PreSerialize Defines a callback method that is executed directly before the object has been serialized. Example @[ ASRA :: ExclusionPolicy ( :all ) ] class Example include ASR :: Serializable def initialize ; end @[ ASRA :: Expose ] @name : String ? property first_name : String = \"Jon\" property last_name : String = \"Snow\" @[ ASRA :: PreSerialize ] private def pre_ser : Nil @name = \" #{ first_name } #{ last_name } \" end @[ ASRA :: PostSerialize ] private def post_ser : Nil @name = nil end end ASR . serializer . serialize Example . new , :json # => {\"name\":\"Jon Snow\"}","title":"PreSerialize"},{"location":"Serializer/Annotations/PreSerialize/#Athena::Serializer::Annotations::PreSerialize","text":"Defines a callback method that is executed directly before the object has been serialized.","title":"PreSerialize"},{"location":"Serializer/Annotations/PreSerialize/#Athena::Serializer::Annotations::PreSerialize--example","text":"@[ ASRA :: ExclusionPolicy ( :all ) ] class Example include ASR :: Serializable def initialize ; end @[ ASRA :: Expose ] @name : String ? property first_name : String = \"Jon\" property last_name : String = \"Snow\" @[ ASRA :: PreSerialize ] private def pre_ser : Nil @name = \" #{ first_name } #{ last_name } \" end @[ ASRA :: PostSerialize ] private def post_ser : Nil @name = nil end end ASR . serializer . serialize Example . new , :json # => {\"name\":\"Jon Snow\"}","title":"Example"},{"location":"Serializer/Annotations/ReadOnly/","text":"annotation Athena::Serializer::Annotations::ReadOnly Indicates that a property is read-only and cannot be set during deserialization. Example class Example include ASR :: Serializable property name : String @[ ASRA :: ReadOnly ] property password : String ? end obj = ASR . serializer . deserialize Example , %({\"name\":\"Fred\",\"password\":\"password1\"}) , :json obj . name # => \"Fred\" obj . password # => nil NOTE: The property must be nilable, or have a default value.","title":"ReadOnly"},{"location":"Serializer/Annotations/ReadOnly/#Athena::Serializer::Annotations::ReadOnly","text":"Indicates that a property is read-only and cannot be set during deserialization.","title":"ReadOnly"},{"location":"Serializer/Annotations/ReadOnly/#Athena::Serializer::Annotations::ReadOnly--example","text":"class Example include ASR :: Serializable property name : String @[ ASRA :: ReadOnly ] property password : String ? end obj = ASR . serializer . deserialize Example , %({\"name\":\"Fred\",\"password\":\"password1\"}) , :json obj . name # => \"Fred\" obj . password # => nil NOTE: The property must be nilable, or have a default value.","title":"Example"},{"location":"Serializer/Annotations/Since/","text":"annotation Athena::Serializer::Annotations::Since Represents the first version a property was available. See ASR::ExclusionStrategies::Version . NOTE: Value must be a SemanticVersion version.","title":"Since"},{"location":"Serializer/Annotations/Since/#Athena::Serializer::Annotations::Since","text":"Represents the first version a property was available. See ASR::ExclusionStrategies::Version . NOTE: Value must be a SemanticVersion version.","title":"Since"},{"location":"Serializer/Annotations/Skip/","text":"annotation Athena::Serializer::Annotations::Skip Indicates that a property should not be serialized or deserialized. Example class Example include ASR :: Serializable def initialize ; end property name : String = \"Jim\" @[ ASRA :: Skip ] property password : String = \"monkey\" end ASR . serializer . deserialize Example , %({\"name\":\"Fred\",\"password\":\"foobar\"}) , :json # => #<Example:0x7fe4dc98bce0 @name=\"Fred\", @password=\"monkey\"> ASR . serializer . serialize Example . new , :json # => {\"name\":\"Fred\"}","title":"Skip"},{"location":"Serializer/Annotations/Skip/#Athena::Serializer::Annotations::Skip","text":"Indicates that a property should not be serialized or deserialized.","title":"Skip"},{"location":"Serializer/Annotations/Skip/#Athena::Serializer::Annotations::Skip--example","text":"class Example include ASR :: Serializable def initialize ; end property name : String = \"Jim\" @[ ASRA :: Skip ] property password : String = \"monkey\" end ASR . serializer . deserialize Example , %({\"name\":\"Fred\",\"password\":\"foobar\"}) , :json # => #<Example:0x7fe4dc98bce0 @name=\"Fred\", @password=\"monkey\"> ASR . serializer . serialize Example . new , :json # => {\"name\":\"Fred\"}","title":"Example"},{"location":"Serializer/Annotations/SkipWhenEmpty/","text":"annotation Athena::Serializer::Annotations::SkipWhenEmpty Indicates that a property should not be serialized when it is empty. Example class Example include ASR :: Serializable def initialize ; end property id : Int64 = 1 @[ ASRA :: SkipWhenEmpty ] property value : String = \"value\" @[ ASRA :: SkipWhenEmpty ] property values : Array ( String ) = %w(one two three) end obj = Example . new ASR . serializer . serialize obj , :json # => {\"id\":1,\"value\":\"value\",\"values\":[\"one\",\"two\",\"three\"]} obj . value = \"\" obj . values = [] of String ASR . serializer . serialize obj , :json # => {\"id\":1} NOTE: Can be used on any type that defines an #empty? method.","title":"SkipWhenEmpty"},{"location":"Serializer/Annotations/SkipWhenEmpty/#Athena::Serializer::Annotations::SkipWhenEmpty","text":"Indicates that a property should not be serialized when it is empty.","title":"SkipWhenEmpty"},{"location":"Serializer/Annotations/SkipWhenEmpty/#Athena::Serializer::Annotations::SkipWhenEmpty--example","text":"class Example include ASR :: Serializable def initialize ; end property id : Int64 = 1 @[ ASRA :: SkipWhenEmpty ] property value : String = \"value\" @[ ASRA :: SkipWhenEmpty ] property values : Array ( String ) = %w(one two three) end obj = Example . new ASR . serializer . serialize obj , :json # => {\"id\":1,\"value\":\"value\",\"values\":[\"one\",\"two\",\"three\"]} obj . value = \"\" obj . values = [] of String ASR . serializer . serialize obj , :json # => {\"id\":1} NOTE: Can be used on any type that defines an #empty? method.","title":"Example"},{"location":"Serializer/Annotations/Until/","text":"annotation Athena::Serializer::Annotations::Until Represents the last version a property was available. See ASR::ExclusionStrategies::Version . NOTE: Value must be a SemanticVersion version.","title":"Until"},{"location":"Serializer/Annotations/Until/#Athena::Serializer::Annotations::Until","text":"Represents the last version a property was available. See ASR::ExclusionStrategies::Version . NOTE: Value must be a SemanticVersion version.","title":"Until"},{"location":"Serializer/Annotations/VirtualProperty/","text":"annotation Athena::Serializer::Annotations::VirtualProperty Can be applied to a method to make it act like a property. Example class Example include ASR :: Serializable def initialize ; end property foo : String = \"foo\" @[ ASRA :: VirtualProperty ] @[ ASRA :: Name ( serialize : \"testing\" ) ] def some_method : Bool false end @[ ASRA :: VirtualProperty ] def get_val : String \"VAL\" end end ASR . serializer . serialize Example . new , :json # => {\"foo\":\"foo\",\"testing\":false,\"get_val\":\"VAL\"} NOTE: The return type restriction MUST be defined.","title":"VirtualProperty"},{"location":"Serializer/Annotations/VirtualProperty/#Athena::Serializer::Annotations::VirtualProperty","text":"Can be applied to a method to make it act like a property.","title":"VirtualProperty"},{"location":"Serializer/Annotations/VirtualProperty/#Athena::Serializer::Annotations::VirtualProperty--example","text":"class Example include ASR :: Serializable def initialize ; end property foo : String = \"foo\" @[ ASRA :: VirtualProperty ] @[ ASRA :: Name ( serialize : \"testing\" ) ] def some_method : Bool false end @[ ASRA :: VirtualProperty ] def get_val : String \"VAL\" end end ASR . serializer . serialize Example . new , :json # => {\"foo\":\"foo\",\"testing\":false,\"get_val\":\"VAL\"} NOTE: The return type restriction MUST be defined.","title":"Example"},{"location":"Serializer/Any/","text":"module Athena::Serializer::Any Defines an abstraction that format specific types, such as JSON::Any , or YAML::Any must implement. Methods abstract #as_a abstract #as_a? abstract #as_bool : Bool abstract #as_f : Float64 abstract #as_f32 : Float32 abstract #as_f32? : Float32 ? abstract #as_f? : Float64 ? abstract #as_i : Int32 abstract #as_i64 : Int64 abstract #as_i64? : Int64 ? abstract #as_i? : Int32 ? abstract #as_s : String abstract #as_s? : String ? abstract #dig ( key_or_index : String | Int , * keys ) abstract #is_nil? : Bool abstract #raw","title":"Any"},{"location":"Serializer/Any/#Athena::Serializer::Any","text":"Defines an abstraction that format specific types, such as JSON::Any , or YAML::Any must implement.","title":"Any"},{"location":"Serializer/Any/#methods","text":"","title":"Methods"},{"location":"Serializer/Any/#Athena::Serializer::Any#as_a()","text":"","title":"#as_a"},{"location":"Serializer/Any/#Athena::Serializer::Any#as_a?()","text":"","title":"#as_a?"},{"location":"Serializer/Any/#Athena::Serializer::Any#as_bool()","text":"","title":"#as_bool"},{"location":"Serializer/Any/#Athena::Serializer::Any#as_f()","text":"","title":"#as_f"},{"location":"Serializer/Any/#Athena::Serializer::Any#as_f32()","text":"","title":"#as_f32"},{"location":"Serializer/Any/#Athena::Serializer::Any#as_f32?()","text":"","title":"#as_f32?"},{"location":"Serializer/Any/#Athena::Serializer::Any#as_f?()","text":"","title":"#as_f?"},{"location":"Serializer/Any/#Athena::Serializer::Any#as_i()","text":"","title":"#as_i"},{"location":"Serializer/Any/#Athena::Serializer::Any#as_i64()","text":"","title":"#as_i64"},{"location":"Serializer/Any/#Athena::Serializer::Any#as_i64?()","text":"","title":"#as_i64?"},{"location":"Serializer/Any/#Athena::Serializer::Any#as_i?()","text":"","title":"#as_i?"},{"location":"Serializer/Any/#Athena::Serializer::Any#as_s()","text":"","title":"#as_s"},{"location":"Serializer/Any/#Athena::Serializer::Any#as_s?()","text":"","title":"#as_s?"},{"location":"Serializer/Any/#Athena::Serializer::Any#dig(key_or_index,*keys)","text":"","title":"#dig"},{"location":"Serializer/Any/#Athena::Serializer::Any#is_nil?()","text":"","title":"#is_nil?"},{"location":"Serializer/Any/#Athena::Serializer::Any#raw()","text":"","title":"#raw"},{"location":"Serializer/Context/","text":"abstract class Athena::Serializer::Context inherits Reference Stores runtime data about the current action. Such as what serialization groups/version to use when serializing. NOTE: Cannot be used for more than one action. Direct known subclasses Athena::Serializer::DeserializationContext Athena::Serializer::SerializationContext Methods #add_exclusion_strategy ( strategy : ASR::ExclusionStrategies::ExclusionStrategyInterface ) : self Adds strategy to self . exclusion_strategy is set to strategy if there previously was no strategy. exclusion_strategy is set to ASR::ExclusionStrategies::Disjunct if there was a exclusion_strategy already set. strategy is added to the ASR::ExclusionStrategies::Disjunct if there are multiple strategies. abstract #direction : ASR::Context::Direction Returns which (de)serialization action self represents. #exclusion_strategy : ASR::ExclusionStrategies::ExclusionStrategyInterface? The ASR::ExclusionStrategies::ExclusionStrategyInterface being used. #groups : Array ( String )? Returns the serialization groups, if any, currently set on self . #groups= ( groups : Array ( String )) : self Sets the group(s) to compare against properties' ASRA::Groups annotations. Adds a ASR::ExclusionStrategies::Groups automatically if set. #version : SemanticVersion? Returns the version, if any, currently set on self . #version= ( version : String ) : self Sets the version to compare against properties' ASRA::Since and ASRA::Until annotations. Adds an ASR::ExclusionStrategies::Version automatically if set.","title":"Context"},{"location":"Serializer/Context/#Athena::Serializer::Context","text":"Stores runtime data about the current action. Such as what serialization groups/version to use when serializing. NOTE: Cannot be used for more than one action.","title":"Context"},{"location":"Serializer/Context/#direct-known-subclasses","text":"Athena::Serializer::DeserializationContext Athena::Serializer::SerializationContext","title":"Direct known subclasses"},{"location":"Serializer/Context/#methods","text":"","title":"Methods"},{"location":"Serializer/Context/#Athena::Serializer::Context#add_exclusion_strategy(strategy)","text":"Adds strategy to self . exclusion_strategy is set to strategy if there previously was no strategy. exclusion_strategy is set to ASR::ExclusionStrategies::Disjunct if there was a exclusion_strategy already set. strategy is added to the ASR::ExclusionStrategies::Disjunct if there are multiple strategies.","title":"#add_exclusion_strategy"},{"location":"Serializer/Context/#Athena::Serializer::Context#direction()","text":"Returns which (de)serialization action self represents.","title":"#direction"},{"location":"Serializer/Context/#Athena::Serializer::Context#exclusion_strategy()","text":"The ASR::ExclusionStrategies::ExclusionStrategyInterface being used.","title":"#exclusion_strategy"},{"location":"Serializer/Context/#Athena::Serializer::Context#groups()","text":"Returns the serialization groups, if any, currently set on self .","title":"#groups"},{"location":"Serializer/Context/#Athena::Serializer::Context#groups=(groups)","text":"Sets the group(s) to compare against properties' ASRA::Groups annotations. Adds a ASR::ExclusionStrategies::Groups automatically if set.","title":"#groups="},{"location":"Serializer/Context/#Athena::Serializer::Context#version()","text":"Returns the version, if any, currently set on self .","title":"#version"},{"location":"Serializer/Context/#Athena::Serializer::Context#version=(version)","text":"Sets the version to compare against properties' ASRA::Since and ASRA::Until annotations. Adds an ASR::ExclusionStrategies::Version automatically if set.","title":"#version="},{"location":"Serializer/Context/Direction/","text":"enum Athena::Serializer::Context::Direction The possible (de)serialization actions. Members Deserialization = 0 Serialization = 1 Methods #deserialization? #serialization?","title":"Direction"},{"location":"Serializer/Context/Direction/#Athena::Serializer::Context::Direction","text":"The possible (de)serialization actions.","title":"Direction"},{"location":"Serializer/Context/Direction/#members","text":"","title":"Members"},{"location":"Serializer/Context/Direction/#Athena::Serializer::Context::Direction::Deserialization","text":"","title":"Deserialization"},{"location":"Serializer/Context/Direction/#Athena::Serializer::Context::Direction::Serialization","text":"","title":"Serialization"},{"location":"Serializer/Context/Direction/#methods","text":"","title":"Methods"},{"location":"Serializer/Context/Direction/#Athena::Serializer::Context::Direction#deserialization?()","text":"","title":"#deserialization?"},{"location":"Serializer/Context/Direction/#Athena::Serializer::Context::Direction#serialization?()","text":"","title":"#serialization?"},{"location":"Serializer/DeserializationContext/","text":"class Athena::Serializer::DeserializationContext inherits Athena::Serializer::Context The ASR::Context specific to deserialization. Methods #direction : ASR::Context::Direction Returns which (de)serialization action self represents.","title":"DeserializationContext"},{"location":"Serializer/DeserializationContext/#Athena::Serializer::DeserializationContext","text":"The ASR::Context specific to deserialization.","title":"DeserializationContext"},{"location":"Serializer/DeserializationContext/#methods","text":"","title":"Methods"},{"location":"Serializer/DeserializationContext/#Athena::Serializer::DeserializationContext#direction()","text":"Returns which (de)serialization action self represents.","title":"#direction"},{"location":"Serializer/ExclusionStrategies/","text":"module Athena::Serializer::ExclusionStrategies Exclusion Strategies allow controlling which properties should be (de)serialized. Athena::Serializer includes two common strategies: ASR::ExclusionStrategies::Groups , and ASR::ExclusionStrategies::Version . Custom strategies can be implemented by via ExclusionStrategies::ExclusionStrategyInterface . OPTIMIZE: Once feasible, support compile time exclusion strategies.","title":"ExclusionStrategies"},{"location":"Serializer/ExclusionStrategies/#Athena::Serializer::ExclusionStrategies","text":"Exclusion Strategies allow controlling which properties should be (de)serialized. Athena::Serializer includes two common strategies: ASR::ExclusionStrategies::Groups , and ASR::ExclusionStrategies::Version . Custom strategies can be implemented by via ExclusionStrategies::ExclusionStrategyInterface . OPTIMIZE: Once feasible, support compile time exclusion strategies.","title":"ExclusionStrategies"},{"location":"Serializer/ExclusionStrategies/Disjunct/","text":"struct Athena::Serializer::ExclusionStrategies::Disjunct inherits Struct Wraps an Array(ASR::ExclusionStrategies::ExclusionStrategyInterface) , excluding a property if any member skips it. Used internally to allow multiple exclusion strategies to be used within a single instance variable for ASR::Context#add_exclusion_strategy . Included modules Athena::Serializer::ExclusionStrategies::ExclusionStrategyInterface Class methods .new ( members : Array ( ASR::ExclusionStrategies::ExclusionStrategyInterface )) Methods #members : Array ( ASR::ExclusionStrategies::ExclusionStrategyInterface ) The wrapped exclusion strategies. #skip_property? ( metadata : ASR::PropertyMetadataBase , context : ASR::Context ) : Bool Returns true if a property should NOT be (de)serialized.","title":"Disjunct"},{"location":"Serializer/ExclusionStrategies/Disjunct/#Athena::Serializer::ExclusionStrategies::Disjunct","text":"Wraps an Array(ASR::ExclusionStrategies::ExclusionStrategyInterface) , excluding a property if any member skips it. Used internally to allow multiple exclusion strategies to be used within a single instance variable for ASR::Context#add_exclusion_strategy .","title":"Disjunct"},{"location":"Serializer/ExclusionStrategies/Disjunct/#included-modules","text":"Athena::Serializer::ExclusionStrategies::ExclusionStrategyInterface","title":"Included modules"},{"location":"Serializer/ExclusionStrategies/Disjunct/#class-methods","text":"","title":"Class methods"},{"location":"Serializer/ExclusionStrategies/Disjunct/#Athena::Serializer::ExclusionStrategies::Disjunct.new(members)","text":"","title":".new"},{"location":"Serializer/ExclusionStrategies/Disjunct/#methods","text":"","title":"Methods"},{"location":"Serializer/ExclusionStrategies/Disjunct/#Athena::Serializer::ExclusionStrategies::Disjunct#members()","text":"The wrapped exclusion strategies.","title":"#members"},{"location":"Serializer/ExclusionStrategies/Disjunct/#Athena::Serializer::ExclusionStrategies::Disjunct#skip_property?(metadata,context)","text":"Returns true if a property should NOT be (de)serialized.","title":"#skip_property?"},{"location":"Serializer/ExclusionStrategies/ExclusionStrategyInterface/","text":"module Athena::Serializer::ExclusionStrategies::ExclusionStrategyInterface Represents a specific exclusion strategy. Custom logic can be implemented by defining a type with this interface. It can then be used via ASR::Context#add_exclusion_strategy . Example struct OddNumberExclusionStrategy include Athena :: Serializer :: ExclusionStrategies :: ExclusionStrategyInterface # :inherit: # # Skips serializing odd numbered values def skip_property? ( metadata : ASR :: PropertyMetadataBase , context : ASR :: Context ) : Bool # Don't skip if the value is nil return false unless value = ( metadata . value ) # Only skip on serialization, if the value is an number, and if it's odd. context . is_a? ( ASR :: SerializationContext ) && value . is_a? ( Number ) && value . odd? end end serialization_context = ASR :: SerializationContext . new serialization_context . add_exclusion_strategy OddNumberExclusionStrategy . new deserialization_context = ASR :: DeserializationContext . new deserialization_context . add_exclusion_strategy OddNumberExclusionStrategy . new record Values , one : Int32 = 1 , two : Int32 = 2 , three : Int32 = 3 do include ASR :: Serializable end ASR . serializer . serialize Values . new , :json , serialization_context # => {\"two\":2} ASR . serializer . deserialize Values , %({\"one\":4,\"two\":5,\"three\":6}) , :json , deserialization_context # => Values(@one=4, @three=6, @two=5) Annotation Configurations Custom annotations can be defined using Athena::Config.configuration_annotation . These annotations will be exposed at runtime as part of the properties' metadata within exclusion strategies via ASR::PropertyMetadata#annotation_configurations . The main purpose of this is to allow for more advanced annotation based exclusion strategies. # Define an annotation called `IsActiveProperty` that accepts an optional `active` field. ACF . configuration_annotation IsActiveProperty , active : Bool = true # Define an exclusion strategy that should skip \"inactive\" properties. struct ActivePropertyExclusionStrategy include Athena :: Serializer :: ExclusionStrategies :: ExclusionStrategyInterface # :inherit: def skip_property? ( metadata : ASR :: PropertyMetadataBase , context : ASR :: Context ) : Bool # Don't skip on deserialization. return false if context . direction . deserialization? ann_configs = metadata . annotation_configurations # Skip if the property has the annotation and it's \"inactive\". ann_configs . has? ( IsActiveProperty ) && ! ann_configs [ IsActiveProperty ]. active end end record Example , id : Int32 , first_name : String , last_name : String , zip_code : Int32 do include ASR :: Serializable @[ IsActiveProperty ] @first_name : String @[ IsActiveProperty ( active : false ) ] @last_name : String # Can also be defined as a positional argument. @[ IsActiveProperty ( false ) ] @zip_code : Int32 end serialization_context = ASR :: SerializationContext . new serialization_context . add_exclusion_strategy ActivePropertyExclusionStrategy . new ASR . serializer . serialize Example . new ( 1 , \"Jon\" , \"Snow\" , 90210 ), :json , serialization_context # => {\"id\":1,\"first_name\":\"Jon\"} Direct including types Athena::Serializer::ExclusionStrategies::Disjunct Athena::Serializer::ExclusionStrategies::Groups Athena::Serializer::ExclusionStrategies::Version Methods abstract #skip_property? ( metadata : ASR::PropertyMetadataBase , context : ASR::Context ) : Bool Returns true if a property should NOT be (de)serialized.","title":"ExclusionStrategyInterface"},{"location":"Serializer/ExclusionStrategies/ExclusionStrategyInterface/#Athena::Serializer::ExclusionStrategies::ExclusionStrategyInterface","text":"Represents a specific exclusion strategy. Custom logic can be implemented by defining a type with this interface. It can then be used via ASR::Context#add_exclusion_strategy .","title":"ExclusionStrategyInterface"},{"location":"Serializer/ExclusionStrategies/ExclusionStrategyInterface/#Athena::Serializer::ExclusionStrategies::ExclusionStrategyInterface--example","text":"struct OddNumberExclusionStrategy include Athena :: Serializer :: ExclusionStrategies :: ExclusionStrategyInterface # :inherit: # # Skips serializing odd numbered values def skip_property? ( metadata : ASR :: PropertyMetadataBase , context : ASR :: Context ) : Bool # Don't skip if the value is nil return false unless value = ( metadata . value ) # Only skip on serialization, if the value is an number, and if it's odd. context . is_a? ( ASR :: SerializationContext ) && value . is_a? ( Number ) && value . odd? end end serialization_context = ASR :: SerializationContext . new serialization_context . add_exclusion_strategy OddNumberExclusionStrategy . new deserialization_context = ASR :: DeserializationContext . new deserialization_context . add_exclusion_strategy OddNumberExclusionStrategy . new record Values , one : Int32 = 1 , two : Int32 = 2 , three : Int32 = 3 do include ASR :: Serializable end ASR . serializer . serialize Values . new , :json , serialization_context # => {\"two\":2} ASR . serializer . deserialize Values , %({\"one\":4,\"two\":5,\"three\":6}) , :json , deserialization_context # => Values(@one=4, @three=6, @two=5)","title":"Example"},{"location":"Serializer/ExclusionStrategies/ExclusionStrategyInterface/#Athena::Serializer::ExclusionStrategies::ExclusionStrategyInterface--annotation-configurations","text":"Custom annotations can be defined using Athena::Config.configuration_annotation . These annotations will be exposed at runtime as part of the properties' metadata within exclusion strategies via ASR::PropertyMetadata#annotation_configurations . The main purpose of this is to allow for more advanced annotation based exclusion strategies. # Define an annotation called `IsActiveProperty` that accepts an optional `active` field. ACF . configuration_annotation IsActiveProperty , active : Bool = true # Define an exclusion strategy that should skip \"inactive\" properties. struct ActivePropertyExclusionStrategy include Athena :: Serializer :: ExclusionStrategies :: ExclusionStrategyInterface # :inherit: def skip_property? ( metadata : ASR :: PropertyMetadataBase , context : ASR :: Context ) : Bool # Don't skip on deserialization. return false if context . direction . deserialization? ann_configs = metadata . annotation_configurations # Skip if the property has the annotation and it's \"inactive\". ann_configs . has? ( IsActiveProperty ) && ! ann_configs [ IsActiveProperty ]. active end end record Example , id : Int32 , first_name : String , last_name : String , zip_code : Int32 do include ASR :: Serializable @[ IsActiveProperty ] @first_name : String @[ IsActiveProperty ( active : false ) ] @last_name : String # Can also be defined as a positional argument. @[ IsActiveProperty ( false ) ] @zip_code : Int32 end serialization_context = ASR :: SerializationContext . new serialization_context . add_exclusion_strategy ActivePropertyExclusionStrategy . new ASR . serializer . serialize Example . new ( 1 , \"Jon\" , \"Snow\" , 90210 ), :json , serialization_context # => {\"id\":1,\"first_name\":\"Jon\"}","title":"Annotation Configurations"},{"location":"Serializer/ExclusionStrategies/ExclusionStrategyInterface/#direct-including-types","text":"Athena::Serializer::ExclusionStrategies::Disjunct Athena::Serializer::ExclusionStrategies::Groups Athena::Serializer::ExclusionStrategies::Version","title":"Direct including types"},{"location":"Serializer/ExclusionStrategies/ExclusionStrategyInterface/#methods","text":"","title":"Methods"},{"location":"Serializer/ExclusionStrategies/ExclusionStrategyInterface/#Athena::Serializer::ExclusionStrategies::ExclusionStrategyInterface#skip_property?(metadata,context)","text":"Returns true if a property should NOT be (de)serialized.","title":"#skip_property?"},{"location":"Serializer/ExclusionStrategies/Groups/","text":"struct Athena::Serializer::ExclusionStrategies::Groups inherits Struct Allows creating different views of your objects by limiting which properties get serialized, based on the group(s) each property is a part of. It is enabled by default when using ASR::Context#groups= . class Example include ASR :: Serializable def initialize ; end @[ ASRA :: Groups ( \"list\" , \"details\" ) ] property id : Int64 = 1 @[ ASRA :: Groups ( \"list\" , \"details\" ) ] property title : String = \"TITLE\" @[ ASRA :: Groups ( \"list\" ) ] property comment_summaries : Array ( String ) = [ \"Sentence 1.\" , \"Sentence 2.\" ] @[ ASRA :: Groups ( \"details\" ) ] property comments : Array ( String ) = [ \"Sentence 1. Another sentence.\" , \"Sentence 2. Some other stuff.\" ] # Properties not explicitly given a group are added to the `\"default\"` group. property created_at : Time = Time . utc ( 2019 , 1 , 1 ) property updated_at : Time ? end obj = Example . new ASR . serializer . serialize obj , :json , ASR :: SerializationContext . new . groups = [ \"list\" ] # => {\"id\":1,\"title\":\"TITLE\",\"comment_summaries\":[\"Sentence 1.\",\"Sentence 2.\"]} ASR . serializer . serialize obj , :json , ASR :: SerializationContext . new . groups = [ \"details\" ] # => {\"id\":1,\"title\":\"TITLE\",\"comments\":[\"Sentence 1. Another sentence.\",\"Sentence 2. Some other stuff.\"]} ASR . serializer . serialize obj , :json , ASR :: SerializationContext . new . groups = [ \"list\" , \"default\" ] # => {\"id\":1,\"title\":\"TITLE\",\"comment_summaries\":[\"Sentence 1.\",\"Sentence 2.\"],\"created_at\":\"2019-01-01T00:00:00Z\"} Included modules Athena::Serializer::ExclusionStrategies::ExclusionStrategyInterface Class methods .new ( groups : Array ( String )) .new ( * groups : String ) Methods #skip_property? ( metadata : ASR::PropertyMetadataBase , context : ASR::Context ) : Bool Returns true if a property should NOT be (de)serialized.","title":"Groups"},{"location":"Serializer/ExclusionStrategies/Groups/#Athena::Serializer::ExclusionStrategies::Groups","text":"Allows creating different views of your objects by limiting which properties get serialized, based on the group(s) each property is a part of. It is enabled by default when using ASR::Context#groups= . class Example include ASR :: Serializable def initialize ; end @[ ASRA :: Groups ( \"list\" , \"details\" ) ] property id : Int64 = 1 @[ ASRA :: Groups ( \"list\" , \"details\" ) ] property title : String = \"TITLE\" @[ ASRA :: Groups ( \"list\" ) ] property comment_summaries : Array ( String ) = [ \"Sentence 1.\" , \"Sentence 2.\" ] @[ ASRA :: Groups ( \"details\" ) ] property comments : Array ( String ) = [ \"Sentence 1. Another sentence.\" , \"Sentence 2. Some other stuff.\" ] # Properties not explicitly given a group are added to the `\"default\"` group. property created_at : Time = Time . utc ( 2019 , 1 , 1 ) property updated_at : Time ? end obj = Example . new ASR . serializer . serialize obj , :json , ASR :: SerializationContext . new . groups = [ \"list\" ] # => {\"id\":1,\"title\":\"TITLE\",\"comment_summaries\":[\"Sentence 1.\",\"Sentence 2.\"]} ASR . serializer . serialize obj , :json , ASR :: SerializationContext . new . groups = [ \"details\" ] # => {\"id\":1,\"title\":\"TITLE\",\"comments\":[\"Sentence 1. Another sentence.\",\"Sentence 2. Some other stuff.\"]} ASR . serializer . serialize obj , :json , ASR :: SerializationContext . new . groups = [ \"list\" , \"default\" ] # => {\"id\":1,\"title\":\"TITLE\",\"comment_summaries\":[\"Sentence 1.\",\"Sentence 2.\"],\"created_at\":\"2019-01-01T00:00:00Z\"}","title":"Groups"},{"location":"Serializer/ExclusionStrategies/Groups/#included-modules","text":"Athena::Serializer::ExclusionStrategies::ExclusionStrategyInterface","title":"Included modules"},{"location":"Serializer/ExclusionStrategies/Groups/#class-methods","text":"","title":"Class methods"},{"location":"Serializer/ExclusionStrategies/Groups/#Athena::Serializer::ExclusionStrategies::Groups.new(groups)","text":"","title":".new"},{"location":"Serializer/ExclusionStrategies/Groups/#methods","text":"","title":"Methods"},{"location":"Serializer/ExclusionStrategies/Groups/#Athena::Serializer::ExclusionStrategies::Groups#skip_property?(metadata,context)","text":"Returns true if a property should NOT be (de)serialized.","title":"#skip_property?"},{"location":"Serializer/ExclusionStrategies/Version/","text":"struct Athena::Serializer::ExclusionStrategies::Version inherits Struct Serialize properties based on a SemanticVersion string. It is enabled by default when using ASR::Context#version= . class Example include ASR :: Serializable def initialize ; end @[ ASRA :: Until ( \"1.0.0\" ) ] property name : String = \"Legacy Name\" @[ ASRA :: Since ( \"1.1.0\" ) ] property name2 : String = \"New Name\" end obj = Example . new ASR . serializer . serialize obj , :json , ASR :: SerializationContext . new . version = \"0.30.0\" # => {\"name\":\"Legacy Name\"} ASR . serializer . serialize obj , :json , ASR :: SerializationContext . new . version = \"1.2.0\" # => {\"name2\":\"New Name\"} Included modules Athena::Serializer::ExclusionStrategies::ExclusionStrategyInterface Class methods .new ( version : SemanticVersion ) Methods #skip_property? ( metadata : ASR::PropertyMetadataBase , context : ASR::Context ) : Bool Returns true if a property should NOT be (de)serialized. #version : SemanticVersion","title":"Version"},{"location":"Serializer/ExclusionStrategies/Version/#Athena::Serializer::ExclusionStrategies::Version","text":"Serialize properties based on a SemanticVersion string. It is enabled by default when using ASR::Context#version= . class Example include ASR :: Serializable def initialize ; end @[ ASRA :: Until ( \"1.0.0\" ) ] property name : String = \"Legacy Name\" @[ ASRA :: Since ( \"1.1.0\" ) ] property name2 : String = \"New Name\" end obj = Example . new ASR . serializer . serialize obj , :json , ASR :: SerializationContext . new . version = \"0.30.0\" # => {\"name\":\"Legacy Name\"} ASR . serializer . serialize obj , :json , ASR :: SerializationContext . new . version = \"1.2.0\" # => {\"name2\":\"New Name\"}","title":"Version"},{"location":"Serializer/ExclusionStrategies/Version/#included-modules","text":"Athena::Serializer::ExclusionStrategies::ExclusionStrategyInterface","title":"Included modules"},{"location":"Serializer/ExclusionStrategies/Version/#class-methods","text":"","title":"Class methods"},{"location":"Serializer/ExclusionStrategies/Version/#Athena::Serializer::ExclusionStrategies::Version.new(version)","text":"","title":".new"},{"location":"Serializer/ExclusionStrategies/Version/#methods","text":"","title":"Methods"},{"location":"Serializer/ExclusionStrategies/Version/#Athena::Serializer::ExclusionStrategies::Version#skip_property?(metadata,context)","text":"Returns true if a property should NOT be (de)serialized.","title":"#skip_property?"},{"location":"Serializer/ExclusionStrategies/Version/#Athena::Serializer::ExclusionStrategies::Version#version()","text":"","title":"#version"},{"location":"Serializer/Format/","text":"enum Athena::Serializer::Format The built-in supported formats. Members JSON = 0 YAML = 1 Methods #deserialization_visitor Returns the ASR::Visitors::DeserializationVisitorInterface related to self . #json? #serialization_visitor Returns the ASR::Visitors::SerializationVisitorInterface related to self . #yaml?","title":"Format"},{"location":"Serializer/Format/#Athena::Serializer::Format","text":"The built-in supported formats.","title":"Format"},{"location":"Serializer/Format/#members","text":"","title":"Members"},{"location":"Serializer/Format/#Athena::Serializer::Format::JSON","text":"","title":"JSON"},{"location":"Serializer/Format/#Athena::Serializer::Format::YAML","text":"","title":"YAML"},{"location":"Serializer/Format/#methods","text":"","title":"Methods"},{"location":"Serializer/Format/#Athena::Serializer::Format#deserialization_visitor()","text":"Returns the ASR::Visitors::DeserializationVisitorInterface related to self .","title":"#deserialization_visitor"},{"location":"Serializer/Format/#Athena::Serializer::Format#json?()","text":"","title":"#json?"},{"location":"Serializer/Format/#Athena::Serializer::Format#serialization_visitor()","text":"Returns the ASR::Visitors::SerializationVisitorInterface related to self .","title":"#serialization_visitor"},{"location":"Serializer/Format/#Athena::Serializer::Format#yaml?()","text":"","title":"#yaml?"},{"location":"Serializer/InstantiateObjectConstructor/","text":"struct Athena::Serializer::InstantiateObjectConstructor inherits Struct Default ASR::ObjectConstructorInterface implementation. Directly instantiates the object via a custom initializer added by ASR::Serializable . Included modules Athena::Serializer::ObjectConstructorInterface Class methods .new Methods #construct ( navigator : ASR::Navigators::DeserializationNavigatorInterface , properties : Array ( PropertyMetadataBase ), data : ASR::Any , type ) Creates an instance of type and applies the provided properties onto it, with the provided data .","title":"InstantiateObjectConstructor"},{"location":"Serializer/InstantiateObjectConstructor/#Athena::Serializer::InstantiateObjectConstructor","text":"Default ASR::ObjectConstructorInterface implementation. Directly instantiates the object via a custom initializer added by ASR::Serializable .","title":"InstantiateObjectConstructor"},{"location":"Serializer/InstantiateObjectConstructor/#included-modules","text":"Athena::Serializer::ObjectConstructorInterface","title":"Included modules"},{"location":"Serializer/InstantiateObjectConstructor/#class-methods","text":"","title":"Class methods"},{"location":"Serializer/InstantiateObjectConstructor/#Athena::Serializer::InstantiateObjectConstructor.new()","text":"","title":".new"},{"location":"Serializer/InstantiateObjectConstructor/#methods","text":"","title":"Methods"},{"location":"Serializer/InstantiateObjectConstructor/#Athena::Serializer::InstantiateObjectConstructor#construct(navigator,properties,data,type)","text":"Creates an instance of type and applies the provided properties onto it, with the provided data .","title":"#construct"},{"location":"Serializer/Model/","text":"module Athena::Serializer::Model Used to denote a type that is (de)serializable. This module can be used to make the compiler happy in some situations, it doesn't do anything on its own. You most likely want to use ASR::Serializable instead. require \"athena-serializer\" abstract struct BaseModel # `ASR::Model` is needed here to ensure typings are correct for the deserialization process. # Child types should still include `ASR::Serializable`. include ASR :: Model end record ModelOne < BaseModel , id : Int32 , name : String do include ASR :: Serializable end record ModelTwo < BaseModel , id : Int32 , name : String do include ASR :: Serializable end record Unionable , type : BaseModel . class","title":"Model"},{"location":"Serializer/Model/#Athena::Serializer::Model","text":"Used to denote a type that is (de)serializable. This module can be used to make the compiler happy in some situations, it doesn't do anything on its own. You most likely want to use ASR::Serializable instead. require \"athena-serializer\" abstract struct BaseModel # `ASR::Model` is needed here to ensure typings are correct for the deserialization process. # Child types should still include `ASR::Serializable`. include ASR :: Model end record ModelOne < BaseModel , id : Int32 , name : String do include ASR :: Serializable end record ModelTwo < BaseModel , id : Int32 , name : String do include ASR :: Serializable end record Unionable , type : BaseModel . class","title":"Model"},{"location":"Serializer/Navigators/","text":"module Athena::Serializer::Navigators","title":"Navigators"},{"location":"Serializer/Navigators/#Athena::Serializer::Navigators","text":"","title":"Navigators"},{"location":"Serializer/Navigators/DeserializationNavigator/","text":"struct Athena::Serializer::Navigators::DeserializationNavigator inherits Struct Included modules Athena::Serializer::Navigators::DeserializationNavigatorInterface Class methods .new ( visitor : ASR::Visitors::DeserializationVisitorInterface , context : ASR::DeserializationContext , object_constructor : ASR::ObjectConstructorInterface ) Methods #accept ( type : T . class , data : ASR::Any ) forall T","title":"DeserializationNavigator"},{"location":"Serializer/Navigators/DeserializationNavigator/#Athena::Serializer::Navigators::DeserializationNavigator","text":"","title":"DeserializationNavigator"},{"location":"Serializer/Navigators/DeserializationNavigator/#included-modules","text":"Athena::Serializer::Navigators::DeserializationNavigatorInterface","title":"Included modules"},{"location":"Serializer/Navigators/DeserializationNavigator/#class-methods","text":"","title":"Class methods"},{"location":"Serializer/Navigators/DeserializationNavigator/#Athena::Serializer::Navigators::DeserializationNavigator.new(visitor,context,object_constructor)","text":"","title":".new"},{"location":"Serializer/Navigators/DeserializationNavigator/#methods","text":"","title":"Methods"},{"location":"Serializer/Navigators/DeserializationNavigator/#Athena::Serializer::Navigators::DeserializationNavigator#accept(type,data)","text":"","title":"#accept"},{"location":"Serializer/Navigators/DeserializationNavigatorInterface/","text":"module Athena::Serializer::Navigators::DeserializationNavigatorInterface Direct including types Athena::Serializer::Navigators::DeserializationNavigator Methods abstract #accept ( type : T . class , data : ASR::Any ) forall T","title":"DeserializationNavigatorInterface"},{"location":"Serializer/Navigators/DeserializationNavigatorInterface/#Athena::Serializer::Navigators::DeserializationNavigatorInterface","text":"","title":"DeserializationNavigatorInterface"},{"location":"Serializer/Navigators/DeserializationNavigatorInterface/#direct-including-types","text":"Athena::Serializer::Navigators::DeserializationNavigator","title":"Direct including types"},{"location":"Serializer/Navigators/DeserializationNavigatorInterface/#methods","text":"","title":"Methods"},{"location":"Serializer/Navigators/DeserializationNavigatorInterface/#Athena::Serializer::Navigators::DeserializationNavigatorInterface#accept(type,data)","text":"","title":"#accept"},{"location":"Serializer/Navigators/NavigatorFactory/","text":"struct Athena::Serializer::Navigators::NavigatorFactory inherits Struct Included modules Athena::Serializer::Navigators::NavigatorFactoryInterface Class methods .new ( object_constructor : ASR::ObjectConstructorInterface = ASR :: InstantiateObjectConstructor . new ) Methods #get_deserialization_navigator ( visitor : ASR::Visitors::DeserializationVisitorInterface , context : ASR::DeserializationContext ) : ASR::Navigators::DeserializationNavigatorInterface #get_serialization_navigator ( visitor : ASR::Visitors::SerializationVisitorInterface , context : ASR::SerializationContext ) : ASR::Navigators::SerializationNavigatorInterface","title":"NavigatorFactory"},{"location":"Serializer/Navigators/NavigatorFactory/#Athena::Serializer::Navigators::NavigatorFactory","text":"","title":"NavigatorFactory"},{"location":"Serializer/Navigators/NavigatorFactory/#included-modules","text":"Athena::Serializer::Navigators::NavigatorFactoryInterface","title":"Included modules"},{"location":"Serializer/Navigators/NavigatorFactory/#class-methods","text":"","title":"Class methods"},{"location":"Serializer/Navigators/NavigatorFactory/#Athena::Serializer::Navigators::NavigatorFactory.new(object_constructor)","text":"","title":".new"},{"location":"Serializer/Navigators/NavigatorFactory/#methods","text":"","title":"Methods"},{"location":"Serializer/Navigators/NavigatorFactory/#Athena::Serializer::Navigators::NavigatorFactory#get_deserialization_navigator(visitor,context)","text":"","title":"#get_deserialization_navigator"},{"location":"Serializer/Navigators/NavigatorFactory/#Athena::Serializer::Navigators::NavigatorFactory#get_serialization_navigator(visitor,context)","text":"","title":"#get_serialization_navigator"},{"location":"Serializer/Navigators/NavigatorFactoryInterface/","text":"module Athena::Serializer::Navigators::NavigatorFactoryInterface Direct including types Athena::Serializer::Navigators::NavigatorFactory Methods abstract #get_deserialization_navigator ( visitor : ASR::Visitors::DeserializationVisitorInterface , context : ASR::DeserializationContext ) : ASR::Navigators::DeserializationNavigatorInterface abstract #get_serialization_navigator ( visitor : ASR::Visitors::SerializationVisitorInterface , context : ASR::SerializationContext ) : ASR::Navigators::SerializationNavigatorInterface","title":"NavigatorFactoryInterface"},{"location":"Serializer/Navigators/NavigatorFactoryInterface/#Athena::Serializer::Navigators::NavigatorFactoryInterface","text":"","title":"NavigatorFactoryInterface"},{"location":"Serializer/Navigators/NavigatorFactoryInterface/#direct-including-types","text":"Athena::Serializer::Navigators::NavigatorFactory","title":"Direct including types"},{"location":"Serializer/Navigators/NavigatorFactoryInterface/#methods","text":"","title":"Methods"},{"location":"Serializer/Navigators/NavigatorFactoryInterface/#Athena::Serializer::Navigators::NavigatorFactoryInterface#get_deserialization_navigator(visitor,context)","text":"","title":"#get_deserialization_navigator"},{"location":"Serializer/Navigators/NavigatorFactoryInterface/#Athena::Serializer::Navigators::NavigatorFactoryInterface#get_serialization_navigator(visitor,context)","text":"","title":"#get_serialization_navigator"},{"location":"Serializer/Navigators/SerializationNavigator/","text":"struct Athena::Serializer::Navigators::SerializationNavigator inherits Struct Included modules Athena::Serializer::Navigators::SerializationNavigatorInterface Class methods .new ( visitor : ASR::Visitors::SerializationVisitorInterface , context : ASR::SerializationContext ) Methods #accept ( data : ASR::Model ) : Nil #accept ( data : _ ) : Nil","title":"SerializationNavigator"},{"location":"Serializer/Navigators/SerializationNavigator/#Athena::Serializer::Navigators::SerializationNavigator","text":"","title":"SerializationNavigator"},{"location":"Serializer/Navigators/SerializationNavigator/#included-modules","text":"Athena::Serializer::Navigators::SerializationNavigatorInterface","title":"Included modules"},{"location":"Serializer/Navigators/SerializationNavigator/#class-methods","text":"","title":"Class methods"},{"location":"Serializer/Navigators/SerializationNavigator/#Athena::Serializer::Navigators::SerializationNavigator.new(visitor,context)","text":"","title":".new"},{"location":"Serializer/Navigators/SerializationNavigator/#methods","text":"","title":"Methods"},{"location":"Serializer/Navigators/SerializationNavigator/#Athena::Serializer::Navigators::SerializationNavigator#accept(data)","text":"","title":"#accept"},{"location":"Serializer/Navigators/SerializationNavigator/#Athena::Serializer::Navigators::SerializationNavigator#accept(data)","text":"","title":"#accept"},{"location":"Serializer/Navigators/SerializationNavigatorInterface/","text":"module Athena::Serializer::Navigators::SerializationNavigatorInterface Direct including types Athena::Serializer::Navigators::SerializationNavigator Methods abstract #accept ( data : ASR::Model ) : Nil abstract #accept ( data : _ ) : Nil","title":"SerializationNavigatorInterface"},{"location":"Serializer/Navigators/SerializationNavigatorInterface/#Athena::Serializer::Navigators::SerializationNavigatorInterface","text":"","title":"SerializationNavigatorInterface"},{"location":"Serializer/Navigators/SerializationNavigatorInterface/#direct-including-types","text":"Athena::Serializer::Navigators::SerializationNavigator","title":"Direct including types"},{"location":"Serializer/Navigators/SerializationNavigatorInterface/#methods","text":"","title":"Methods"},{"location":"Serializer/Navigators/SerializationNavigatorInterface/#Athena::Serializer::Navigators::SerializationNavigatorInterface#accept(data)","text":"","title":"#accept"},{"location":"Serializer/Navigators/SerializationNavigatorInterface/#Athena::Serializer::Navigators::SerializationNavigatorInterface#accept(data)","text":"","title":"#accept"},{"location":"Serializer/ObjectConstructorInterface/","text":"module Athena::Serializer::ObjectConstructorInterface Determines how a new object is constructed during deserialization. By default it is directly instantiated via .new as part of ASR::InstantiateObjectConstructor . However custom constructors can be defined. A use case could be retrieving the object from the database as part of a PUT request in order to apply the deserialized data onto it. This would allow it to retain the PK, any timestamps, or ASRA::ReadOnly values. Direct including types Athena::Serializer::InstantiateObjectConstructor Methods abstract #construct ( navigator : ASR::Navigators::DeserializationNavigatorInterface , properties : Array ( PropertyMetadataBase ), data : ASR::Any , type ) Creates an instance of type and applies the provided properties onto it, with the provided data .","title":"ObjectConstructorInterface"},{"location":"Serializer/ObjectConstructorInterface/#Athena::Serializer::ObjectConstructorInterface","text":"Determines how a new object is constructed during deserialization. By default it is directly instantiated via .new as part of ASR::InstantiateObjectConstructor . However custom constructors can be defined. A use case could be retrieving the object from the database as part of a PUT request in order to apply the deserialized data onto it. This would allow it to retain the PK, any timestamps, or ASRA::ReadOnly values.","title":"ObjectConstructorInterface"},{"location":"Serializer/ObjectConstructorInterface/#direct-including-types","text":"Athena::Serializer::InstantiateObjectConstructor","title":"Direct including types"},{"location":"Serializer/ObjectConstructorInterface/#methods","text":"","title":"Methods"},{"location":"Serializer/ObjectConstructorInterface/#Athena::Serializer::ObjectConstructorInterface#construct(navigator,properties,data,type)","text":"Creates an instance of type and applies the provided properties onto it, with the provided data .","title":"#construct"},{"location":"Serializer/PropertyMetadata/","text":"struct Athena::Serializer::PropertyMetadata(IvarType, ValueType, ClassType) inherits Struct Stores metadata related to a specific property. This includes its name (internal and external), value, versions/groups, and any aliases. Included modules Athena::Serializer::PropertyMetadataBase Class methods .new ( name : String , external_name : String , annotation_configurations : ACF::AnnotationConfigurations , value : ValueType = nil , skip_when_empty : Bool = false , groups : Array ( String ) = [ \"default\" ] , aliases : Array ( String ) = [] of String , since_version : SemanticVersion? = nil , until_version : SemanticVersion? = nil , type : IvarType . class = IvarType , class __arg0 : ClassType . class = ClassType ) Methods #aliases : Array ( String ) Deserialize this property from the property's name or any name in aliases . See ASRA::Name . #annotation_configurations : ACF::AnnotationConfigurations Returns annotations configurations registered via Athena::Config.configuration_annotation and applied to this property. These configurations could then be accessed within an ART::ExclusionStrategies::ExclusionStrategyInterface . #class : ClassType . class The class that the property is part of. #external_name : String The name that should be used for serialization/deserialization. #groups : Array ( String ) The serialization groups this property belongs to. See ASR::ExclusionStrategies::Groups . #name : String The name of the property. #since_version : SemanticVersion? Represents the first version this property is available. See ASR::ExclusionStrategies::Version . #since_version= ( since_version : SemanticVersion? ) Represents the first version this property is available. See ASR::ExclusionStrategies::Version . #skip_when_empty? : Bool If this property should not be serialized if it is empty. See ASRA::SkipWhenEmpty . #type : IvarType . class The type of the property. #until_version : SemanticVersion? Represents the last version this property was available. See ASR::ExclusionStrategies::Version . #until_version= ( until_version : SemanticVersion? ) Represents the last version this property was available. See ASR::ExclusionStrategies::Version . #value : ValueType The value of the property (when serializing).","title":"PropertyMetadata"},{"location":"Serializer/PropertyMetadata/#Athena::Serializer::PropertyMetadata","text":"Stores metadata related to a specific property. This includes its name (internal and external), value, versions/groups, and any aliases.","title":"PropertyMetadata"},{"location":"Serializer/PropertyMetadata/#included-modules","text":"Athena::Serializer::PropertyMetadataBase","title":"Included modules"},{"location":"Serializer/PropertyMetadata/#class-methods","text":"","title":"Class methods"},{"location":"Serializer/PropertyMetadata/#Athena::Serializer::PropertyMetadata.new(name,external_name,annotation_configurations,value,skip_when_empty,groups,aliases,since_version,until_version,type,class)","text":"","title":".new"},{"location":"Serializer/PropertyMetadata/#methods","text":"","title":"Methods"},{"location":"Serializer/PropertyMetadata/#Athena::Serializer::PropertyMetadata#aliases()","text":"Deserialize this property from the property's name or any name in aliases . See ASRA::Name .","title":"#aliases"},{"location":"Serializer/PropertyMetadata/#Athena::Serializer::PropertyMetadata#annotation_configurations()","text":"Returns annotations configurations registered via Athena::Config.configuration_annotation and applied to this property. These configurations could then be accessed within an ART::ExclusionStrategies::ExclusionStrategyInterface .","title":"#annotation_configurations"},{"location":"Serializer/PropertyMetadata/#Athena::Serializer::PropertyMetadata#class()","text":"The class that the property is part of.","title":"#class"},{"location":"Serializer/PropertyMetadata/#Athena::Serializer::PropertyMetadata#external_name()","text":"The name that should be used for serialization/deserialization.","title":"#external_name"},{"location":"Serializer/PropertyMetadata/#Athena::Serializer::PropertyMetadata#groups()","text":"The serialization groups this property belongs to. See ASR::ExclusionStrategies::Groups .","title":"#groups"},{"location":"Serializer/PropertyMetadata/#Athena::Serializer::PropertyMetadata#name()","text":"The name of the property.","title":"#name"},{"location":"Serializer/PropertyMetadata/#Athena::Serializer::PropertyMetadata#since_version()","text":"Represents the first version this property is available. See ASR::ExclusionStrategies::Version .","title":"#since_version"},{"location":"Serializer/PropertyMetadata/#Athena::Serializer::PropertyMetadata#since_version=(since_version)","text":"Represents the first version this property is available. See ASR::ExclusionStrategies::Version .","title":"#since_version="},{"location":"Serializer/PropertyMetadata/#Athena::Serializer::PropertyMetadata#skip_when_empty?()","text":"If this property should not be serialized if it is empty. See ASRA::SkipWhenEmpty .","title":"#skip_when_empty?"},{"location":"Serializer/PropertyMetadata/#Athena::Serializer::PropertyMetadata#type()","text":"The type of the property.","title":"#type"},{"location":"Serializer/PropertyMetadata/#Athena::Serializer::PropertyMetadata#until_version()","text":"Represents the last version this property was available. See ASR::ExclusionStrategies::Version .","title":"#until_version"},{"location":"Serializer/PropertyMetadata/#Athena::Serializer::PropertyMetadata#until_version=(until_version)","text":"Represents the last version this property was available. See ASR::ExclusionStrategies::Version .","title":"#until_version="},{"location":"Serializer/PropertyMetadata/#Athena::Serializer::PropertyMetadata#value()","text":"The value of the property (when serializing).","title":"#value"},{"location":"Serializer/PropertyMetadataBase/","text":"module Athena::Serializer::PropertyMetadataBase Parent type of a property metadata just used for typing. See ASR::PropertyMetadata . Direct including types Athena::Serializer::PropertyMetadata(IvarType, ValueType, ClassType)","title":"PropertyMetadataBase"},{"location":"Serializer/PropertyMetadataBase/#Athena::Serializer::PropertyMetadataBase","text":"Parent type of a property metadata just used for typing. See ASR::PropertyMetadata .","title":"PropertyMetadataBase"},{"location":"Serializer/PropertyMetadataBase/#direct-including-types","text":"Athena::Serializer::PropertyMetadata(IvarType, ValueType, ClassType)","title":"Direct including types"},{"location":"Serializer/Serializable/","text":"module Athena::Serializer::Serializable Adds the necessary methods to a struct / class to allow for (de)serialization of that type. require \"athena-serializer\" record Example , id : Int32 , name : String do include ASR :: Serializable end obj = ASR . serializer . deserialize Example , %({\"id\":1,\"name\":\"George\"}) , :json obj # => Example(@id=1, @name=\"George\") ASR . serializer . serialize obj , :yaml # => # --- # id: 1 # name: George","title":"Serializable"},{"location":"Serializer/Serializable/#Athena::Serializer::Serializable","text":"Adds the necessary methods to a struct / class to allow for (de)serialization of that type. require \"athena-serializer\" record Example , id : Int32 , name : String do include ASR :: Serializable end obj = ASR . serializer . deserialize Example , %({\"id\":1,\"name\":\"George\"}) , :json obj # => Example(@id=1, @name=\"George\") ASR . serializer . serialize obj , :yaml # => # --- # id: 1 # name: George","title":"Serializable"},{"location":"Serializer/SerializationContext/","text":"class Athena::Serializer::SerializationContext inherits Athena::Serializer::Context The ASR::Context specific to serialization. Allows specifying if nil values should be serialized. Methods #direction : ASR::Context::Direction Returns which (de)serialization action self represents. #emit_nil= ( emit_nil : Bool ) If nil values should be serialized. #emit_nil? : Bool If nil values should be serialized.","title":"SerializationContext"},{"location":"Serializer/SerializationContext/#Athena::Serializer::SerializationContext","text":"The ASR::Context specific to serialization. Allows specifying if nil values should be serialized.","title":"SerializationContext"},{"location":"Serializer/SerializationContext/#methods","text":"","title":"Methods"},{"location":"Serializer/SerializationContext/#Athena::Serializer::SerializationContext#direction()","text":"Returns which (de)serialization action self represents.","title":"#direction"},{"location":"Serializer/SerializationContext/#Athena::Serializer::SerializationContext#emit_nil=(emit_nil)","text":"If nil values should be serialized.","title":"#emit_nil="},{"location":"Serializer/SerializationContext/#Athena::Serializer::SerializationContext#emit_nil?()","text":"If nil values should be serialized.","title":"#emit_nil?"},{"location":"Serializer/Serializer/","text":"struct Athena::Serializer::Serializer inherits Struct Default implementation of ASR::SerializerInterface . Provides the main API used to (de)serialize objects. Custom formats can be implemented by creating the required visitors for that type, then overriding #get_deserialization_visitor_class and #get_serialization_visitor_class . # Redefine the visitor class getters in order to first check for custom formats. # This assumes these visitor types are defined, with the proper logic to handle # the (de)serialization process. struct Athena::Serializer:: Serializer protected def get_deserialization_visitor_class ( format : ASR :: Format | String ) return MessagePackDeserializationVisitor if format == \"message_pack\" previous_def end protected def get_serialization_visitor_class ( format : ASR :: Format | String ) return MessagePackSerializationVisitor if format == \"message_pack\" previous_def end end Included modules Athena::Serializer::SerializerInterface Class methods .new ( navigator_factory : ASR::Navigators::NavigatorFactoryInterface = ASR :: Navigators :: NavigatorFactory . new ) Methods #deserialize ( type : _ , input_data : String | IO , format : ASR::Format | String , context : ASR::DeserializationContext = ASR :: DeserializationContext . new ) :inherit: #serialize ( data : _ , format : ASR::Format | String , io : IO , context : ASR::SerializationContext = ASR :: SerializationContext . new , ** named_args ) : Nil Serializes the provided data into format writing it to the provided io , optionally with the provided context .= #serialize ( data : _ , format : ASR::Format | String , context : ASR::SerializationContext = ASR :: SerializationContext . new , ** named_args ) : String Serializes the provided data into format , optionally with the provided context .","title":"Serializer"},{"location":"Serializer/Serializer/#Athena::Serializer::Serializer","text":"Default implementation of ASR::SerializerInterface . Provides the main API used to (de)serialize objects. Custom formats can be implemented by creating the required visitors for that type, then overriding #get_deserialization_visitor_class and #get_serialization_visitor_class . # Redefine the visitor class getters in order to first check for custom formats. # This assumes these visitor types are defined, with the proper logic to handle # the (de)serialization process. struct Athena::Serializer:: Serializer protected def get_deserialization_visitor_class ( format : ASR :: Format | String ) return MessagePackDeserializationVisitor if format == \"message_pack\" previous_def end protected def get_serialization_visitor_class ( format : ASR :: Format | String ) return MessagePackSerializationVisitor if format == \"message_pack\" previous_def end end","title":"Serializer"},{"location":"Serializer/Serializer/#included-modules","text":"Athena::Serializer::SerializerInterface","title":"Included modules"},{"location":"Serializer/Serializer/#class-methods","text":"","title":"Class methods"},{"location":"Serializer/Serializer/#Athena::Serializer::Serializer.new(navigator_factory)","text":"","title":".new"},{"location":"Serializer/Serializer/#methods","text":"","title":"Methods"},{"location":"Serializer/Serializer/#Athena::Serializer::Serializer#deserialize(type,input_data,format,context)","text":":inherit:","title":"#deserialize"},{"location":"Serializer/Serializer/#Athena::Serializer::Serializer#serialize(data,format,io,context,**named_args)","text":"Serializes the provided data into format writing it to the provided io , optionally with the provided context .=","title":"#serialize"},{"location":"Serializer/SerializerInterface/","text":"module Athena::Serializer::SerializerInterface The main entrypoint of Athena::Serializer . Direct including types Athena::Serializer::Serializer Methods abstract #deserialize ( type : ASR :: Model . class , data : String | IO , format : ASR::Format | String , context : ASR::DeserializationContext = ASR :: DeserializationContext . new ) Deserializes the provided input_data in the provided format into an instance of type , optionally with the provided context . abstract #serialize ( data : _ , format : ASR::Format | String , io : IO , context : ASR::SerializationContext = ASR :: SerializationContext . new , ** named_args ) : Nil Serializes the provided data into format writing it to the provided io , optionally with the provided context .= abstract #serialize ( data : _ , format : ASR::Format | String , context : ASR::SerializationContext = ASR :: SerializationContext . new , ** named_args ) : String Serializes the provided data into format , optionally with the provided context .","title":"SerializerInterface"},{"location":"Serializer/SerializerInterface/#Athena::Serializer::SerializerInterface","text":"The main entrypoint of Athena::Serializer .","title":"SerializerInterface"},{"location":"Serializer/SerializerInterface/#direct-including-types","text":"Athena::Serializer::Serializer","title":"Direct including types"},{"location":"Serializer/SerializerInterface/#methods","text":"","title":"Methods"},{"location":"Serializer/SerializerInterface/#Athena::Serializer::SerializerInterface#deserialize(type,data,format,context)","text":"Deserializes the provided input_data in the provided format into an instance of type , optionally with the provided context .","title":"#deserialize"},{"location":"Serializer/SerializerInterface/#Athena::Serializer::SerializerInterface#serialize(data,format,io,context,**named_args)","text":"Serializes the provided data into format writing it to the provided io , optionally with the provided context .=","title":"#serialize"},{"location":"Serializer/Visitors/","text":"module Athena::Serializer::Visitors","title":"Visitors"},{"location":"Serializer/Visitors/#Athena::Serializer::Visitors","text":"","title":"Visitors"},{"location":"Serializer/Visitors/DeserializationVisitor/","text":"abstract class Athena::Serializer::Visitors::DeserializationVisitor inherits Reference Implement deserialization logic based on ASR::Any common to all formats. Included modules Athena::Serializer::Visitors::DeserializationVisitorInterface Direct known subclasses Athena::Serializer::Visitors::JSONDeserializationVisitor Athena::Serializer::Visitors::YAMLDeserializationVisitor Methods #navigator : Athena::Serializer::Navigators::DeserializationNavigatorInterface #navigator= ( navigator : Athena::Serializer::Navigators::DeserializationNavigatorInterface ) #navigator? : Athena::Serializer::Navigators::DeserializationNavigatorInterface? #visit ( type : Nil . class , data : ASR::Any ) : Nil #visit ( type : _ , data : ASR::Any ) #visit ( type : _ , data : _ )","title":"DeserializationVisitor"},{"location":"Serializer/Visitors/DeserializationVisitor/#Athena::Serializer::Visitors::DeserializationVisitor","text":"Implement deserialization logic based on ASR::Any common to all formats.","title":"DeserializationVisitor"},{"location":"Serializer/Visitors/DeserializationVisitor/#included-modules","text":"Athena::Serializer::Visitors::DeserializationVisitorInterface","title":"Included modules"},{"location":"Serializer/Visitors/DeserializationVisitor/#direct-known-subclasses","text":"Athena::Serializer::Visitors::JSONDeserializationVisitor Athena::Serializer::Visitors::YAMLDeserializationVisitor","title":"Direct known subclasses"},{"location":"Serializer/Visitors/DeserializationVisitor/#methods","text":"","title":"Methods"},{"location":"Serializer/Visitors/DeserializationVisitor/#Athena::Serializer::Visitors::DeserializationVisitor#navigator()","text":"","title":"#navigator"},{"location":"Serializer/Visitors/DeserializationVisitor/#Athena::Serializer::Visitors::DeserializationVisitor#navigator=(navigator)","text":"","title":"#navigator="},{"location":"Serializer/Visitors/DeserializationVisitor/#Athena::Serializer::Visitors::DeserializationVisitor#navigator?()","text":"","title":"#navigator?"},{"location":"Serializer/Visitors/DeserializationVisitor/#Athena::Serializer::Visitors::DeserializationVisitor#visit(type,data)","text":"","title":"#visit"},{"location":"Serializer/Visitors/DeserializationVisitor/#Athena::Serializer::Visitors::DeserializationVisitor#visit(type,data)","text":"","title":"#visit"},{"location":"Serializer/Visitors/DeserializationVisitor/#Athena::Serializer::Visitors::DeserializationVisitor#visit(type,data)","text":"","title":"#visit"},{"location":"Serializer/Visitors/DeserializationVisitorInterface/","text":"module Athena::Serializer::Visitors::DeserializationVisitorInterface Direct including types Athena::Serializer::Visitors::DeserializationVisitor Methods abstract #prepare ( data : IO | String ) : ASR::Any abstract #visit ( type : Nil . class , data : ASR::Any ) : Nil abstract #visit ( type : _ , data : ASR::Any ) abstract #visit ( type : _ , data : _ )","title":"DeserializationVisitorInterface"},{"location":"Serializer/Visitors/DeserializationVisitorInterface/#Athena::Serializer::Visitors::DeserializationVisitorInterface","text":"","title":"DeserializationVisitorInterface"},{"location":"Serializer/Visitors/DeserializationVisitorInterface/#direct-including-types","text":"Athena::Serializer::Visitors::DeserializationVisitor","title":"Direct including types"},{"location":"Serializer/Visitors/DeserializationVisitorInterface/#methods","text":"","title":"Methods"},{"location":"Serializer/Visitors/DeserializationVisitorInterface/#Athena::Serializer::Visitors::DeserializationVisitorInterface#prepare(data)","text":"","title":"#prepare"},{"location":"Serializer/Visitors/DeserializationVisitorInterface/#Athena::Serializer::Visitors::DeserializationVisitorInterface#visit(type,data)","text":"","title":"#visit"},{"location":"Serializer/Visitors/DeserializationVisitorInterface/#Athena::Serializer::Visitors::DeserializationVisitorInterface#visit(type,data)","text":"","title":"#visit"},{"location":"Serializer/Visitors/DeserializationVisitorInterface/#Athena::Serializer::Visitors::DeserializationVisitorInterface#visit(type,data)","text":"","title":"#visit"},{"location":"Serializer/Visitors/JSONDeserializationVisitor/","text":"class Athena::Serializer::Visitors::JSONDeserializationVisitor inherits Athena::Serializer::Visitors::DeserializationVisitor Methods #prepare ( input : IO | String ) : ASR::Any","title":"JSONDeserializationVisitor"},{"location":"Serializer/Visitors/JSONDeserializationVisitor/#Athena::Serializer::Visitors::JSONDeserializationVisitor","text":"","title":"JSONDeserializationVisitor"},{"location":"Serializer/Visitors/JSONDeserializationVisitor/#methods","text":"","title":"Methods"},{"location":"Serializer/Visitors/JSONDeserializationVisitor/#Athena::Serializer::Visitors::JSONDeserializationVisitor#prepare(input)","text":"","title":"#prepare"},{"location":"Serializer/Visitors/JSONSerializationVisitor/","text":"class Athena::Serializer::Visitors::JSONSerializationVisitor inherits Reference Included modules Athena::Serializer::Visitors::SerializationVisitorInterface Class methods .new ( io : IO , named_args : NamedTuple ) Methods #finish : Nil #navigator : Athena::Serializer::Navigators::SerializationNavigatorInterface #navigator= ( navigator : Athena::Serializer::Navigators::SerializationNavigatorInterface ) #navigator? : Athena::Serializer::Navigators::SerializationNavigatorInterface? #prepare : Nil #visit ( data : ASR::Any ) : Nil #visit ( data : ASR::Model ) : Nil #visit ( data : UUID ) : Nil #visit ( data : Enum ) : Nil #visit ( data : Time ) : Nil #visit ( data : Enumerable ) : Nil #visit ( data : Hash | NamedTuple ) : Nil #visit ( data : Bool ) : Nil #visit ( data : Number ) : Nil #visit ( data : String | Symbol ) : Nil #visit ( data : Nil ) : Nil #visit ( properties : Array ( PropertyMetadataBase )) : Nil :inherit: #visit ( data : _ ) : Nil","title":"JSONSerializationVisitor"},{"location":"Serializer/Visitors/JSONSerializationVisitor/#Athena::Serializer::Visitors::JSONSerializationVisitor","text":"","title":"JSONSerializationVisitor"},{"location":"Serializer/Visitors/JSONSerializationVisitor/#included-modules","text":"Athena::Serializer::Visitors::SerializationVisitorInterface","title":"Included modules"},{"location":"Serializer/Visitors/JSONSerializationVisitor/#class-methods","text":"","title":"Class methods"},{"location":"Serializer/Visitors/JSONSerializationVisitor/#Athena::Serializer::Visitors::JSONSerializationVisitor.new(io,named_args)","text":"","title":".new"},{"location":"Serializer/Visitors/JSONSerializationVisitor/#methods","text":"","title":"Methods"},{"location":"Serializer/Visitors/JSONSerializationVisitor/#Athena::Serializer::Visitors::JSONSerializationVisitor#finish()","text":"","title":"#finish"},{"location":"Serializer/Visitors/JSONSerializationVisitor/#Athena::Serializer::Visitors::JSONSerializationVisitor#navigator()","text":"","title":"#navigator"},{"location":"Serializer/Visitors/JSONSerializationVisitor/#Athena::Serializer::Visitors::JSONSerializationVisitor#navigator=(navigator)","text":"","title":"#navigator="},{"location":"Serializer/Visitors/JSONSerializationVisitor/#Athena::Serializer::Visitors::JSONSerializationVisitor#navigator?()","text":"","title":"#navigator?"},{"location":"Serializer/Visitors/JSONSerializationVisitor/#Athena::Serializer::Visitors::JSONSerializationVisitor#prepare()","text":"","title":"#prepare"},{"location":"Serializer/Visitors/JSONSerializationVisitor/#Athena::Serializer::Visitors::JSONSerializationVisitor#visit(data)","text":"","title":"#visit"},{"location":"Serializer/Visitors/JSONSerializationVisitor/#Athena::Serializer::Visitors::JSONSerializationVisitor#visit(data)","text":"","title":"#visit"},{"location":"Serializer/Visitors/JSONSerializationVisitor/#Athena::Serializer::Visitors::JSONSerializationVisitor#visit(data)","text":"","title":"#visit"},{"location":"Serializer/Visitors/JSONSerializationVisitor/#Athena::Serializer::Visitors::JSONSerializationVisitor#visit(data)","text":"","title":"#visit"},{"location":"Serializer/Visitors/JSONSerializationVisitor/#Athena::Serializer::Visitors::JSONSerializationVisitor#visit(data)","text":"","title":"#visit"},{"location":"Serializer/Visitors/JSONSerializationVisitor/#Athena::Serializer::Visitors::JSONSerializationVisitor#visit(data)","text":"","title":"#visit"},{"location":"Serializer/Visitors/JSONSerializationVisitor/#Athena::Serializer::Visitors::JSONSerializationVisitor#visit(data)","text":"","title":"#visit"},{"location":"Serializer/Visitors/JSONSerializationVisitor/#Athena::Serializer::Visitors::JSONSerializationVisitor#visit(data)","text":"","title":"#visit"},{"location":"Serializer/Visitors/JSONSerializationVisitor/#Athena::Serializer::Visitors::JSONSerializationVisitor#visit(data)","text":"","title":"#visit"},{"location":"Serializer/Visitors/JSONSerializationVisitor/#Athena::Serializer::Visitors::JSONSerializationVisitor#visit(data)","text":"","title":"#visit"},{"location":"Serializer/Visitors/JSONSerializationVisitor/#Athena::Serializer::Visitors::JSONSerializationVisitor#visit(data)","text":"","title":"#visit"},{"location":"Serializer/Visitors/JSONSerializationVisitor/#Athena::Serializer::Visitors::JSONSerializationVisitor#visit(data)","text":"","title":"#visit"},{"location":"Serializer/Visitors/SerializationVisitorInterface/","text":"module Athena::Serializer::Visitors::SerializationVisitorInterface Direct including types Athena::Serializer::Visitors::JSONSerializationVisitor Athena::Serializer::Visitors::YAMLSerializationVisitor Methods abstract #finish : Nil abstract #prepare : Nil abstract #visit ( data : Array ( ASR::PropertyMetadataBase )) : Nil abstract #visit ( data : Bool ) : Nil abstract #visit ( data : Enum ) : Nil abstract #visit ( data : Hash ) : Nil abstract #visit ( data : Enumerable ) : Nil abstract #visit ( data : NamedTuple ) : Nil abstract #visit ( data : Nil ) : Nil abstract #visit ( data : Number ) : Nil abstract #visit ( data : String ) : Nil abstract #visit ( data : Symbol ) : Nil abstract #visit ( data : Time ) : Nil abstract #visit ( data : UUID ) : Nil abstract #visit ( data : ASR::Any ) : Nil abstract #visit ( data : ASR::Model ) : Nil","title":"SerializationVisitorInterface"},{"location":"Serializer/Visitors/SerializationVisitorInterface/#Athena::Serializer::Visitors::SerializationVisitorInterface","text":"","title":"SerializationVisitorInterface"},{"location":"Serializer/Visitors/SerializationVisitorInterface/#direct-including-types","text":"Athena::Serializer::Visitors::JSONSerializationVisitor Athena::Serializer::Visitors::YAMLSerializationVisitor","title":"Direct including types"},{"location":"Serializer/Visitors/SerializationVisitorInterface/#methods","text":"","title":"Methods"},{"location":"Serializer/Visitors/SerializationVisitorInterface/#Athena::Serializer::Visitors::SerializationVisitorInterface#finish()","text":"","title":"#finish"},{"location":"Serializer/Visitors/SerializationVisitorInterface/#Athena::Serializer::Visitors::SerializationVisitorInterface#prepare()","text":"","title":"#prepare"},{"location":"Serializer/Visitors/SerializationVisitorInterface/#Athena::Serializer::Visitors::SerializationVisitorInterface#visit(data)","text":"","title":"#visit"},{"location":"Serializer/Visitors/SerializationVisitorInterface/#Athena::Serializer::Visitors::SerializationVisitorInterface#visit(data)","text":"","title":"#visit"},{"location":"Serializer/Visitors/SerializationVisitorInterface/#Athena::Serializer::Visitors::SerializationVisitorInterface#visit(data)","text":"","title":"#visit"},{"location":"Serializer/Visitors/SerializationVisitorInterface/#Athena::Serializer::Visitors::SerializationVisitorInterface#visit(data)","text":"","title":"#visit"},{"location":"Serializer/Visitors/SerializationVisitorInterface/#Athena::Serializer::Visitors::SerializationVisitorInterface#visit(data)","text":"","title":"#visit"},{"location":"Serializer/Visitors/SerializationVisitorInterface/#Athena::Serializer::Visitors::SerializationVisitorInterface#visit(data)","text":"","title":"#visit"},{"location":"Serializer/Visitors/SerializationVisitorInterface/#Athena::Serializer::Visitors::SerializationVisitorInterface#visit(data)","text":"","title":"#visit"},{"location":"Serializer/Visitors/SerializationVisitorInterface/#Athena::Serializer::Visitors::SerializationVisitorInterface#visit(data)","text":"","title":"#visit"},{"location":"Serializer/Visitors/SerializationVisitorInterface/#Athena::Serializer::Visitors::SerializationVisitorInterface#visit(data)","text":"","title":"#visit"},{"location":"Serializer/Visitors/SerializationVisitorInterface/#Athena::Serializer::Visitors::SerializationVisitorInterface#visit(data)","text":"","title":"#visit"},{"location":"Serializer/Visitors/SerializationVisitorInterface/#Athena::Serializer::Visitors::SerializationVisitorInterface#visit(data)","text":"","title":"#visit"},{"location":"Serializer/Visitors/SerializationVisitorInterface/#Athena::Serializer::Visitors::SerializationVisitorInterface#visit(data)","text":"","title":"#visit"},{"location":"Serializer/Visitors/SerializationVisitorInterface/#Athena::Serializer::Visitors::SerializationVisitorInterface#visit(data)","text":"","title":"#visit"},{"location":"Serializer/Visitors/SerializationVisitorInterface/#Athena::Serializer::Visitors::SerializationVisitorInterface#visit(data)","text":"","title":"#visit"},{"location":"Serializer/Visitors/YAMLDeserializationVisitor/","text":"class Athena::Serializer::Visitors::YAMLDeserializationVisitor inherits Athena::Serializer::Visitors::DeserializationVisitor Methods #prepare ( input : IO | String ) : ASR::Any","title":"YAMLDeserializationVisitor"},{"location":"Serializer/Visitors/YAMLDeserializationVisitor/#Athena::Serializer::Visitors::YAMLDeserializationVisitor","text":"","title":"YAMLDeserializationVisitor"},{"location":"Serializer/Visitors/YAMLDeserializationVisitor/#methods","text":"","title":"Methods"},{"location":"Serializer/Visitors/YAMLDeserializationVisitor/#Athena::Serializer::Visitors::YAMLDeserializationVisitor#prepare(input)","text":"","title":"#prepare"},{"location":"Serializer/Visitors/YAMLSerializationVisitor/","text":"class Athena::Serializer::Visitors::YAMLSerializationVisitor inherits Reference Included modules Athena::Serializer::Visitors::SerializationVisitorInterface Class methods .new ( io : IO , named_args : NamedTuple ) Methods #finish : Nil #navigator : Athena::Serializer::Navigators::SerializationNavigatorInterface #navigator= ( navigator : Athena::Serializer::Navigators::SerializationNavigatorInterface ) #navigator? : Athena::Serializer::Navigators::SerializationNavigatorInterface? #prepare : Nil #visit ( properties : Array ( PropertyMetadataBase )) : Nil :inherit: #visit ( data : String | Symbol | Number | Bool | Nil ) : Nil #visit ( data : Hash | NamedTuple ) : Nil #visit ( data : Enumerable ) : Nil #visit ( data : Time ) : Nil #visit ( data : Enum ) : Nil #visit ( data : UUID ) : Nil #visit ( data : ASR::Model ) : Nil #visit ( data : ASR::Any ) : Nil #visit ( data : _ ) : Nil","title":"YAMLSerializationVisitor"},{"location":"Serializer/Visitors/YAMLSerializationVisitor/#Athena::Serializer::Visitors::YAMLSerializationVisitor","text":"","title":"YAMLSerializationVisitor"},{"location":"Serializer/Visitors/YAMLSerializationVisitor/#included-modules","text":"Athena::Serializer::Visitors::SerializationVisitorInterface","title":"Included modules"},{"location":"Serializer/Visitors/YAMLSerializationVisitor/#class-methods","text":"","title":"Class methods"},{"location":"Serializer/Visitors/YAMLSerializationVisitor/#Athena::Serializer::Visitors::YAMLSerializationVisitor.new(io,named_args)","text":"","title":".new"},{"location":"Serializer/Visitors/YAMLSerializationVisitor/#methods","text":"","title":"Methods"},{"location":"Serializer/Visitors/YAMLSerializationVisitor/#Athena::Serializer::Visitors::YAMLSerializationVisitor#finish()","text":"","title":"#finish"},{"location":"Serializer/Visitors/YAMLSerializationVisitor/#Athena::Serializer::Visitors::YAMLSerializationVisitor#navigator()","text":"","title":"#navigator"},{"location":"Serializer/Visitors/YAMLSerializationVisitor/#Athena::Serializer::Visitors::YAMLSerializationVisitor#navigator=(navigator)","text":"","title":"#navigator="},{"location":"Serializer/Visitors/YAMLSerializationVisitor/#Athena::Serializer::Visitors::YAMLSerializationVisitor#navigator?()","text":"","title":"#navigator?"},{"location":"Serializer/Visitors/YAMLSerializationVisitor/#Athena::Serializer::Visitors::YAMLSerializationVisitor#prepare()","text":"","title":"#prepare"},{"location":"Serializer/Visitors/YAMLSerializationVisitor/#Athena::Serializer::Visitors::YAMLSerializationVisitor#visit(properties)","text":":inherit:","title":"#visit"},{"location":"Spec/","text":"alias ASPEC Convenience alias to make referencing Athena::Spec types easier. Alias definition Athena::Spec module Athena::Spec A set of common Spec compliant testing utilities/types. Class methods .run_all : Nil Runs all ASPEC::TestCase s. Is equivalent to manually calling .run on each test case.","title":"Spec"},{"location":"Spec/#ASPEC","text":"Convenience alias to make referencing Athena::Spec types easier.","title":"ASPEC"},{"location":"Spec/#alias-definition","text":"Athena::Spec","title":"Alias definition"},{"location":"Spec/#Athena::Spec","text":"A set of common Spec compliant testing utilities/types.","title":"Spec"},{"location":"Spec/#class-methods","text":"","title":"Class methods"},{"location":"Spec/#Athena::Spec.run_all()","text":"Runs all ASPEC::TestCase s. Is equivalent to manually calling .run on each test case.","title":".run_all"},{"location":"Spec/Methods/","text":"module Athena::Spec::Methods Namespace for common/helpful testing methods. This module can be included into your spec_helper in order to allow your specs to use them all. This module is also included into ASPEC::TestCase by default to allow using them within your unit tests as well. May be reopened to add additional application specific helpers. Extended modules Athena::Spec::Methods Direct including types Athena::Spec::TestCase Methods #assert_error ( file_path : String , message : String , * , prefix : String = \"spec/\" ) : Nil Runs the Crystal program at the provided file_path and asserts it errors with the provided message . The main purpose of this method is to test compile time errors. By default, file_path is assumed to be within spec/ , but can be customized via the prefix named argument. NOTE: # ./spec/abstract_class.cr abstract class Foo ; end Foo . new # ./spec/abstract_class_spec.cr require \"athena-spec\" ASPEC :: Methods . assert_error \"abstract_class.cr\" , \"can't instantiate abstract class Foo\" #run_executable ( path : String , args : Array ( String ) = [] of String , & : String , String , Process :: Status -> ) : Nil Runs the executable at the given path , optionally with the provided args . The standard output, error output, and status of the execution are yielded. require \"athena-spec\" ASPEC :: Methods . run_executable \"/usr/bin/ls\" do | output , error , status | output # => \"docs\\n\" + \"LICENSE\\n\" + \"README.md\\n\" + \"shard.yml\\n\" + \"spec\\n\" + \"src\\n\" error # => \"\" status # => #<Process::Status:0x7f7bc9befb70 @exit_status=0> end #run_executable ( path : String , input : IO , args : Array ( String ) = [] of String , & : String , String , Process :: Status -> ) : Nil Runs the executable at the given path , with the given input , optionally with the provided args . The standard output, error output, and status of the execution are yielded. require \"athena-spec\" input = IO :: Memory . new %({\"id\":1}) ASPEC :: Methods . run_executable \"jq\" , input , [ \".\" , \"-c\" ] do | output , error , status | output # => \"{\\\"id\\\":1}\\n\" error # => \"\" status # => #<Process::Status:0x7f26ec698b70 @exit_status=0> end invalid_input = IO :: Memory . new %({\"id\"1}) ASPEC :: Methods . run_executable \"jq\" , invalid_input , [ \".\" , \"-c\" ] do | output , error , status | output # => \"\" error # => \"parse error: Expected separator between values at line 1, column 7\\n\" status # => #<Process::Status:0x7f0217496900 @exit_status=1024> end","title":"Methods"},{"location":"Spec/Methods/#Athena::Spec::Methods","text":"Namespace for common/helpful testing methods. This module can be included into your spec_helper in order to allow your specs to use them all. This module is also included into ASPEC::TestCase by default to allow using them within your unit tests as well. May be reopened to add additional application specific helpers.","title":"Methods"},{"location":"Spec/Methods/#extended-modules","text":"Athena::Spec::Methods","title":"Extended modules"},{"location":"Spec/Methods/#direct-including-types","text":"Athena::Spec::TestCase","title":"Direct including types"},{"location":"Spec/Methods/#methods","text":"","title":"Methods"},{"location":"Spec/Methods/#Athena::Spec::Methods#assert_error(file_path,message,*,prefix)","text":"Runs the Crystal program at the provided file_path and asserts it errors with the provided message . The main purpose of this method is to test compile time errors. By default, file_path is assumed to be within spec/ , but can be customized via the prefix named argument. NOTE: # ./spec/abstract_class.cr abstract class Foo ; end Foo . new # ./spec/abstract_class_spec.cr require \"athena-spec\" ASPEC :: Methods . assert_error \"abstract_class.cr\" , \"can't instantiate abstract class Foo\"","title":"#assert_error"},{"location":"Spec/Methods/#Athena::Spec::Methods#run_executable(path,args,&)","text":"Runs the executable at the given path , optionally with the provided args . The standard output, error output, and status of the execution are yielded. require \"athena-spec\" ASPEC :: Methods . run_executable \"/usr/bin/ls\" do | output , error , status | output # => \"docs\\n\" + \"LICENSE\\n\" + \"README.md\\n\" + \"shard.yml\\n\" + \"spec\\n\" + \"src\\n\" error # => \"\" status # => #<Process::Status:0x7f7bc9befb70 @exit_status=0> end","title":"#run_executable"},{"location":"Spec/TestCase/","text":"abstract struct Athena::Spec::TestCase inherits Struct ASPEC::TestCase provides a Spec compliant alternative DSL for creating unit and integration tests. It allows structuring tests in a more OOP fashion, with the main benefits of reusability and extendability. This type can be extended to share common testing logic with groups of similar types. Any tests defined within a parent will run for each child test case. abstract def , super , and other OOP features can be used as well to reduce duplication. Some additional features are also built in, such as the DataProvider . NOTE: This is NOT a standalone testing framework. Everything boils down to standard describe , it , and/or pending blocks. A test case consists of a struct inheriting from self , optionally with an #initialize method in order to initialize the state that should be used for each test. A test is a method that starts with test_ , where the method name is used as the description. For example, test_some_method_some_context becomes \"some method some context\" . Internally each test method maps to an it block. All of the stdlib's Spec assertions methods are available, in addition to #pending! and #fail . A method may be focused by either prefixing the method name with an f , or applying the Focus annotation. A method may be marked pending by either prefixing the method name with a p , or applying the Pending annotation. Internally this maps to a pending block. Tags may be applied to a method via the Tags annotation. The Tags , Focus , and Pending annotations may also be applied to the test case type as well, with a similar affect. Example # Require the stdlib's spec module. require \"spec\" # Define a class to test. class Calculator def add ( v1 , v2 ) v1 + v2 end def subtract ( v1 , v2 ) raise NotImplementedError . new \"TODO\" end end # An example test case. struct ExampleSpec < ASPEC :: TestCase @target : Calculator # Initialize the test target along with any dependencies. def initialize : Nil @target = Calculator . new end # All of the stdlib's `Spec` methods can be used, # plus any custom methods defined in `ASPEC::Methods`. def test_add : Nil @target . add ( 1 , 2 ) . should eq 3 end # A pending test. def ptest_substract : Nil @target . subtract ( 10 , 5 ) . should eq 5 end # Private/protected methods can be used to reduce duplication within the context of single test case. private def helper_method # ... end end Inheritance Inheritance can be used to build reusable test cases for groups of similar objects abstract struct SomeTypeTestCase < ASPEC :: TestCase # Require children to define a method to get the object. protected abstract def get_object : Calculator # Test cases can use the abstract method for tests common to all test cases of this type. def test_common : Nil obj = self . get_object # ... end end struct CalculatorTest < SomeTypeTestCase protected def get_object : Calculator Calculator . new end # Additional tests specific to this type. def test_specific : Nil # ... end end Data Providers A DataProvider can be used to reduce duplication, see the corresponding annotation or more information. struct DataProviderTest < ASPEC :: TestCase # Data Providers allow reusing a test's multiple times with different input. @[ DataProvider ( \"get_values\" ) ] def test_squares ( value : Int32 , expected : Int32 ) : Nil ( value ** 2 ) . should eq expected end # Returns a hash where the key represents the name of the test, # and the value is a Tuple of data that should be provided to the test. def get_values : Hash { \"two\" => { 2 , 4 }, \"three\" => { 3 , 9 }, } end end # Run all the test cases ASPEC . run_all # => # ExampleSpec # add # subtract # a custom method name # CalculatorTest # common # specific # DataProviderTest # squares two # squares three # # Pending: # ExampleSpec subtract # # Finished in 172 microseconds # 7 examples, 0 failures, 0 errors, 1 pending Included modules Athena::Spec::Methods Direct known subclasses Athena::Routing::Spec::WebTestCase Athena::Validator::Spec::ConstraintValidatorTestCase Class methods .run : Nil Runs the tests contained within self . See Athena::Spec.run_all to run all test cases. .new Runs before each test. Used to create the objects that will be used within the tests. require \"spec\" require \"athena-spec\" struct ExampleSpec < ASpec :: TestCase @value : Int32 def initialize : Nil @value = 1 end def test_one : Nil @value += 1 @value # => 2 end def test_two : Nil @value # => 1 end end ExampleSpec . run Methods #after_all : Nil Runs once after all tests within self have been executed. require \"spec\" require \"athena-spec\" struct ExampleSpec < ASPEC :: TestCase def after_all : Nil puts \"This prints only once after anything else\" end def test_one : Nil true . should be_true end def test_two : Nil 1 . should eq 1 end end ExampleSpec . run #before_all : Nil Runs once before any tests within self have been executed. Can be used to initialize objects common to every test, but that do not need to be reset before running each test. require \"spec\" require \"athena-spec\" struct ExampleSpec < ASPEC :: TestCase def before_all : Nil puts \"This prints only once before anything else\" end def test_one : Nil true . should be_true end def test_two : Nil 1 . should eq 1 end end ExampleSpec . run #tear_down : Nil Runs after each test. Can be used to cleanup data in between tests, such as releasing a connection or closing a file. require \"spec\" require \"athena-spec\" struct ExampleSpec < ASPEC :: TestCase @file : File def initialize : Nil @file = File . new \"./foo.txt\" , \"w\" end def tear_down : Nil @file . close end def test_one : Nil @file . path # => \"./foo.txt\" end end ExampleSpec . run","title":"TestCase"},{"location":"Spec/TestCase/#Athena::Spec::TestCase","text":"ASPEC::TestCase provides a Spec compliant alternative DSL for creating unit and integration tests. It allows structuring tests in a more OOP fashion, with the main benefits of reusability and extendability. This type can be extended to share common testing logic with groups of similar types. Any tests defined within a parent will run for each child test case. abstract def , super , and other OOP features can be used as well to reduce duplication. Some additional features are also built in, such as the DataProvider . NOTE: This is NOT a standalone testing framework. Everything boils down to standard describe , it , and/or pending blocks. A test case consists of a struct inheriting from self , optionally with an #initialize method in order to initialize the state that should be used for each test. A test is a method that starts with test_ , where the method name is used as the description. For example, test_some_method_some_context becomes \"some method some context\" . Internally each test method maps to an it block. All of the stdlib's Spec assertions methods are available, in addition to #pending! and #fail . A method may be focused by either prefixing the method name with an f , or applying the Focus annotation. A method may be marked pending by either prefixing the method name with a p , or applying the Pending annotation. Internally this maps to a pending block. Tags may be applied to a method via the Tags annotation. The Tags , Focus , and Pending annotations may also be applied to the test case type as well, with a similar affect.","title":"TestCase"},{"location":"Spec/TestCase/#Athena::Spec::TestCase--example","text":"# Require the stdlib's spec module. require \"spec\" # Define a class to test. class Calculator def add ( v1 , v2 ) v1 + v2 end def subtract ( v1 , v2 ) raise NotImplementedError . new \"TODO\" end end # An example test case. struct ExampleSpec < ASPEC :: TestCase @target : Calculator # Initialize the test target along with any dependencies. def initialize : Nil @target = Calculator . new end # All of the stdlib's `Spec` methods can be used, # plus any custom methods defined in `ASPEC::Methods`. def test_add : Nil @target . add ( 1 , 2 ) . should eq 3 end # A pending test. def ptest_substract : Nil @target . subtract ( 10 , 5 ) . should eq 5 end # Private/protected methods can be used to reduce duplication within the context of single test case. private def helper_method # ... end end","title":"Example"},{"location":"Spec/TestCase/#Athena::Spec::TestCase--inheritance","text":"Inheritance can be used to build reusable test cases for groups of similar objects abstract struct SomeTypeTestCase < ASPEC :: TestCase # Require children to define a method to get the object. protected abstract def get_object : Calculator # Test cases can use the abstract method for tests common to all test cases of this type. def test_common : Nil obj = self . get_object # ... end end struct CalculatorTest < SomeTypeTestCase protected def get_object : Calculator Calculator . new end # Additional tests specific to this type. def test_specific : Nil # ... end end","title":"Inheritance"},{"location":"Spec/TestCase/#Athena::Spec::TestCase--data-providers","text":"A DataProvider can be used to reduce duplication, see the corresponding annotation or more information. struct DataProviderTest < ASPEC :: TestCase # Data Providers allow reusing a test's multiple times with different input. @[ DataProvider ( \"get_values\" ) ] def test_squares ( value : Int32 , expected : Int32 ) : Nil ( value ** 2 ) . should eq expected end # Returns a hash where the key represents the name of the test, # and the value is a Tuple of data that should be provided to the test. def get_values : Hash { \"two\" => { 2 , 4 }, \"three\" => { 3 , 9 }, } end end # Run all the test cases ASPEC . run_all # => # ExampleSpec # add # subtract # a custom method name # CalculatorTest # common # specific # DataProviderTest # squares two # squares three # # Pending: # ExampleSpec subtract # # Finished in 172 microseconds # 7 examples, 0 failures, 0 errors, 1 pending","title":"Data Providers"},{"location":"Spec/TestCase/#included-modules","text":"Athena::Spec::Methods","title":"Included modules"},{"location":"Spec/TestCase/#direct-known-subclasses","text":"Athena::Routing::Spec::WebTestCase Athena::Validator::Spec::ConstraintValidatorTestCase","title":"Direct known subclasses"},{"location":"Spec/TestCase/#class-methods","text":"","title":"Class methods"},{"location":"Spec/TestCase/#Athena::Spec::TestCase.run()","text":"Runs the tests contained within self . See Athena::Spec.run_all to run all test cases.","title":".run"},{"location":"Spec/TestCase/#Athena::Spec::TestCase.new()","text":"Runs before each test. Used to create the objects that will be used within the tests. require \"spec\" require \"athena-spec\" struct ExampleSpec < ASpec :: TestCase @value : Int32 def initialize : Nil @value = 1 end def test_one : Nil @value += 1 @value # => 2 end def test_two : Nil @value # => 1 end end ExampleSpec . run","title":".new"},{"location":"Spec/TestCase/#methods","text":"","title":"Methods"},{"location":"Spec/TestCase/#Athena::Spec::TestCase#after_all()","text":"Runs once after all tests within self have been executed. require \"spec\" require \"athena-spec\" struct ExampleSpec < ASPEC :: TestCase def after_all : Nil puts \"This prints only once after anything else\" end def test_one : Nil true . should be_true end def test_two : Nil 1 . should eq 1 end end ExampleSpec . run","title":"#after_all"},{"location":"Spec/TestCase/#Athena::Spec::TestCase#before_all()","text":"Runs once before any tests within self have been executed. Can be used to initialize objects common to every test, but that do not need to be reset before running each test. require \"spec\" require \"athena-spec\" struct ExampleSpec < ASPEC :: TestCase def before_all : Nil puts \"This prints only once before anything else\" end def test_one : Nil true . should be_true end def test_two : Nil 1 . should eq 1 end end ExampleSpec . run","title":"#before_all"},{"location":"Spec/TestCase/#Athena::Spec::TestCase#tear_down()","text":"Runs after each test. Can be used to cleanup data in between tests, such as releasing a connection or closing a file. require \"spec\" require \"athena-spec\" struct ExampleSpec < ASPEC :: TestCase @file : File def initialize : Nil @file = File . new \"./foo.txt\" , \"w\" end def tear_down : Nil @file . close end def test_one : Nil @file . path # => \"./foo.txt\" end end ExampleSpec . run","title":"#tear_down"},{"location":"Spec/TestCase/DataProvider/","text":"annotation Athena::Spec::TestCase::DataProvider Tests can be defined with arbitrary arguments. These arguments are provided by one or more DataProvider . A data provider is a method that returns either a Hash , NamedTuple , Array , or Tuple . NOTE: The method's return type must be set to one of those types. If the return type is a Hash or NamedTuple then it is a keyed provider; the key will be used as part of the description for each test. If the return type is an Array or Tuple it is considered a keyless provider; the index will be used as part of the description for each test. NOTE: In both cases the value must be a Tuple ; the values should be an ordered list of the arguments you want to provide to the test. One or more DataProvider annotations can be applied to a test with a positional argument of the name of the providing methods. An it block will be defined for each \"set\" of data. Data providers can be a very powerful tool when combined with inheritance and abstract def s. A parent test case could define all the testing logic, and child implementations only provide the data. Example require \"athena-spec\" struct DataProviderTest < ASPEC :: TestCase @[ DataProvider ( \"get_values_hash\" ) ] @[ DataProvider ( \"get_values_named_tuple\" ) ] def test_squares ( value : Int32 , expected : Int32 ) : Nil ( value ** 2 ) . should eq expected end # A keyed provider using a Hash. def get_values_hash : Hash { \"two\" => { 2 , 4 }, \"three\" => { 3 , 9 }, } end # A keyed provider using a NamedTuple. def get_values_named_tuple : NamedTuple { four : { 4 , 16 }, five : { 5 , 25 }, } end @[ DataProvider ( \"get_values_array\" ) ] @[ DataProvider ( \"get_values_tuple\" ) ] def test_cubes ( value : Int32 , expected : Int32 ) : Nil ( value ** 3 ) . should eq expected end # A keyless provider using an Array. def get_values_array : Array [ { 2 , 8 }, { 3 , 27 }, ] end # A keyless provider using a Tuple. def get_values_tuple : Tuple { { 4 , 64 }, { 5 , 125 }, } end end ASPEC . run_all # => # DataProviderTest # squares two # squares three # squares four # squares five # cubes 0 # cubes 1 # cubes 0 # cubes 1","title":"DataProvider"},{"location":"Spec/TestCase/DataProvider/#Athena::Spec::TestCase::DataProvider","text":"Tests can be defined with arbitrary arguments. These arguments are provided by one or more DataProvider . A data provider is a method that returns either a Hash , NamedTuple , Array , or Tuple . NOTE: The method's return type must be set to one of those types. If the return type is a Hash or NamedTuple then it is a keyed provider; the key will be used as part of the description for each test. If the return type is an Array or Tuple it is considered a keyless provider; the index will be used as part of the description for each test. NOTE: In both cases the value must be a Tuple ; the values should be an ordered list of the arguments you want to provide to the test. One or more DataProvider annotations can be applied to a test with a positional argument of the name of the providing methods. An it block will be defined for each \"set\" of data. Data providers can be a very powerful tool when combined with inheritance and abstract def s. A parent test case could define all the testing logic, and child implementations only provide the data.","title":"DataProvider"},{"location":"Spec/TestCase/DataProvider/#Athena::Spec::TestCase::DataProvider--example","text":"require \"athena-spec\" struct DataProviderTest < ASPEC :: TestCase @[ DataProvider ( \"get_values_hash\" ) ] @[ DataProvider ( \"get_values_named_tuple\" ) ] def test_squares ( value : Int32 , expected : Int32 ) : Nil ( value ** 2 ) . should eq expected end # A keyed provider using a Hash. def get_values_hash : Hash { \"two\" => { 2 , 4 }, \"three\" => { 3 , 9 }, } end # A keyed provider using a NamedTuple. def get_values_named_tuple : NamedTuple { four : { 4 , 16 }, five : { 5 , 25 }, } end @[ DataProvider ( \"get_values_array\" ) ] @[ DataProvider ( \"get_values_tuple\" ) ] def test_cubes ( value : Int32 , expected : Int32 ) : Nil ( value ** 3 ) . should eq expected end # A keyless provider using an Array. def get_values_array : Array [ { 2 , 8 }, { 3 , 27 }, ] end # A keyless provider using a Tuple. def get_values_tuple : Tuple { { 4 , 64 }, { 5 , 125 }, } end end ASPEC . run_all # => # DataProviderTest # squares two # squares three # squares four # squares five # cubes 0 # cubes 1 # cubes 0 # cubes 1","title":"Example"},{"location":"Spec/TestCase/Focus/","text":"annotation Athena::Spec::TestCase::Focus Focuses a specific test case (describe block) or method (it block). Maps to Focusing Specs in the stdlib.","title":"Focus"},{"location":"Spec/TestCase/Focus/#Athena::Spec::TestCase::Focus","text":"Focuses a specific test case (describe block) or method (it block). Maps to Focusing Specs in the stdlib.","title":"Focus"},{"location":"Spec/TestCase/Pending/","text":"annotation Athena::Spec::TestCase::Pending Marks a specific test case (describe block) or method (it block) as pending . Maps to the stdlib's #pending method.","title":"Pending"},{"location":"Spec/TestCase/Pending/#Athena::Spec::TestCase::Pending","text":"Marks a specific test case (describe block) or method (it block) as pending . Maps to the stdlib's #pending method.","title":"Pending"},{"location":"Spec/TestCase/Tags/","text":"annotation Athena::Spec::TestCase::Tags Defines the tags tied to a specific test case (describe block) or method (it block). Maps to Tagging Specs in the stdlib.","title":"Tags"},{"location":"Spec/TestCase/Tags/#Athena::Spec::TestCase::Tags","text":"Defines the tags tied to a specific test case (describe block) or method (it block). Maps to Tagging Specs in the stdlib.","title":"Tags"},{"location":"Validator/","text":"alias AVD Convenience alias to make referencing Athena::Validator types easier. Alias definition Athena::Validator alias Assert Used to apply constraints to instance variables and types via annotations. @[ Assert :: NotBlank ] property name : String NOTE: Constraints, including custom ones, are automatically added to this namespace. Alias definition Athena :: Validator :: Annotations module Athena::Validator Athena's Validation component, AVD for short, adds an object/value validation framework to your project. The framework consists of AVD::Constraint s that describe some assertion; such as a string should be AVD::Constraints::NotBlank or that a value is AVD::Constraints::GreaterThanOrEqual another value. Constraints, along with a value, are then passed to an AVD::ConstraintValidatorInterface that actually performs the validation, using the data defined in the constraint. If the validator determines that the value is invalid in some way, it creates and adds an AVD::Violation::ConstraintViolationInterface to this runs' AVD::ExecutionContextInterface . The AVD::Validator::ValidatorInterface then returns an AVD::Violation::ConstraintViolationListInterface that contains all the violations. The value can be considered valid if that list is empty. NOTE: See each type individually for more detailed information. Getting Started Athena::Validator comes with a set of common AVD::Constraints built in that any project could find useful. When used on its own, the Athena::Validator.validator method can be used to obtain an AVD::Validator::ValidatorInterface instance to validate a given value/object. Basics A validator accepts a value, and one or more AVD::Constraint to validate the value against. The validator then returns an AVD::Violation::ConstraintViolationListInterface that includes all the violations, if any. # Obtain a validator instance. validator = AVD . validator # Use the validator to validate a value. violations = validator . validate \"foo\" , AVD :: Constraints :: NotBlank . new # The validator returns an empty list of violations, indicating the value is valid. violations . inspect # => Athena::Validator::Violation::ConstraintViolationList(@violations=[]) In this case it returns an empty list of violations, meaning the value is valid. # Using the validator instance from the previous example violations = validator . validate \"\" , AVD :: Constraints :: NotBlank . new violations . inspect # => # Athena::Validator::Violation::ConstraintViolationList( # @violations= # [Athena::Validator::Violation::ConstraintViolation(String)( # @cause=nil, # @code=\"0d0c3254-3642-4cb0-9882-46ee5918e6e3\", # @constraint= # #<Athena::Validator::Constraints::NotBlank:0x7f97da08ced0 # @allow_nil=false, # @groups=[\"default\"], # @message=\"This value should not be blank.\", # @payload=nil>, # @invalid_value_container= # Athena::Validator::ValueContainer(String)(@value=\"\"), # @message=\"This value should not be blank.\", # @message_template=\"This value should not be blank.\", # @parameters={\"{{ value }}\" => \"\"}, # @plural=nil, # @property_path=\"\", # @root=\"\")]) # Both the ConstraintViolationList and ConstraintViolation implement a `#to_s` method. puts violations # => # : # This value should not be blank. (code: 0d0c3254-3642-4cb0-9882-46ee5918e6e3) However in the case of the value NOT being valid, the list includes all of the AVD::Violation::ConstraintViolationInterface s produced during this run. Each violation includes some metadata; such as the related constraint that failed, a machine readable code, a human readable message, any parameters that should be used to render that message, etc. The extra context allows for a lot of flexibility; both in terms of how the error could be rendered or handled. By default, in addition to any constraint specific arguments, the majority of the constraints have three optional arguments: message , groups , and payload . The message argument represents the message that should be used if the value is found to not be valid. The message can also include placeholders, in the form of {{ key }} , that will be replaced when the message is rendered. Most commonly this includes the invalid value itself, but some constraints have additional placeholders. The payload argument can be used to attach any domain specific data to the constraint; such as attaching a severity with each constraint to have more serious violations be handled differently. The groups argument can be used to run a subset of the defined constraints. More on this in the Validation Groups section. validator = AVD . validator # Instantiate a constraint with a custom message, using a placeholder. violations = validator . validate - 4 , AVD :: Constraints :: PositiveOrZero . new message : \"{{ value }} is not a valid age. A user cannot have a negative age.\" puts violations # => # -4: # -4 is not a valid age. A user cannot have a negative age. (code: e09e52d0-b549-4ba1-8b4e-420aad76f0de) Customizing the message can be a good way for those consuming the errors to determine WHY a given value is not valid. Validating Objects Validating arbitrary values against a set of arbitrary constraints can be useful in smaller applications and/or for one off use cases. However to keep in line with our Object Oriented Programming (OOP) principles, we can also validate objects. The object could be either a struct or a class. The only requirements are that the object includes a specific module, AVD::Validatable , and specifies which properties should be validated and against what constraints. The easiest/most common way to do this is via annotations and the Assert alias. # Define a class that can be validated. class User include AVD :: Validatable def initialize ( @name : String , @age : Int32 ? = nil ); end # Specify that we want to assert that the user's name is not blank. # Multiple constraints can be defined on a single property. @[ Assert :: NotBlank ] getter name : String # Arguments to the constraint can be used normally as well. # The constraint's default argument can also be supplied positionally: `@[Assert::GreaterThan(0)]`. @[ Assert :: NotNil ( message : \"A user's age cannot be null\" ) ] getter age : Int32 ? end # Obtain a validator instance. validator = AVD . validator # Validate a user instance, notice we're not passing in any constraints. validator . validate ( User . new ( \"Jim\" , 10 )) . empty? # => true validator . validate User . new \"\" , 10 # => # Object(User).name: # This value should not be blank. (code: 0d0c3254-3642-4cb0-9882-46ee5918e6e3) Notice that in this case we do not need to supply the constraints to the #validate method. This is because the validator is able to extract them from the annotations on the properties. An array of constraints can still be supplied, and will take precedence over the constraints defined within the type. NOTE: By default if a property's value is another object, the sub object will not be validated. use the AVD::Constraints::Valid constraint if you wish to also validate the sub object. This also applies to arrays of objects. Another important thing to point out is that no custom DSL is required to define these constraints. Athena::Validator is intended to be a generic validation solution that could be used outside of the Athena ecosystem. However, in order to be able to use the annotation based approach, you need to be able to apply the annotations to the underlying properties. If this is not possible due to how a specific type is implemented, or if you just don't like the annotation syntax, the type can also be configured via code. # Define a class that can be validated. class User include AVD :: Validatable # This class method is invoked when building the metadata associated with a type, # and can be used to manually wire up the constraints. def self . load_metadata ( metadata : AVD :: Metadata :: ClassMetadata ) : Nil metadata . add_property_constraint \"name\" , AVD :: Constraints :: NotBlank . new end def initialize ( @name : String ); end getter name : String end # Obtain a validator instance. validator = AVD . validator # Validate a user instance, notice we're not passing in any constraints. validator . validate ( User . new ( \"Jim\" )) . empty? # => true validator . validate User . new \"\" # => # Object(User).name: # This value should not be blank. (code: 0d0c3254-3642-4cb0-9882-46ee5918e6e3) The metadata for each type is lazily loaded when an instance of that type is validated, and is only built once. See AVD::Metadata::ClassMetadata for some additional ways to register property constraints. Getters Constraints can also be applied to getter methods of an object. This allows for dynamic validations based on the return value of the method. For example, say we wanted to assert that a user's name is not the same as their password. class User include AVD :: Validatable property name : String property password : String def initialize ( @name : String , @password : String ); end @[ Assert :: IsTrue ( message : \"Your password cannot be the same as your name.\" ) ] def is_safe_password? : Bool @name != @password end end validator = AVD . validator user = User . new \"foo\" , \"foo\" validator . validate ( user ) . empty? # => false user . password = \"bar\" validator . validate ( user ) . empty? # => true Custom Constraints If the built in AVD::Constraints are not sufficient to handle validating a given value/object; custom ones can be defined. Let's make a new constraint that asserts a string contains only alphanumeric characters. This is accomplished by first defining a new class within the AVD::Constraints namespace that inherits from AVD::Constraint . Then define a Validator struct within our constraint that inherits from AVD::ConstraintValidator that actually implements the validation logic. class AVD::Constraints:: AlphaNumeric < AVD :: Constraint # (Optional) A unique error code can also be defined to provide a machine readable identifier for a specific error. NOT_ALPHANUMERIC_ERROR = \"1a83a8bd-ff79-4d5c-96e7-86d0b25b8a09\" # (Optional) Allows using the `.error_message(code : String) : String` method with this constraint. @@error_names = { NOT_ALPHANUMERIC_ERROR => \"NOT_ALPHANUMERIC_ERROR\" , } # Define an initializer with our default message, and any additional arguments specific to this constraint. def initialize ( message : String = \"This value should contain only alphanumeric characters.\" , groups : Array ( String ) | String | Nil = nil , payload : Hash ( String , String )? = nil ) super message , groups , payload end # Define the validator within our constraint that'll contain our validation logic. struct Validator < AVD :: ConstraintValidator # Define our validate method that accepts the value to be validated, and the constraint. # # Overloads can be used to filter values of specific types. def validate ( value : _ , constraint : AVD :: Constraints :: AlphaNumeric ) : Nil # Custom constraints should ignore nil and empty values to allow # other constraints (NotBlank, NotNil, etc.) take care of that return if value . nil? || value == \"\" # We'll cast the value to a string, # alternatively we could just ignore non `String?` values. value = value . to_s # If all the characters of this string are alphanumeric, then it is valid return if value . each_char . all? &. alphanumeric? # Otherwise, it is invalid and we need to add a violation, # see `AVD::ExecutionContextInterface` for additional information. self . context . add_violation constraint . message , NOT_ALPHANUMERIC_ERROR , value end end end puts AVD . validator . validate \"$\" , AVD :: Constraints :: AlphaNumeric . new # => # $: # This value should contain only alphanumeric characters. (code: 1a83a8bd-ff79-4d5c-96e7-86d0b25b8a09) NOTE: The constraint MUST be defined within the AVD::Constraints namespace for implementation reasons. This may change in the future. We are now able to use this constraint as we would one of the built in ones; either by manually instantiating it, or applying an @[Assert::AlphaNumeric] annotation to a property. See AVD::ConstraintValidatorInterface for more information on custom validators. Validation Groups By default when validating an object, all constraints defined on that type will be checked. However, in some cases you may only want to validate the object against some of those constraints. This can be accomplished via assigning each constraint to a validation group, then apply validation against one specific group of constraints. For example, using our User class from earlier, say we only want to validate certain properties when the user is first created. To do this we can utilize the groups argument that all constraints have. class User include AVD :: Validatable def initialize ( @email : String , @password : String , @city : String ); end @[ Assert :: Email ( groups : \"create\" ) ] getter email : String @[ Assert :: NotBlank ( groups : \"create\" ) ] @[ Assert :: Size ( 7 .. , groups : \"create\" ) ] getter password : String @[ Assert :: Size ( 2 .. ) ] getter city : String end user = User . new \"george@dietrich.app\" , \"monkey123\" , \"\" # Validate the user object, but only for those in the \"create\" group, # if no groups are supplied, then all constraints in the \"default\" group will be used. violations = AVD . validator . validate user , groups : \"create\" # There are no violations since the city's size is not validated since it's not in the \"create\" group. violations . empty? # => true See AVD::Constraint@validation-groups for some expanded information. Sequential Validation By default, all constraints are validated in a single \"batch\". I.e. all constraints within the provided group(s) are validated, without regard to if the previous/next constraint is/was (in)valid. However, an AVD::Constraints::GroupSequence can be used to validate batches of constraints in steps. I.e. validate the first \"batch\" of constraints, and only advance to the next batch if all constraints in that step are valid. @[ Assert :: GroupSequence ( \"User\" , \"Secondary\" ) ] class User include AVD :: Validatable @[ Assert :: NotBlank ] getter username : String @[ Assert :: NotBlank ( groups : \"Secondary\" ) ] getter password : String def initialize ( @username : String , @password : String ); end end # Instantiate a new `User` object where both properties are invalid. user = User . new \"\" , \"\" # Notice there is only one violation since there was a violation in the `User` group, # it did not advance to the `Secondary` group. AVD . validator . validate user # => # Object(User).username: # This value should not be blank. (code: 0d0c3254-3642-4cb0-9882-46ee5918e6e3) Group Sequence Providers The AVD::Constraints::GroupSequence can be a useful tool for creating efficient validations, but it is quite limiting since the sequence is static on the type. If more flexibility is required the AVD::Constraints::GroupSequence::Provider module can be included into a type. The module allows the object to return the sequence it should use dynamically at runtime. class User include AVD :: Validatable include AVD :: Constraints :: GroupSequence :: Provider # ... def group_sequence : Array ( Array ( String ) | String ) | AVD :: Constraints :: GroupSequence # Build out and return the sequence `self` should use. end end Alternatively, if you only want to apply constraints sequentially on a single property, the AVD::Constraints::Sequentially constraint can be used to do this in a simpler way. NOTE: See the related types for more detailed information. Class methods .validator : AVD::Validator::ValidatorInterface Returns a new AVD::Validator::ValidatorInterface . validator = AVD . validator validator . validate \"foo\" , AVD :: Constraints :: NotBlank . new","title":"Validator"},{"location":"Validator/#AVD","text":"Convenience alias to make referencing Athena::Validator types easier.","title":"AVD"},{"location":"Validator/#alias-definition","text":"Athena::Validator","title":"Alias definition"},{"location":"Validator/#Assert","text":"Used to apply constraints to instance variables and types via annotations. @[ Assert :: NotBlank ] property name : String NOTE: Constraints, including custom ones, are automatically added to this namespace.","title":"Assert"},{"location":"Validator/#alias-definition_1","text":"Athena :: Validator :: Annotations","title":"Alias definition"},{"location":"Validator/#Athena::Validator","text":"Athena's Validation component, AVD for short, adds an object/value validation framework to your project. The framework consists of AVD::Constraint s that describe some assertion; such as a string should be AVD::Constraints::NotBlank or that a value is AVD::Constraints::GreaterThanOrEqual another value. Constraints, along with a value, are then passed to an AVD::ConstraintValidatorInterface that actually performs the validation, using the data defined in the constraint. If the validator determines that the value is invalid in some way, it creates and adds an AVD::Violation::ConstraintViolationInterface to this runs' AVD::ExecutionContextInterface . The AVD::Validator::ValidatorInterface then returns an AVD::Violation::ConstraintViolationListInterface that contains all the violations. The value can be considered valid if that list is empty. NOTE: See each type individually for more detailed information.","title":"Validator"},{"location":"Validator/#Athena::Validator--getting-started","text":"Athena::Validator comes with a set of common AVD::Constraints built in that any project could find useful. When used on its own, the Athena::Validator.validator method can be used to obtain an AVD::Validator::ValidatorInterface instance to validate a given value/object.","title":"Getting Started"},{"location":"Validator/#Athena::Validator--basics","text":"A validator accepts a value, and one or more AVD::Constraint to validate the value against. The validator then returns an AVD::Violation::ConstraintViolationListInterface that includes all the violations, if any. # Obtain a validator instance. validator = AVD . validator # Use the validator to validate a value. violations = validator . validate \"foo\" , AVD :: Constraints :: NotBlank . new # The validator returns an empty list of violations, indicating the value is valid. violations . inspect # => Athena::Validator::Violation::ConstraintViolationList(@violations=[]) In this case it returns an empty list of violations, meaning the value is valid. # Using the validator instance from the previous example violations = validator . validate \"\" , AVD :: Constraints :: NotBlank . new violations . inspect # => # Athena::Validator::Violation::ConstraintViolationList( # @violations= # [Athena::Validator::Violation::ConstraintViolation(String)( # @cause=nil, # @code=\"0d0c3254-3642-4cb0-9882-46ee5918e6e3\", # @constraint= # #<Athena::Validator::Constraints::NotBlank:0x7f97da08ced0 # @allow_nil=false, # @groups=[\"default\"], # @message=\"This value should not be blank.\", # @payload=nil>, # @invalid_value_container= # Athena::Validator::ValueContainer(String)(@value=\"\"), # @message=\"This value should not be blank.\", # @message_template=\"This value should not be blank.\", # @parameters={\"{{ value }}\" => \"\"}, # @plural=nil, # @property_path=\"\", # @root=\"\")]) # Both the ConstraintViolationList and ConstraintViolation implement a `#to_s` method. puts violations # => # : # This value should not be blank. (code: 0d0c3254-3642-4cb0-9882-46ee5918e6e3) However in the case of the value NOT being valid, the list includes all of the AVD::Violation::ConstraintViolationInterface s produced during this run. Each violation includes some metadata; such as the related constraint that failed, a machine readable code, a human readable message, any parameters that should be used to render that message, etc. The extra context allows for a lot of flexibility; both in terms of how the error could be rendered or handled. By default, in addition to any constraint specific arguments, the majority of the constraints have three optional arguments: message , groups , and payload . The message argument represents the message that should be used if the value is found to not be valid. The message can also include placeholders, in the form of {{ key }} , that will be replaced when the message is rendered. Most commonly this includes the invalid value itself, but some constraints have additional placeholders. The payload argument can be used to attach any domain specific data to the constraint; such as attaching a severity with each constraint to have more serious violations be handled differently. The groups argument can be used to run a subset of the defined constraints. More on this in the Validation Groups section. validator = AVD . validator # Instantiate a constraint with a custom message, using a placeholder. violations = validator . validate - 4 , AVD :: Constraints :: PositiveOrZero . new message : \"{{ value }} is not a valid age. A user cannot have a negative age.\" puts violations # => # -4: # -4 is not a valid age. A user cannot have a negative age. (code: e09e52d0-b549-4ba1-8b4e-420aad76f0de) Customizing the message can be a good way for those consuming the errors to determine WHY a given value is not valid.","title":"Basics"},{"location":"Validator/#Athena::Validator--validating-objects","text":"Validating arbitrary values against a set of arbitrary constraints can be useful in smaller applications and/or for one off use cases. However to keep in line with our Object Oriented Programming (OOP) principles, we can also validate objects. The object could be either a struct or a class. The only requirements are that the object includes a specific module, AVD::Validatable , and specifies which properties should be validated and against what constraints. The easiest/most common way to do this is via annotations and the Assert alias. # Define a class that can be validated. class User include AVD :: Validatable def initialize ( @name : String , @age : Int32 ? = nil ); end # Specify that we want to assert that the user's name is not blank. # Multiple constraints can be defined on a single property. @[ Assert :: NotBlank ] getter name : String # Arguments to the constraint can be used normally as well. # The constraint's default argument can also be supplied positionally: `@[Assert::GreaterThan(0)]`. @[ Assert :: NotNil ( message : \"A user's age cannot be null\" ) ] getter age : Int32 ? end # Obtain a validator instance. validator = AVD . validator # Validate a user instance, notice we're not passing in any constraints. validator . validate ( User . new ( \"Jim\" , 10 )) . empty? # => true validator . validate User . new \"\" , 10 # => # Object(User).name: # This value should not be blank. (code: 0d0c3254-3642-4cb0-9882-46ee5918e6e3) Notice that in this case we do not need to supply the constraints to the #validate method. This is because the validator is able to extract them from the annotations on the properties. An array of constraints can still be supplied, and will take precedence over the constraints defined within the type. NOTE: By default if a property's value is another object, the sub object will not be validated. use the AVD::Constraints::Valid constraint if you wish to also validate the sub object. This also applies to arrays of objects. Another important thing to point out is that no custom DSL is required to define these constraints. Athena::Validator is intended to be a generic validation solution that could be used outside of the Athena ecosystem. However, in order to be able to use the annotation based approach, you need to be able to apply the annotations to the underlying properties. If this is not possible due to how a specific type is implemented, or if you just don't like the annotation syntax, the type can also be configured via code. # Define a class that can be validated. class User include AVD :: Validatable # This class method is invoked when building the metadata associated with a type, # and can be used to manually wire up the constraints. def self . load_metadata ( metadata : AVD :: Metadata :: ClassMetadata ) : Nil metadata . add_property_constraint \"name\" , AVD :: Constraints :: NotBlank . new end def initialize ( @name : String ); end getter name : String end # Obtain a validator instance. validator = AVD . validator # Validate a user instance, notice we're not passing in any constraints. validator . validate ( User . new ( \"Jim\" )) . empty? # => true validator . validate User . new \"\" # => # Object(User).name: # This value should not be blank. (code: 0d0c3254-3642-4cb0-9882-46ee5918e6e3) The metadata for each type is lazily loaded when an instance of that type is validated, and is only built once. See AVD::Metadata::ClassMetadata for some additional ways to register property constraints.","title":"Validating Objects"},{"location":"Validator/#Athena::Validator--getters","text":"Constraints can also be applied to getter methods of an object. This allows for dynamic validations based on the return value of the method. For example, say we wanted to assert that a user's name is not the same as their password. class User include AVD :: Validatable property name : String property password : String def initialize ( @name : String , @password : String ); end @[ Assert :: IsTrue ( message : \"Your password cannot be the same as your name.\" ) ] def is_safe_password? : Bool @name != @password end end validator = AVD . validator user = User . new \"foo\" , \"foo\" validator . validate ( user ) . empty? # => false user . password = \"bar\" validator . validate ( user ) . empty? # => true","title":"Getters"},{"location":"Validator/#Athena::Validator--custom-constraints","text":"If the built in AVD::Constraints are not sufficient to handle validating a given value/object; custom ones can be defined. Let's make a new constraint that asserts a string contains only alphanumeric characters. This is accomplished by first defining a new class within the AVD::Constraints namespace that inherits from AVD::Constraint . Then define a Validator struct within our constraint that inherits from AVD::ConstraintValidator that actually implements the validation logic. class AVD::Constraints:: AlphaNumeric < AVD :: Constraint # (Optional) A unique error code can also be defined to provide a machine readable identifier for a specific error. NOT_ALPHANUMERIC_ERROR = \"1a83a8bd-ff79-4d5c-96e7-86d0b25b8a09\" # (Optional) Allows using the `.error_message(code : String) : String` method with this constraint. @@error_names = { NOT_ALPHANUMERIC_ERROR => \"NOT_ALPHANUMERIC_ERROR\" , } # Define an initializer with our default message, and any additional arguments specific to this constraint. def initialize ( message : String = \"This value should contain only alphanumeric characters.\" , groups : Array ( String ) | String | Nil = nil , payload : Hash ( String , String )? = nil ) super message , groups , payload end # Define the validator within our constraint that'll contain our validation logic. struct Validator < AVD :: ConstraintValidator # Define our validate method that accepts the value to be validated, and the constraint. # # Overloads can be used to filter values of specific types. def validate ( value : _ , constraint : AVD :: Constraints :: AlphaNumeric ) : Nil # Custom constraints should ignore nil and empty values to allow # other constraints (NotBlank, NotNil, etc.) take care of that return if value . nil? || value == \"\" # We'll cast the value to a string, # alternatively we could just ignore non `String?` values. value = value . to_s # If all the characters of this string are alphanumeric, then it is valid return if value . each_char . all? &. alphanumeric? # Otherwise, it is invalid and we need to add a violation, # see `AVD::ExecutionContextInterface` for additional information. self . context . add_violation constraint . message , NOT_ALPHANUMERIC_ERROR , value end end end puts AVD . validator . validate \"$\" , AVD :: Constraints :: AlphaNumeric . new # => # $: # This value should contain only alphanumeric characters. (code: 1a83a8bd-ff79-4d5c-96e7-86d0b25b8a09) NOTE: The constraint MUST be defined within the AVD::Constraints namespace for implementation reasons. This may change in the future. We are now able to use this constraint as we would one of the built in ones; either by manually instantiating it, or applying an @[Assert::AlphaNumeric] annotation to a property. See AVD::ConstraintValidatorInterface for more information on custom validators.","title":"Custom Constraints"},{"location":"Validator/#Athena::Validator--validation-groups","text":"By default when validating an object, all constraints defined on that type will be checked. However, in some cases you may only want to validate the object against some of those constraints. This can be accomplished via assigning each constraint to a validation group, then apply validation against one specific group of constraints. For example, using our User class from earlier, say we only want to validate certain properties when the user is first created. To do this we can utilize the groups argument that all constraints have. class User include AVD :: Validatable def initialize ( @email : String , @password : String , @city : String ); end @[ Assert :: Email ( groups : \"create\" ) ] getter email : String @[ Assert :: NotBlank ( groups : \"create\" ) ] @[ Assert :: Size ( 7 .. , groups : \"create\" ) ] getter password : String @[ Assert :: Size ( 2 .. ) ] getter city : String end user = User . new \"george@dietrich.app\" , \"monkey123\" , \"\" # Validate the user object, but only for those in the \"create\" group, # if no groups are supplied, then all constraints in the \"default\" group will be used. violations = AVD . validator . validate user , groups : \"create\" # There are no violations since the city's size is not validated since it's not in the \"create\" group. violations . empty? # => true See AVD::Constraint@validation-groups for some expanded information.","title":"Validation Groups"},{"location":"Validator/#Athena::Validator--sequential-validation","text":"By default, all constraints are validated in a single \"batch\". I.e. all constraints within the provided group(s) are validated, without regard to if the previous/next constraint is/was (in)valid. However, an AVD::Constraints::GroupSequence can be used to validate batches of constraints in steps. I.e. validate the first \"batch\" of constraints, and only advance to the next batch if all constraints in that step are valid. @[ Assert :: GroupSequence ( \"User\" , \"Secondary\" ) ] class User include AVD :: Validatable @[ Assert :: NotBlank ] getter username : String @[ Assert :: NotBlank ( groups : \"Secondary\" ) ] getter password : String def initialize ( @username : String , @password : String ); end end # Instantiate a new `User` object where both properties are invalid. user = User . new \"\" , \"\" # Notice there is only one violation since there was a violation in the `User` group, # it did not advance to the `Secondary` group. AVD . validator . validate user # => # Object(User).username: # This value should not be blank. (code: 0d0c3254-3642-4cb0-9882-46ee5918e6e3)","title":"Sequential Validation"},{"location":"Validator/#Athena::Validator--group-sequence-providers","text":"The AVD::Constraints::GroupSequence can be a useful tool for creating efficient validations, but it is quite limiting since the sequence is static on the type. If more flexibility is required the AVD::Constraints::GroupSequence::Provider module can be included into a type. The module allows the object to return the sequence it should use dynamically at runtime. class User include AVD :: Validatable include AVD :: Constraints :: GroupSequence :: Provider # ... def group_sequence : Array ( Array ( String ) | String ) | AVD :: Constraints :: GroupSequence # Build out and return the sequence `self` should use. end end Alternatively, if you only want to apply constraints sequentially on a single property, the AVD::Constraints::Sequentially constraint can be used to do this in a simpler way. NOTE: See the related types for more detailed information.","title":"Group Sequence Providers"},{"location":"Validator/#class-methods","text":"","title":"Class methods"},{"location":"Validator/#Athena::Validator.validator()","text":"Returns a new AVD::Validator::ValidatorInterface . validator = AVD . validator validator . validate \"foo\" , AVD :: Constraints :: NotBlank . new","title":".validator"},{"location":"Validator/Constraint/","text":"abstract class Athena::Validator::Constraint inherits Reference Athena::Validator validates values/objects against a set of constraints, i.e. rules. Each constraint makes an assertive statement that some condition is true. Given a value, a constraint will tell you if that value adheres to the rules of the constraint. An example of this could be asserting a value is not blank, or greater than or equal to another value. It's important to note a constraint does not implement the validation logic itself. Instead, this is handled via an AVD::ConstraintValidator as defined via #validated_by . Having this abstraction allows for better reusability and testability. Athena::Validator comes with a set of common constraints built in. See the individual types within AVD::Constraints for more information. Usage A constraint can be instantiated and passed to a validator directly: # An array of constraints can also be passed. AVD . validator . validate \"\" , AVD :: Constraints :: NotBlank . new Constraint annotation(s) can also be applied to instance variables to assert the value of that property adheres to the constraint. class Example include AVD :: Validatable def initialize ( @name : String ); end # More than one constraint can be applied to a property. @[ Assert :: NotBlank ] property name : String end # Constraints are extracted from the annotations. # An array can also be passed to validate against that list instead. AVD . validator . validate Example . new ( \"Jim\" ) Constraints can also be added manually via code by defining an self.load_metadata(metadata : AVD::Metadata::ClassMetadata) : Nil method and adding the constraints directly to the AVD::Metadata::ClassMetadata instance. # This class method is invoked when building the metadata associated with a type, # and can be used to manually wire up the constraints. def self . load_metadata ( metadata : AVD :: Metadata :: ClassMetadata ) : Nil metadata . add_property_constraint \"name\" , AVD :: Constraints :: NotBlank . new end The metadata for each type is lazily loaded when an instance of that type is validated, and is only built once. Arguments While most constraints can be instantiated with an argless constructor,they do have a set of optional arguments. * The message argument represents the message that should be used if the value is found to not be valid. The message can also include placeholders, in the form of {{ key }} , that will be replaced when the message is rendered. Most commonly this includes the invalid value itself, but some constraints have additional placeholders. * The payload argument can be used to attach any domain specific data to the constraint; such as attaching a severity with each constraint to have more serious violations be handled differently. See the Payload section. * The groups argument can be used to run a subset of the defined constraints. More on this in the Validation Groups section. For example: validator = AVD . validator # Instantiate a constraint with a custom message, using a placeholder. violations = validator . validate - 4 , AVD :: Constraints :: PositiveOrZero . new message : \"{{ value }} is not a valid age. A user cannot have a negative age.\" puts violations # => # -4: # -4 is not a valid age. A user cannot have a negative age. (code: e09e52d0-b549-4ba1-8b4e-420aad76f0de) Customizing the message can be a good way for those consuming the errors to determine WHY a given value is not valid. Default Argument The first argument of the constructor is known as the default argument. This argument is special when using the annotation based approach in that it can be supplied as a positional argument within the annotation. For example the default argument for AVD::Constraints::GreaterThan is the value that the value being validated should be compared against. Thus: @[ Assert :: GreaterThan ( 0 ) ] property age : Int32 Is equivalent to: @[ Assert :: GreaterThan ( value : 0 ) ] property age : Int32 NOTE: Only the first argument can be supplied positionally, all other arguments must be provided as named arguments within the annotation. Message Plurality Athena::Validator has very basic support for pluralizing constraint #message s via AVD::Violation::ConstraintViolationInterface#plural . For example the #message could have different versions based on the plurality of the violation. Currently this only supports two contexts: singular (1/nil) and plural (2+). Multiple messages, separated by a | , can be included as part of an AVD::Constraint message. For example from AVD::Constraints::Size : min_message : String = \"This value is too short. It should have {{ limit }} {{ type }} or more.|This value is too short. It should have {{ limit }} {{ type }}s or more.\" If violations' #plural method returns 1 (or nil ) the first message will be used. If #plural is 2 or more, the latter message will be used. TODO: Support more robust translations; like language or multiple pluralities. Payload The payload argument defined on every AVD::Constraint type can be used to store custom domain specific information with a constraint. This data can later be retrieved off of an AVD::Violation::ConstraintViolationInterface . An example use case for this could be mapping a \"severity\" to a CSS class based on how important each specific constraint is. class User include AVD :: Validatable def initialize ( @email : String , @password : String ); end @[ Assert :: NotBlank ( payload : { \"severity\" => \"error\" }) ] getter email : String @[ Assert :: NotBlank ( payload : { \"severity\" => \"warning\" }) ] getter password : String end violations = AVD . validator . validate User . new \"\" , \"\" # Use this when rendering HTML, or JSON to allow dynamically customizing the response object. violations [ 0 ]. constraint . payload # => {\"severity\" => \"error\"} violations [ 1 ]. constraint . payload # => {\"severity\" => \"warning\"} Validation Groups The groups argument defined on every AVD::Constraint type can be used to run a subset of validations. For example, say we only want to validate certain properties when the user is first created: class User include AVD :: Validatable def initialize ( @email : String , @password : String , @city : String ); end @[ Assert :: Email ( groups : \"create\" ) ] getter email : String @[ Assert :: NotBlank ( groups : \"create\" ) ] @[ Assert :: Size ( 7 .. , groups : \"create\" ) ] getter password : String @[ Assert :: Size ( 2 .. ) ] getter city : String end user = User . new \"george@dietrich.app\" , \"monkey123\" , \"\" # Validate the user object, but only for those in the \"create\" group, # if no groups are supplied, then all constraints in the \"default\" group will be used. violations = AVD . validator . validate user , groups : \"create\" # There are no violations since the city's size is not validated since it's not in the \"create\" group. violations . empty? # => true Using this configuration, there are three groups at play within the User class: 1. default - Contains constraints in the current type, and subtypes, that belong to no other group. I.e. city . 1. User - In this example, equivalent to all constraints in the default group. See AVD::Constraints::GroupSequence , and the note below. 1. create - A custom group that only contains the constraints explicitly associated with it. I.e. email , and password . NOTE: When validating just the User object, the default group is equivalent to the User group. However, if the User object has other embedded types using the AVD::Constraints::Valid constraint, then validating the User object with the User group would only validate constraints that are explicitly in the User group within the embedded types. By default, all constraints are validated in a single \"batch\". I.e. all constraints within the provided group(s) are validated, without regard to if the previous/next constraint is/was (in)valid. However, an AVD::Constraints::GroupSequence can be used to validate batches of constraints in steps. I.e. validate the first \"batch\" of constraints, and only advance to the next batch if all constraints in that step are valid. NOTE: The payload is not used with the framework itself. Custom Constraints If the built in AVD::Constraints are not sufficient to handle validating a given value/object; custom ones can be defined. Let's make a new constraint that asserts a string contains only alphanumeric characters. This is accomplished by first defining a new class within the AVD::Constraints namespace that inherits from AVD::Constraint . Then define a Validator struct within our constraint that inherits from AVD::ConstraintValidator that actually implements the validation logic. class AVD::Constraints:: AlphaNumeric < AVD :: Constraint # (Optional) A unique error code can also be defined to provide a machine readable identifier for a specific error. NOT_ALPHANUMERIC_ERROR = \"1a83a8bd-ff79-4d5c-96e7-86d0b25b8a09\" # (Optional) Allows using the `.error_message(code : String) : String` method with this constraint. @@error_names = { NOT_ALPHANUMERIC_ERROR => \"NOT_ALPHANUMERIC_ERROR\" , } # Define an initializer with our default message, and any additional arguments specific to this constraint. def initialize ( message : String = \"This value should contain only alphanumeric characters.\" , groups : Array ( String ) | String | Nil = nil , payload : Hash ( String , String )? = nil ) super message , groups , payload end # Define the validator within our constraint that'll contain our validation logic. struct Validator < AVD :: ConstraintValidator # Define our validate method that accepts the value to be validated, and the constraint. # # Overloads can be used to filter values of specific types. def validate ( value : _ , constraint : AVD :: Constraints :: AlphaNumeric ) : Nil # Custom constraints should ignore nil and empty values to allow # other constraints (NotBlank, NotNil, etc.) take care of that return if value . nil? || value == \"\" # We'll cast the value to a string, # alternatively we could just ignore non `String?` values. value = value . to_s # If all the characters of this string are alphanumeric, then it is valid return if value . each_char . all? &. alphanumeric? # Otherwise, it is invalid and we need to add a violation, # see `AVD::ExecutionContextInterface` for additional information. self . context . add_violation constraint . message , NOT_ALPHANUMERIC_ERROR , value end end end puts AVD . validator . validate \"$\" , AVD :: Constraints :: AlphaNumeric . new # => # $: # This value should contain only alphanumeric characters. (code: 1a83a8bd-ff79-4d5c-96e7-86d0b25b8a09) NOTE: The constraint MUST be defined within the AVD::Constraints namespace for implementation reasons. This may change in the future. We are now able to use this constraint as we would one of the built in ones; either by manually instantiating it, or applying an @[Assert::AlphaNumeric] annotation to a property. See AVD::ConstraintValidatorInterface for more information on custom validators. NOTE: The AVD::Constraints::Compound constraint can be used to create a constraint that consists of one or more other constraints. Direct known subclasses Athena::Validator::Constraints::Blank Athena::Validator::Constraints::Callback Athena::Validator::Constraints::Choice Athena::Validator::Constraints::Composite Athena::Validator::Constraints::Email Athena::Validator::Constraints::EqualTo(ValueType) Athena::Validator::Constraints::GreaterThan(ValueType) Athena::Validator::Constraints::GreaterThanOrEqual(ValueType) Athena::Validator::Constraints::IP Athena::Validator::Constraints::ISBN Athena::Validator::Constraints::IsFalse Athena::Validator::Constraints::ISIN Athena::Validator::Constraints::IsNil Athena::Validator::Constraints::ISSN Athena::Validator::Constraints::IsTrue Athena::Validator::Constraints::LessThan(ValueType) Athena::Validator::Constraints::LessThanOrEqual(ValueType) Athena::Validator::Constraints::Luhn Athena::Validator::Constraints::NotBlank Athena::Validator::Constraints::NotEqualTo(ValueType) Athena::Validator::Constraints::NotNil Athena::Validator::Constraints::Range Athena::Validator::Constraints::Regex Athena::Validator::Constraints::Size Athena::Validator::Constraints::Unique Athena::Validator::Constraints::URL Athena::Validator::Constraints::Valid Athena::Validator::Spec::FailingConstraint Constants DEFAULT_GROUP = \"default\" The group that self is a part of if no other group(s) are explicitly defined. Class methods .error_name ( error_code : String ) : String Returns the name of the provided error_code . .new ( message : String , groups : Array ( String ) | String | Nil = nil , payload : Hash ( String , String )? = nil ) Methods #add_implicit_group ( group : String ) : Nil Adds the provided group to #groups if self is in the AVD::Constraint::DEFAULT_GROUP . #groups : Array ( String ) The validation groups self is a part of. #groups= ( groups : Array ( String )) The validation groups self is a part of. #message : String Returns the message that should be rendered if self is found to be invalid. NOTE: Some subtypes do not use this and instead define multiple message properties in order to support more specific error messages. #payload : Hash ( String , String )? Returns any domain specific data associated with self . abstract #validated_by : AVD :: ConstraintValidator . class Returns the AVD::ConstraintValidator.class that should handle validating self .","title":"Constraint"},{"location":"Validator/Constraint/#Athena::Validator::Constraint","text":"Athena::Validator validates values/objects against a set of constraints, i.e. rules. Each constraint makes an assertive statement that some condition is true. Given a value, a constraint will tell you if that value adheres to the rules of the constraint. An example of this could be asserting a value is not blank, or greater than or equal to another value. It's important to note a constraint does not implement the validation logic itself. Instead, this is handled via an AVD::ConstraintValidator as defined via #validated_by . Having this abstraction allows for better reusability and testability. Athena::Validator comes with a set of common constraints built in. See the individual types within AVD::Constraints for more information.","title":"Constraint"},{"location":"Validator/Constraint/#Athena::Validator::Constraint--usage","text":"A constraint can be instantiated and passed to a validator directly: # An array of constraints can also be passed. AVD . validator . validate \"\" , AVD :: Constraints :: NotBlank . new Constraint annotation(s) can also be applied to instance variables to assert the value of that property adheres to the constraint. class Example include AVD :: Validatable def initialize ( @name : String ); end # More than one constraint can be applied to a property. @[ Assert :: NotBlank ] property name : String end # Constraints are extracted from the annotations. # An array can also be passed to validate against that list instead. AVD . validator . validate Example . new ( \"Jim\" ) Constraints can also be added manually via code by defining an self.load_metadata(metadata : AVD::Metadata::ClassMetadata) : Nil method and adding the constraints directly to the AVD::Metadata::ClassMetadata instance. # This class method is invoked when building the metadata associated with a type, # and can be used to manually wire up the constraints. def self . load_metadata ( metadata : AVD :: Metadata :: ClassMetadata ) : Nil metadata . add_property_constraint \"name\" , AVD :: Constraints :: NotBlank . new end The metadata for each type is lazily loaded when an instance of that type is validated, and is only built once.","title":"Usage"},{"location":"Validator/Constraint/#Athena::Validator::Constraint--arguments","text":"While most constraints can be instantiated with an argless constructor,they do have a set of optional arguments. * The message argument represents the message that should be used if the value is found to not be valid. The message can also include placeholders, in the form of {{ key }} , that will be replaced when the message is rendered. Most commonly this includes the invalid value itself, but some constraints have additional placeholders. * The payload argument can be used to attach any domain specific data to the constraint; such as attaching a severity with each constraint to have more serious violations be handled differently. See the Payload section. * The groups argument can be used to run a subset of the defined constraints. More on this in the Validation Groups section. For example: validator = AVD . validator # Instantiate a constraint with a custom message, using a placeholder. violations = validator . validate - 4 , AVD :: Constraints :: PositiveOrZero . new message : \"{{ value }} is not a valid age. A user cannot have a negative age.\" puts violations # => # -4: # -4 is not a valid age. A user cannot have a negative age. (code: e09e52d0-b549-4ba1-8b4e-420aad76f0de) Customizing the message can be a good way for those consuming the errors to determine WHY a given value is not valid.","title":"Arguments"},{"location":"Validator/Constraint/#Athena::Validator::Constraint--default-argument","text":"The first argument of the constructor is known as the default argument. This argument is special when using the annotation based approach in that it can be supplied as a positional argument within the annotation. For example the default argument for AVD::Constraints::GreaterThan is the value that the value being validated should be compared against. Thus: @[ Assert :: GreaterThan ( 0 ) ] property age : Int32 Is equivalent to: @[ Assert :: GreaterThan ( value : 0 ) ] property age : Int32 NOTE: Only the first argument can be supplied positionally, all other arguments must be provided as named arguments within the annotation.","title":"Default Argument"},{"location":"Validator/Constraint/#Athena::Validator::Constraint--message-plurality","text":"Athena::Validator has very basic support for pluralizing constraint #message s via AVD::Violation::ConstraintViolationInterface#plural . For example the #message could have different versions based on the plurality of the violation. Currently this only supports two contexts: singular (1/nil) and plural (2+). Multiple messages, separated by a | , can be included as part of an AVD::Constraint message. For example from AVD::Constraints::Size : min_message : String = \"This value is too short. It should have {{ limit }} {{ type }} or more.|This value is too short. It should have {{ limit }} {{ type }}s or more.\" If violations' #plural method returns 1 (or nil ) the first message will be used. If #plural is 2 or more, the latter message will be used. TODO: Support more robust translations; like language or multiple pluralities.","title":"Message Plurality"},{"location":"Validator/Constraint/#Athena::Validator::Constraint--payload","text":"The payload argument defined on every AVD::Constraint type can be used to store custom domain specific information with a constraint. This data can later be retrieved off of an AVD::Violation::ConstraintViolationInterface . An example use case for this could be mapping a \"severity\" to a CSS class based on how important each specific constraint is. class User include AVD :: Validatable def initialize ( @email : String , @password : String ); end @[ Assert :: NotBlank ( payload : { \"severity\" => \"error\" }) ] getter email : String @[ Assert :: NotBlank ( payload : { \"severity\" => \"warning\" }) ] getter password : String end violations = AVD . validator . validate User . new \"\" , \"\" # Use this when rendering HTML, or JSON to allow dynamically customizing the response object. violations [ 0 ]. constraint . payload # => {\"severity\" => \"error\"} violations [ 1 ]. constraint . payload # => {\"severity\" => \"warning\"}","title":"Payload"},{"location":"Validator/Constraint/#Athena::Validator::Constraint--validation-groups","text":"The groups argument defined on every AVD::Constraint type can be used to run a subset of validations. For example, say we only want to validate certain properties when the user is first created: class User include AVD :: Validatable def initialize ( @email : String , @password : String , @city : String ); end @[ Assert :: Email ( groups : \"create\" ) ] getter email : String @[ Assert :: NotBlank ( groups : \"create\" ) ] @[ Assert :: Size ( 7 .. , groups : \"create\" ) ] getter password : String @[ Assert :: Size ( 2 .. ) ] getter city : String end user = User . new \"george@dietrich.app\" , \"monkey123\" , \"\" # Validate the user object, but only for those in the \"create\" group, # if no groups are supplied, then all constraints in the \"default\" group will be used. violations = AVD . validator . validate user , groups : \"create\" # There are no violations since the city's size is not validated since it's not in the \"create\" group. violations . empty? # => true Using this configuration, there are three groups at play within the User class: 1. default - Contains constraints in the current type, and subtypes, that belong to no other group. I.e. city . 1. User - In this example, equivalent to all constraints in the default group. See AVD::Constraints::GroupSequence , and the note below. 1. create - A custom group that only contains the constraints explicitly associated with it. I.e. email , and password . NOTE: When validating just the User object, the default group is equivalent to the User group. However, if the User object has other embedded types using the AVD::Constraints::Valid constraint, then validating the User object with the User group would only validate constraints that are explicitly in the User group within the embedded types. By default, all constraints are validated in a single \"batch\". I.e. all constraints within the provided group(s) are validated, without regard to if the previous/next constraint is/was (in)valid. However, an AVD::Constraints::GroupSequence can be used to validate batches of constraints in steps. I.e. validate the first \"batch\" of constraints, and only advance to the next batch if all constraints in that step are valid. NOTE: The payload is not used with the framework itself.","title":"Validation Groups"},{"location":"Validator/Constraint/#Athena::Validator::Constraint--custom-constraints","text":"If the built in AVD::Constraints are not sufficient to handle validating a given value/object; custom ones can be defined. Let's make a new constraint that asserts a string contains only alphanumeric characters. This is accomplished by first defining a new class within the AVD::Constraints namespace that inherits from AVD::Constraint . Then define a Validator struct within our constraint that inherits from AVD::ConstraintValidator that actually implements the validation logic. class AVD::Constraints:: AlphaNumeric < AVD :: Constraint # (Optional) A unique error code can also be defined to provide a machine readable identifier for a specific error. NOT_ALPHANUMERIC_ERROR = \"1a83a8bd-ff79-4d5c-96e7-86d0b25b8a09\" # (Optional) Allows using the `.error_message(code : String) : String` method with this constraint. @@error_names = { NOT_ALPHANUMERIC_ERROR => \"NOT_ALPHANUMERIC_ERROR\" , } # Define an initializer with our default message, and any additional arguments specific to this constraint. def initialize ( message : String = \"This value should contain only alphanumeric characters.\" , groups : Array ( String ) | String | Nil = nil , payload : Hash ( String , String )? = nil ) super message , groups , payload end # Define the validator within our constraint that'll contain our validation logic. struct Validator < AVD :: ConstraintValidator # Define our validate method that accepts the value to be validated, and the constraint. # # Overloads can be used to filter values of specific types. def validate ( value : _ , constraint : AVD :: Constraints :: AlphaNumeric ) : Nil # Custom constraints should ignore nil and empty values to allow # other constraints (NotBlank, NotNil, etc.) take care of that return if value . nil? || value == \"\" # We'll cast the value to a string, # alternatively we could just ignore non `String?` values. value = value . to_s # If all the characters of this string are alphanumeric, then it is valid return if value . each_char . all? &. alphanumeric? # Otherwise, it is invalid and we need to add a violation, # see `AVD::ExecutionContextInterface` for additional information. self . context . add_violation constraint . message , NOT_ALPHANUMERIC_ERROR , value end end end puts AVD . validator . validate \"$\" , AVD :: Constraints :: AlphaNumeric . new # => # $: # This value should contain only alphanumeric characters. (code: 1a83a8bd-ff79-4d5c-96e7-86d0b25b8a09) NOTE: The constraint MUST be defined within the AVD::Constraints namespace for implementation reasons. This may change in the future. We are now able to use this constraint as we would one of the built in ones; either by manually instantiating it, or applying an @[Assert::AlphaNumeric] annotation to a property. See AVD::ConstraintValidatorInterface for more information on custom validators. NOTE: The AVD::Constraints::Compound constraint can be used to create a constraint that consists of one or more other constraints.","title":"Custom Constraints"},{"location":"Validator/Constraint/#direct-known-subclasses","text":"Athena::Validator::Constraints::Blank Athena::Validator::Constraints::Callback Athena::Validator::Constraints::Choice Athena::Validator::Constraints::Composite Athena::Validator::Constraints::Email Athena::Validator::Constraints::EqualTo(ValueType) Athena::Validator::Constraints::GreaterThan(ValueType) Athena::Validator::Constraints::GreaterThanOrEqual(ValueType) Athena::Validator::Constraints::IP Athena::Validator::Constraints::ISBN Athena::Validator::Constraints::IsFalse Athena::Validator::Constraints::ISIN Athena::Validator::Constraints::IsNil Athena::Validator::Constraints::ISSN Athena::Validator::Constraints::IsTrue Athena::Validator::Constraints::LessThan(ValueType) Athena::Validator::Constraints::LessThanOrEqual(ValueType) Athena::Validator::Constraints::Luhn Athena::Validator::Constraints::NotBlank Athena::Validator::Constraints::NotEqualTo(ValueType) Athena::Validator::Constraints::NotNil Athena::Validator::Constraints::Range Athena::Validator::Constraints::Regex Athena::Validator::Constraints::Size Athena::Validator::Constraints::Unique Athena::Validator::Constraints::URL Athena::Validator::Constraints::Valid Athena::Validator::Spec::FailingConstraint","title":"Direct known subclasses"},{"location":"Validator/Constraint/#constants","text":"","title":"Constants"},{"location":"Validator/Constraint/#Athena::Validator::Constraint::DEFAULT_GROUP","text":"The group that self is a part of if no other group(s) are explicitly defined.","title":"DEFAULT_GROUP"},{"location":"Validator/Constraint/#class-methods","text":"","title":"Class methods"},{"location":"Validator/Constraint/#Athena::Validator::Constraint.error_name(error_code)","text":"Returns the name of the provided error_code .","title":".error_name"},{"location":"Validator/Constraint/#Athena::Validator::Constraint.new(message,groups,payload)","text":"","title":".new"},{"location":"Validator/Constraint/#methods","text":"","title":"Methods"},{"location":"Validator/Constraint/#Athena::Validator::Constraint#add_implicit_group(group)","text":"Adds the provided group to #groups if self is in the AVD::Constraint::DEFAULT_GROUP .","title":"#add_implicit_group"},{"location":"Validator/Constraint/#Athena::Validator::Constraint#groups()","text":"The validation groups self is a part of.","title":"#groups"},{"location":"Validator/Constraint/#Athena::Validator::Constraint#groups=(groups)","text":"The validation groups self is a part of.","title":"#groups="},{"location":"Validator/Constraint/#Athena::Validator::Constraint#message()","text":"Returns the message that should be rendered if self is found to be invalid. NOTE: Some subtypes do not use this and instead define multiple message properties in order to support more specific error messages.","title":"#message"},{"location":"Validator/Constraint/#Athena::Validator::Constraint#payload()","text":"Returns any domain specific data associated with self .","title":"#payload"},{"location":"Validator/Constraint/#Athena::Validator::Constraint#validated_by()","text":"Returns the AVD::ConstraintValidator.class that should handle validating self .","title":"#validated_by"},{"location":"Validator/ConstraintValidator/","text":"abstract struct Athena::Validator::ConstraintValidator inherits Struct Basic implementation of AVD::ConstraintValidatorInterface . Included modules Athena::Validator::ConstraintValidatorInterface Direct known subclasses Athena::Validator::Constraints::All::Validator Athena::Validator::Constraints::AtLeastOneOf::Validator Athena::Validator::Constraints::Blank::Validator Athena::Validator::Constraints::Callback::Validator Athena::Validator::Constraints::Choice::Validator Athena::Validator::Constraints::ComparisonValidator Athena::Validator::Constraints::Compound::Validator Athena::Validator::Constraints::Email::Validator Athena::Validator::Constraints::IP::Validator Athena::Validator::Constraints::ISBN::Validator Athena::Validator::Constraints::IsFalse::Validator Athena::Validator::Constraints::ISIN::Validator Athena::Validator::Constraints::IsNil::Validator Athena::Validator::Constraints::ISSN::Validator Athena::Validator::Constraints::IsTrue::Validator Athena::Validator::Constraints::Luhn::Validator Athena::Validator::Constraints::NotBlank::Validator Athena::Validator::Constraints::NotNil::Validator Athena::Validator::Constraints::Range::Validator Athena::Validator::Constraints::Regex::Validator Athena::Validator::Constraints::Sequentially::Validator Athena::Validator::Constraints::Size::Validator Athena::Validator::Constraints::Unique::Validator Athena::Validator::Constraints::URL::Validator Athena::Validator::Constraints::Valid::Validator Athena::Validator::ServiceConstraintValidator Athena::Validator::Spec::FailingConstraint::Validator Class methods .new Methods #context : AVD::ExecutionContextInterface Returns the a reference to the AVD::ExecutionContextInterface to which violations within self should be added. See the type for more information. #raise_invalid_type ( value : _ , supported_types : String ) : NoReturn Can be used to raise an AVD::Exceptions::UnexpectedValueError in case self is only able to validate values of the supported_types . # Define a validate method to catch values of other types. # Overloads above would handle the valid types. def validate ( value : _ , constraint : AVD :: Constraints :: MyConstraint ) : Nil self . raise_invalid_type value , \"Int | Float\" end This would result in a violation with the message This value should be a valid: Int | Float being added to the current #context . #validate ( value : _ , constraint : AVD::Constraint ) : Nil Validate the provided value against the provided constraint . Violations should be added to the current #context .","title":"ConstraintValidator"},{"location":"Validator/ConstraintValidator/#Athena::Validator::ConstraintValidator","text":"Basic implementation of AVD::ConstraintValidatorInterface .","title":"ConstraintValidator"},{"location":"Validator/ConstraintValidator/#included-modules","text":"Athena::Validator::ConstraintValidatorInterface","title":"Included modules"},{"location":"Validator/ConstraintValidator/#direct-known-subclasses","text":"Athena::Validator::Constraints::All::Validator Athena::Validator::Constraints::AtLeastOneOf::Validator Athena::Validator::Constraints::Blank::Validator Athena::Validator::Constraints::Callback::Validator Athena::Validator::Constraints::Choice::Validator Athena::Validator::Constraints::ComparisonValidator Athena::Validator::Constraints::Compound::Validator Athena::Validator::Constraints::Email::Validator Athena::Validator::Constraints::IP::Validator Athena::Validator::Constraints::ISBN::Validator Athena::Validator::Constraints::IsFalse::Validator Athena::Validator::Constraints::ISIN::Validator Athena::Validator::Constraints::IsNil::Validator Athena::Validator::Constraints::ISSN::Validator Athena::Validator::Constraints::IsTrue::Validator Athena::Validator::Constraints::Luhn::Validator Athena::Validator::Constraints::NotBlank::Validator Athena::Validator::Constraints::NotNil::Validator Athena::Validator::Constraints::Range::Validator Athena::Validator::Constraints::Regex::Validator Athena::Validator::Constraints::Sequentially::Validator Athena::Validator::Constraints::Size::Validator Athena::Validator::Constraints::Unique::Validator Athena::Validator::Constraints::URL::Validator Athena::Validator::Constraints::Valid::Validator Athena::Validator::ServiceConstraintValidator Athena::Validator::Spec::FailingConstraint::Validator","title":"Direct known subclasses"},{"location":"Validator/ConstraintValidator/#class-methods","text":"","title":"Class methods"},{"location":"Validator/ConstraintValidator/#Athena::Validator::ConstraintValidator.new()","text":"","title":".new"},{"location":"Validator/ConstraintValidator/#methods","text":"","title":"Methods"},{"location":"Validator/ConstraintValidator/#Athena::Validator::ConstraintValidator#context()","text":"Returns the a reference to the AVD::ExecutionContextInterface to which violations within self should be added. See the type for more information.","title":"#context"},{"location":"Validator/ConstraintValidator/#Athena::Validator::ConstraintValidator#raise_invalid_type(value,supported_types)","text":"Can be used to raise an AVD::Exceptions::UnexpectedValueError in case self is only able to validate values of the supported_types . # Define a validate method to catch values of other types. # Overloads above would handle the valid types. def validate ( value : _ , constraint : AVD :: Constraints :: MyConstraint ) : Nil self . raise_invalid_type value , \"Int | Float\" end This would result in a violation with the message This value should be a valid: Int | Float being added to the current #context .","title":"#raise_invalid_type"},{"location":"Validator/ConstraintValidator/#Athena::Validator::ConstraintValidator#validate(value,constraint)","text":"Validate the provided value against the provided constraint . Violations should be added to the current #context .","title":"#validate"},{"location":"Validator/ConstraintValidatorFactory/","text":"struct Athena::Validator::ConstraintValidatorFactory inherits Struct Basic implementation of AVD::ConstraintValidatorFactoryInterface . Included modules Athena::Validator::ConstraintValidatorFactoryInterface Methods #validator ( validator_class : AVD :: ServiceConstraintValidator . class ) : AVD::ConstraintValidator Returns an AVD::ConstraintValidator based on the provided validator_class . NOTE: This overloaded is intended to be used for service based validators that are already instantiated and were provided via DI. #validator ( validator_class : AVD :: ConstraintValidator . class ) : AVD::ConstraintValidator Returns an AVD::ConstraintValidator based on the provided validator_class .","title":"ConstraintValidatorFactory"},{"location":"Validator/ConstraintValidatorFactory/#Athena::Validator::ConstraintValidatorFactory","text":"Basic implementation of AVD::ConstraintValidatorFactoryInterface .","title":"ConstraintValidatorFactory"},{"location":"Validator/ConstraintValidatorFactory/#included-modules","text":"Athena::Validator::ConstraintValidatorFactoryInterface","title":"Included modules"},{"location":"Validator/ConstraintValidatorFactory/#methods","text":"","title":"Methods"},{"location":"Validator/ConstraintValidatorFactory/#Athena::Validator::ConstraintValidatorFactory#validator(validator_class)","text":"Returns an AVD::ConstraintValidator based on the provided validator_class . NOTE: This overloaded is intended to be used for service based validators that are already instantiated and were provided via DI.","title":"#validator"},{"location":"Validator/ConstraintValidatorFactory/#Athena::Validator::ConstraintValidatorFactory#validator(validator_class)","text":"Returns an AVD::ConstraintValidator based on the provided validator_class .","title":"#validator"},{"location":"Validator/ConstraintValidatorFactoryInterface/","text":"module Athena::Validator::ConstraintValidatorFactoryInterface Provides validator instances based on a validator class, caching the instance. AVD::ServiceConstraintValidator s are instantiated externally and injected into the factory. Direct including types Athena::Validator::ConstraintValidatorFactory Methods abstract #validator ( validator : AVD :: ConstraintValidator . class ) : AVD::ConstraintValidatorInterface Returns an AVD::ConstraintValidatorInterface instance based on the provided validator_class .","title":"ConstraintValidatorFactoryInterface"},{"location":"Validator/ConstraintValidatorFactoryInterface/#Athena::Validator::ConstraintValidatorFactoryInterface","text":"Provides validator instances based on a validator class, caching the instance. AVD::ServiceConstraintValidator s are instantiated externally and injected into the factory.","title":"ConstraintValidatorFactoryInterface"},{"location":"Validator/ConstraintValidatorFactoryInterface/#direct-including-types","text":"Athena::Validator::ConstraintValidatorFactory","title":"Direct including types"},{"location":"Validator/ConstraintValidatorFactoryInterface/#methods","text":"","title":"Methods"},{"location":"Validator/ConstraintValidatorFactoryInterface/#Athena::Validator::ConstraintValidatorFactoryInterface#validator(validator)","text":"Returns an AVD::ConstraintValidatorInterface instance based on the provided validator_class .","title":"#validator"},{"location":"Validator/ConstraintValidatorInterface/","text":"module Athena::Validator::ConstraintValidatorInterface A constraint validator is responsible for implementing the actual validation logic for a given AVD::Constraint . Constraint validators should inherit from this type and implement a #validate method. Most commonly the validator type will be defined within the namespace of the related AVD::Constraint itself. The #validate method itself does not return anything. Violations are added to the current #context , either as a single error message, or augmented with additional metadata about the failure. See AVD::ExecutionContextInterface for more information on how violations can be added. Example class AVD::Constraints:: MyConstraint < AVD :: Constraint # Initializer/etc for the constraint struct Validator < AVD :: ConstraintValidator # Define a validate method that handles values of any type, and our `MyConstraint` constraint. def validate ( value : _ , constraint : AVD :: Constraints :: MyConstraint ) : Nil # Implement logic to determine if the value is valid. # Violations should be added to the current `#context`, # See `AVD::ExecutionContextInterface` for more information. end end end Overloads of the #validate method can also be used to handle validating values of different types independently. If the value cannot be handled by any of self 's validators, it is handled via AVD::ConstraintValidator#validate and is essentially a noop. If a AVD::Constraint can only support values of certain types, AVD::ConstraintValidator#raise_invalid_type in a catchall overload can be used to add an invalid type AVD::Violation::ConstraintViolationInterface . struct Validator < AVD :: ConstraintValidator def validate ( value : Number , constraint : AVD :: Constraints :: MyConstraint ) : Nil # Handle validating `Number` values end def validate ( value : Time , constraint : AVD :: Constraints :: MyConstraint ) : Nil # Handle validating `Time` values end def validate ( value : _ , constraint : AVD :: Constraints :: MyConstraint ) : Nil # Add an invalid type violation for values of all other types. self . raise_invalid_type value , \"Number | Time\" end end NOTE: Normally custom validators should not handle nil or blank values as they are handled via other constraints. Service Based Validators If you're using Athena::Validator within the Athena ecosystem, constraint validators can also be defined as services if they require external dependencies. See AVD::ServiceConstraintValidator and Athena::Routing validator extension documentation for more information. Direct including types Athena::Validator::ConstraintValidator Methods abstract #context : AVD::ExecutionContextInterface Returns the a reference to the AVD::ExecutionContextInterface to which violations within self should be added. See the type for more information. abstract #validate ( value : _ , constraint : AVD::Constraint ) : Nil Validate the provided value against the provided constraint . Violations should be added to the current #context .","title":"ConstraintValidatorInterface"},{"location":"Validator/ConstraintValidatorInterface/#Athena::Validator::ConstraintValidatorInterface","text":"A constraint validator is responsible for implementing the actual validation logic for a given AVD::Constraint . Constraint validators should inherit from this type and implement a #validate method. Most commonly the validator type will be defined within the namespace of the related AVD::Constraint itself. The #validate method itself does not return anything. Violations are added to the current #context , either as a single error message, or augmented with additional metadata about the failure. See AVD::ExecutionContextInterface for more information on how violations can be added.","title":"ConstraintValidatorInterface"},{"location":"Validator/ConstraintValidatorInterface/#Athena::Validator::ConstraintValidatorInterface--example","text":"class AVD::Constraints:: MyConstraint < AVD :: Constraint # Initializer/etc for the constraint struct Validator < AVD :: ConstraintValidator # Define a validate method that handles values of any type, and our `MyConstraint` constraint. def validate ( value : _ , constraint : AVD :: Constraints :: MyConstraint ) : Nil # Implement logic to determine if the value is valid. # Violations should be added to the current `#context`, # See `AVD::ExecutionContextInterface` for more information. end end end Overloads of the #validate method can also be used to handle validating values of different types independently. If the value cannot be handled by any of self 's validators, it is handled via AVD::ConstraintValidator#validate and is essentially a noop. If a AVD::Constraint can only support values of certain types, AVD::ConstraintValidator#raise_invalid_type in a catchall overload can be used to add an invalid type AVD::Violation::ConstraintViolationInterface . struct Validator < AVD :: ConstraintValidator def validate ( value : Number , constraint : AVD :: Constraints :: MyConstraint ) : Nil # Handle validating `Number` values end def validate ( value : Time , constraint : AVD :: Constraints :: MyConstraint ) : Nil # Handle validating `Time` values end def validate ( value : _ , constraint : AVD :: Constraints :: MyConstraint ) : Nil # Add an invalid type violation for values of all other types. self . raise_invalid_type value , \"Number | Time\" end end NOTE: Normally custom validators should not handle nil or blank values as they are handled via other constraints.","title":"Example"},{"location":"Validator/ConstraintValidatorInterface/#Athena::Validator::ConstraintValidatorInterface--service-based-validators","text":"If you're using Athena::Validator within the Athena ecosystem, constraint validators can also be defined as services if they require external dependencies. See AVD::ServiceConstraintValidator and Athena::Routing validator extension documentation for more information.","title":"Service Based Validators"},{"location":"Validator/ConstraintValidatorInterface/#direct-including-types","text":"Athena::Validator::ConstraintValidator","title":"Direct including types"},{"location":"Validator/ConstraintValidatorInterface/#methods","text":"","title":"Methods"},{"location":"Validator/ConstraintValidatorInterface/#Athena::Validator::ConstraintValidatorInterface#context()","text":"Returns the a reference to the AVD::ExecutionContextInterface to which violations within self should be added. See the type for more information.","title":"#context"},{"location":"Validator/ConstraintValidatorInterface/#Athena::Validator::ConstraintValidatorInterface#validate(value,constraint)","text":"Validate the provided value against the provided constraint . Violations should be added to the current #context .","title":"#validate"},{"location":"Validator/Constraints/","text":"module Athena::Validator::Constraints Contains all of the built in AVD::Constraint s. See each individual constraint for more information. The Assert alias is used to apply these constraints via annotations.","title":"Constraints"},{"location":"Validator/Constraints/#Athena::Validator::Constraints","text":"Contains all of the built in AVD::Constraint s. See each individual constraint for more information. The Assert alias is used to apply these constraints via annotations.","title":"Constraints"},{"location":"Validator/Constraints/AbstractComparison/","text":"module Athena::Validator::Constraints::AbstractComparison(ValueType) Defines common logic for comparison based constraints, such as AVD::Constraints::GreaterThan , or AVD::Constraints::EqualTo . Direct including types Athena::Validator::Constraints::EqualTo(ValueType) Athena::Validator::Constraints::GreaterThan(ValueType) Athena::Validator::Constraints::GreaterThanOrEqual(ValueType) Athena::Validator::Constraints::LessThan(ValueType) Athena::Validator::Constraints::LessThanOrEqual(ValueType) Athena::Validator::Constraints::NotEqualTo(ValueType) Class methods .new ( value : ValueType , message : String = default_error_message , groups : Array ( String ) | String | Nil = nil , payload : Hash ( String , String )? = nil ) Methods abstract #default_error_message : String Returns the AVD::Constraint#message for this constraint. #value : ValueType Returns the expected value. #value_type : ValueType . class Returns the type of the expected value.","title":"AbstractComparison"},{"location":"Validator/Constraints/AbstractComparison/#Athena::Validator::Constraints::AbstractComparison","text":"Defines common logic for comparison based constraints, such as AVD::Constraints::GreaterThan , or AVD::Constraints::EqualTo .","title":"AbstractComparison"},{"location":"Validator/Constraints/AbstractComparison/#direct-including-types","text":"Athena::Validator::Constraints::EqualTo(ValueType) Athena::Validator::Constraints::GreaterThan(ValueType) Athena::Validator::Constraints::GreaterThanOrEqual(ValueType) Athena::Validator::Constraints::LessThan(ValueType) Athena::Validator::Constraints::LessThanOrEqual(ValueType) Athena::Validator::Constraints::NotEqualTo(ValueType)","title":"Direct including types"},{"location":"Validator/Constraints/AbstractComparison/#class-methods","text":"","title":"Class methods"},{"location":"Validator/Constraints/AbstractComparison/#Athena::Validator::Constraints::AbstractComparison.new(value,message,groups,payload)","text":"","title":".new"},{"location":"Validator/Constraints/AbstractComparison/#methods","text":"","title":"Methods"},{"location":"Validator/Constraints/AbstractComparison/#Athena::Validator::Constraints::AbstractComparison#default_error_message()","text":"Returns the AVD::Constraint#message for this constraint.","title":"#default_error_message"},{"location":"Validator/Constraints/AbstractComparison/#Athena::Validator::Constraints::AbstractComparison#value()","text":"Returns the expected value.","title":"#value"},{"location":"Validator/Constraints/AbstractComparison/#Athena::Validator::Constraints::AbstractComparison#value_type()","text":"Returns the type of the expected value.","title":"#value_type"},{"location":"Validator/Constraints/All/","text":"class Athena::Validator::Constraints::All inherits Athena::Validator::Constraints::Composite Validates each element of an Iterable is valid based on a collection of constraints. Configuration Required Arguments constraints Type: Array(AVD::Constraint) | AVD::Constraint The AVD::Constraint (s) that you want to apply to each element of the underlying iterable. Optional Arguments NOTE: This constraint does not support a message argument. groups Type: Array(String) | String | Nil Default: nil The validation groups this constraint belongs to. AVD::Constraint::DEFAULT_GROUP is assumed if nil . payload Type: Hash(String, String)? Default: nil Any arbitrary domain-specific data that should be stored with this constraint. The payload is not used by Athena::Validator , but its processing is completely up to you. Usage class Example include AVD :: Validatable def initialize ( @strings : Array ( String )); end # Assert each string is not blank and is at least 5 characters long. @[ Assert :: All ( [ @[ Assert :: NotBlank ] , @[ Assert :: Size ( 5 .. ) ] , ] ) ] getter strings : Array ( String ) end NOTE: The annotation approach only supports two levels of nested annotations. Manually wire up the constraint via code if you require more than that. Class methods .new ( constraints : Array ( AVD::Constraint ) | AVD::Constraint , groups : Array ( String ) | String | Nil = nil , payload : Hash ( String , String )? = nil ) Methods #validated_by : AVD :: ConstraintValidator . class Returns the AVD::ConstraintValidator.class that should handle validating self .","title":"All"},{"location":"Validator/Constraints/All/#Athena::Validator::Constraints::All","text":"Validates each element of an Iterable is valid based on a collection of constraints.","title":"All"},{"location":"Validator/Constraints/All/#Athena::Validator::Constraints::All--configuration","text":"","title":"Configuration"},{"location":"Validator/Constraints/All/#Athena::Validator::Constraints::All--required-arguments","text":"","title":"Required Arguments"},{"location":"Validator/Constraints/All/#Athena::Validator::Constraints::All--constraints","text":"Type: Array(AVD::Constraint) | AVD::Constraint The AVD::Constraint (s) that you want to apply to each element of the underlying iterable.","title":"constraints"},{"location":"Validator/Constraints/All/#Athena::Validator::Constraints::All--optional-arguments","text":"NOTE: This constraint does not support a message argument.","title":"Optional Arguments"},{"location":"Validator/Constraints/All/#Athena::Validator::Constraints::All--groups","text":"Type: Array(String) | String | Nil Default: nil The validation groups this constraint belongs to. AVD::Constraint::DEFAULT_GROUP is assumed if nil .","title":"groups"},{"location":"Validator/Constraints/All/#Athena::Validator::Constraints::All--payload","text":"Type: Hash(String, String)? Default: nil Any arbitrary domain-specific data that should be stored with this constraint. The payload is not used by Athena::Validator , but its processing is completely up to you.","title":"payload"},{"location":"Validator/Constraints/All/#Athena::Validator::Constraints::All--usage","text":"class Example include AVD :: Validatable def initialize ( @strings : Array ( String )); end # Assert each string is not blank and is at least 5 characters long. @[ Assert :: All ( [ @[ Assert :: NotBlank ] , @[ Assert :: Size ( 5 .. ) ] , ] ) ] getter strings : Array ( String ) end NOTE: The annotation approach only supports two levels of nested annotations. Manually wire up the constraint via code if you require more than that.","title":"Usage"},{"location":"Validator/Constraints/All/#class-methods","text":"","title":"Class methods"},{"location":"Validator/Constraints/All/#Athena::Validator::Constraints::All.new(constraints,groups,payload)","text":"","title":".new"},{"location":"Validator/Constraints/All/#methods","text":"","title":"Methods"},{"location":"Validator/Constraints/All/#Athena::Validator::Constraints::All#validated_by()","text":"Returns the AVD::ConstraintValidator.class that should handle validating self .","title":"#validated_by"},{"location":"Validator/Constraints/All/Validator/","text":"struct Athena::Validator::Constraints::All::Validator inherits Athena::Validator::ConstraintValidator Methods #validate ( value : Hash ?, constraint : AVD::Constraints::All ) : Nil :inherit: #validate ( value : Indexable? , constraint : AVD::Constraints::All ) : Nil :inherit: #validate ( value : _ , constraint : AVD::Constraints::All ) : NoReturn :inherit:","title":"Validator"},{"location":"Validator/Constraints/All/Validator/#Athena::Validator::Constraints::All::Validator","text":"","title":"Validator"},{"location":"Validator/Constraints/All/Validator/#methods","text":"","title":"Methods"},{"location":"Validator/Constraints/All/Validator/#Athena::Validator::Constraints::All::Validator#validate(value,constraint)","text":":inherit:","title":"#validate"},{"location":"Validator/Constraints/All/Validator/#Athena::Validator::Constraints::All::Validator#validate(value,constraint)","text":":inherit:","title":"#validate"},{"location":"Validator/Constraints/All/Validator/#Athena::Validator::Constraints::All::Validator#validate(value,constraint)","text":":inherit:","title":"#validate"},{"location":"Validator/Constraints/AtLeastOneOf/","text":"class Athena::Validator::Constraints::AtLeastOneOf inherits Athena::Validator::Constraints::Composite Validates that a value satisfies at least one of the provided constraints. Validation stops as soon as one constraint is satisfied. Configuration Required Arguments constraints Type: Array(AVD::Constraint) | AVD::Constraint The AVD::Constraint (s) from which at least one of has to be satisfied in order for the validation to succeed. Optional Arguments include_internal_messages Type: Bool Default: true If the validation failed message should include the list of messages for the internal constraints. See the message argument for an example. message_collection Type: String Default: Each element of this collection should satisfy its own set of constraints. The message that will be shown if validation fails and the internal constraint is an AVD::Constraints::All . See the message argument for an example. message Type: String Default: This value should satisfy at least one of the following constraints: The intro that will be shown if validation fails. By default, it'll be followed by the list of messages from the internal constraints ; configurable via the include_internal_messages argument. For example, if the grades property in the example below fails to validate, the message will be: This value should satisfy at least one of the following constraints: [1] This value is too short. It should have 3 items or more. [2] Each element of this collection should satisfy its own set of constraints. groups Type: Array(String) | String | Nil Default: nil The validation groups this constraint belongs to. AVD::Constraint::DEFAULT_GROUP is assumed if nil . payload Type: Hash(String, String)? Default: nil Any arbitrary domain-specific data that should be stored with this constraint. The payload is not used by Athena::Validator , but its processing is completely up to you. Usage class Example include AVD :: Validatable def initialize ( @password : String , @grades : Array ( Int32 )); end # Asserts the password contains an `#` or is at least 10 characters long. @[ Assert :: AtLeastOneOf ( [ @[ Assert :: Regex ( /#/ ) ] , @[ Assert :: Size ( 10 .. ) ] , ] ) ] getter password : String # Asserts the `grades` array contains at least 3 elements or # that each element is greater than or equal to 5. @[ Assert :: AtLeastOneOf ( [ @[ Assert :: Size ( 3 .. ) ] , @[ Assert :: All ( [ @[ Assert :: GreaterThanOrEqual ( 5 ) ] , ] ) ] , ] ) ] getter grades : Array ( Int32 ) end NOTE: The annotation approach only supports two levels of nested annotations. Manually wire up the constraint via code if you require more than that. Constants AT_LEAST_ONE_OF_ERROR = \"811994eb-b634-42f5-ae98-13eec66481b6\" DEFAULT_ERROR_MESSAGE = \"This value should satisfy at least one of the following constraints:\" Class methods .new ( constraints : Array ( AVD::Constraint ) | AVD::Constraint , include_internal_messages : Bool = true , message_collection : String = \"Each element of this collection should satisfy its own set of constraints.\" , message : String = \"This value should satisfy at least one of the following constraints:\" , groups : Array ( String ) | String | Nil = nil , payload : Hash ( String , String )? = nil ) Methods #include_internal_messages : Bool #message_collection : String #validated_by : AVD :: ConstraintValidator . class Returns the AVD::ConstraintValidator.class that should handle validating self .","title":"AtLeastOneOf"},{"location":"Validator/Constraints/AtLeastOneOf/#Athena::Validator::Constraints::AtLeastOneOf","text":"Validates that a value satisfies at least one of the provided constraints. Validation stops as soon as one constraint is satisfied.","title":"AtLeastOneOf"},{"location":"Validator/Constraints/AtLeastOneOf/#Athena::Validator::Constraints::AtLeastOneOf--configuration","text":"","title":"Configuration"},{"location":"Validator/Constraints/AtLeastOneOf/#Athena::Validator::Constraints::AtLeastOneOf--required-arguments","text":"","title":"Required Arguments"},{"location":"Validator/Constraints/AtLeastOneOf/#Athena::Validator::Constraints::AtLeastOneOf--constraints","text":"Type: Array(AVD::Constraint) | AVD::Constraint The AVD::Constraint (s) from which at least one of has to be satisfied in order for the validation to succeed.","title":"constraints"},{"location":"Validator/Constraints/AtLeastOneOf/#Athena::Validator::Constraints::AtLeastOneOf--optional-arguments","text":"","title":"Optional Arguments"},{"location":"Validator/Constraints/AtLeastOneOf/#Athena::Validator::Constraints::AtLeastOneOf--include_internal_messages","text":"Type: Bool Default: true If the validation failed message should include the list of messages for the internal constraints. See the message argument for an example.","title":"include_internal_messages"},{"location":"Validator/Constraints/AtLeastOneOf/#Athena::Validator::Constraints::AtLeastOneOf--message_collection","text":"Type: String Default: Each element of this collection should satisfy its own set of constraints. The message that will be shown if validation fails and the internal constraint is an AVD::Constraints::All . See the message argument for an example.","title":"message_collection"},{"location":"Validator/Constraints/AtLeastOneOf/#Athena::Validator::Constraints::AtLeastOneOf--message","text":"Type: String Default: This value should satisfy at least one of the following constraints: The intro that will be shown if validation fails. By default, it'll be followed by the list of messages from the internal constraints ; configurable via the include_internal_messages argument. For example, if the grades property in the example below fails to validate, the message will be: This value should satisfy at least one of the following constraints: [1] This value is too short. It should have 3 items or more. [2] Each element of this collection should satisfy its own set of constraints.","title":"message"},{"location":"Validator/Constraints/AtLeastOneOf/#Athena::Validator::Constraints::AtLeastOneOf--groups","text":"Type: Array(String) | String | Nil Default: nil The validation groups this constraint belongs to. AVD::Constraint::DEFAULT_GROUP is assumed if nil .","title":"groups"},{"location":"Validator/Constraints/AtLeastOneOf/#Athena::Validator::Constraints::AtLeastOneOf--payload","text":"Type: Hash(String, String)? Default: nil Any arbitrary domain-specific data that should be stored with this constraint. The payload is not used by Athena::Validator , but its processing is completely up to you.","title":"payload"},{"location":"Validator/Constraints/AtLeastOneOf/#Athena::Validator::Constraints::AtLeastOneOf--usage","text":"class Example include AVD :: Validatable def initialize ( @password : String , @grades : Array ( Int32 )); end # Asserts the password contains an `#` or is at least 10 characters long. @[ Assert :: AtLeastOneOf ( [ @[ Assert :: Regex ( /#/ ) ] , @[ Assert :: Size ( 10 .. ) ] , ] ) ] getter password : String # Asserts the `grades` array contains at least 3 elements or # that each element is greater than or equal to 5. @[ Assert :: AtLeastOneOf ( [ @[ Assert :: Size ( 3 .. ) ] , @[ Assert :: All ( [ @[ Assert :: GreaterThanOrEqual ( 5 ) ] , ] ) ] , ] ) ] getter grades : Array ( Int32 ) end NOTE: The annotation approach only supports two levels of nested annotations. Manually wire up the constraint via code if you require more than that.","title":"Usage"},{"location":"Validator/Constraints/AtLeastOneOf/#constants","text":"","title":"Constants"},{"location":"Validator/Constraints/AtLeastOneOf/#Athena::Validator::Constraints::AtLeastOneOf::AT_LEAST_ONE_OF_ERROR","text":"","title":"AT_LEAST_ONE_OF_ERROR"},{"location":"Validator/Constraints/AtLeastOneOf/#Athena::Validator::Constraints::AtLeastOneOf::DEFAULT_ERROR_MESSAGE","text":"","title":"DEFAULT_ERROR_MESSAGE"},{"location":"Validator/Constraints/AtLeastOneOf/#class-methods","text":"","title":"Class methods"},{"location":"Validator/Constraints/AtLeastOneOf/#Athena::Validator::Constraints::AtLeastOneOf.new(constraints,include_internal_messages,message_collection,message,groups,payload)","text":"","title":".new"},{"location":"Validator/Constraints/AtLeastOneOf/#methods","text":"","title":"Methods"},{"location":"Validator/Constraints/AtLeastOneOf/#Athena::Validator::Constraints::AtLeastOneOf#include_internal_messages()","text":"","title":"#include_internal_messages"},{"location":"Validator/Constraints/AtLeastOneOf/#Athena::Validator::Constraints::AtLeastOneOf#message_collection()","text":"","title":"#message_collection"},{"location":"Validator/Constraints/AtLeastOneOf/#Athena::Validator::Constraints::AtLeastOneOf#validated_by()","text":"Returns the AVD::ConstraintValidator.class that should handle validating self .","title":"#validated_by"},{"location":"Validator/Constraints/AtLeastOneOf/Validator/","text":"struct Athena::Validator::Constraints::AtLeastOneOf::Validator inherits Athena::Validator::ConstraintValidator Methods #validate ( value : _ , constraint : AVD::Constraints::AtLeastOneOf ) : Nil :inherit:","title":"Validator"},{"location":"Validator/Constraints/AtLeastOneOf/Validator/#Athena::Validator::Constraints::AtLeastOneOf::Validator","text":"","title":"Validator"},{"location":"Validator/Constraints/AtLeastOneOf/Validator/#methods","text":"","title":"Methods"},{"location":"Validator/Constraints/AtLeastOneOf/Validator/#Athena::Validator::Constraints::AtLeastOneOf::Validator#validate(value,constraint)","text":":inherit:","title":"#validate"},{"location":"Validator/Constraints/Blank/","text":"class Athena::Validator::Constraints::Blank inherits Athena::Validator::Constraint Validates that a value is blank; meaning equal to an empty string or nil . Configuration Optional Arguments message Type: String Default: This value should be blank. The message that will be shown if the value is not blank. Placeholders The following placeholders can be used in this message: {{ value }} - The current (invalid) value. groups Type: Array(String) | String | Nil Default: nil The validation groups this constraint belongs to. AVD::Constraint::DEFAULT_GROUP is assumed if nil . payload Type: Hash(String, String)? Default: nil Any arbitrary domain-specific data that should be stored with this constraint. The payload is not used by Athena::Validator , but its processing is completely up to you. Constants NOT_BLANK_ERROR = \"c815f901-c581-4fb7-a85d-b8c5bc757959\" Class methods .new ( message : String = \"This value should be blank.\" , groups : Array ( String ) | String | Nil = nil , payload : Hash ( String , String )? = nil ) Methods #validated_by : AVD :: ConstraintValidator . class Returns the AVD::ConstraintValidator.class that should handle validating self .","title":"Blank"},{"location":"Validator/Constraints/Blank/#Athena::Validator::Constraints::Blank","text":"Validates that a value is blank; meaning equal to an empty string or nil .","title":"Blank"},{"location":"Validator/Constraints/Blank/#Athena::Validator::Constraints::Blank--configuration","text":"","title":"Configuration"},{"location":"Validator/Constraints/Blank/#Athena::Validator::Constraints::Blank--optional-arguments","text":"","title":"Optional Arguments"},{"location":"Validator/Constraints/Blank/#Athena::Validator::Constraints::Blank--message","text":"Type: String Default: This value should be blank. The message that will be shown if the value is not blank.","title":"message"},{"location":"Validator/Constraints/Blank/#Athena::Validator::Constraints::Blank--placeholders","text":"The following placeholders can be used in this message: {{ value }} - The current (invalid) value.","title":"Placeholders"},{"location":"Validator/Constraints/Blank/#Athena::Validator::Constraints::Blank--groups","text":"Type: Array(String) | String | Nil Default: nil The validation groups this constraint belongs to. AVD::Constraint::DEFAULT_GROUP is assumed if nil .","title":"groups"},{"location":"Validator/Constraints/Blank/#Athena::Validator::Constraints::Blank--payload","text":"Type: Hash(String, String)? Default: nil Any arbitrary domain-specific data that should be stored with this constraint. The payload is not used by Athena::Validator , but its processing is completely up to you.","title":"payload"},{"location":"Validator/Constraints/Blank/#constants","text":"","title":"Constants"},{"location":"Validator/Constraints/Blank/#Athena::Validator::Constraints::Blank::NOT_BLANK_ERROR","text":"","title":"NOT_BLANK_ERROR"},{"location":"Validator/Constraints/Blank/#class-methods","text":"","title":"Class methods"},{"location":"Validator/Constraints/Blank/#Athena::Validator::Constraints::Blank.new(message,groups,payload)","text":"","title":".new"},{"location":"Validator/Constraints/Blank/#methods","text":"","title":"Methods"},{"location":"Validator/Constraints/Blank/#Athena::Validator::Constraints::Blank#validated_by()","text":"Returns the AVD::ConstraintValidator.class that should handle validating self .","title":"#validated_by"},{"location":"Validator/Constraints/Blank/Validator/","text":"struct Athena::Validator::Constraints::Blank::Validator inherits Athena::Validator::ConstraintValidator Methods #validate ( value : _ , constraint : AVD::Constraints::Blank ) : Nil :inherit:","title":"Validator"},{"location":"Validator/Constraints/Blank/Validator/#Athena::Validator::Constraints::Blank::Validator","text":"","title":"Validator"},{"location":"Validator/Constraints/Blank/Validator/#methods","text":"","title":"Methods"},{"location":"Validator/Constraints/Blank/Validator/#Athena::Validator::Constraints::Blank::Validator#validate(value,constraint)","text":":inherit:","title":"#validate"},{"location":"Validator/Constraints/Callback/","text":"class Athena::Validator::Constraints::Callback inherits Athena::Validator::Constraint Allows creating totally custom validation rules, assigning any violations to specific fields on your object. This process is achieved via using one or more callback methods which will be invoked during the validation process. NOTE: The callback method itself does fail or return any value. Instead it should directly add violations to the AVD::ExecutionContextInterface argument. Configuration Required Arguments callback Type: AVD::Constraints::Callback::CallbackProc? Default: nil The proc that should be invoked as the callback for this constraint. NOTE: If this argument is not supplied, the callback_name argument must be. callback_name Type: String? Default: nil The name of the method that should be invoked as the callback for this constraint. NOTE: If this argument is not supplied, the callback argument must be. Optional Arguments NOTE: This constraint does not support a message argument. groups Type: Array(String) | String | Nil Default: nil The validation groups this constraint belongs to. AVD::Constraint::DEFAULT_GROUP is assumed if nil . payload Type: Hash(String, String)? Default: nil Any arbitrary domain-specific data that should be stored with this constraint. The payload is not used by Athena::Validator , but its processing is completely up to you. Usage The callback constraint supports two callback methods when validating objects, and one callback method when using the constraint directly. Instance Methods To define an instance callback method, apply the @[Assert::Callback] method to a public instance method defined within an object. This method should accept two arguments: the AVD::ExecutionContextInterface to which violations should be added, and the AVD::Constraint@payload from the related constraint. More than one callback method can exist on a type, and the method name does not have to be validate . class Example include AVD :: Validatable SPAM_DOMAINS = [ \"fake.com\" , \"spam.net\" ] def initialize ( @domain_name : String ); end @[ Assert :: Callback ] def validate ( context : AVD :: ExecutionContextInterface , payload : Hash ( String , String ) ?) : Nil # Validate that the `domain_name` is not spammy. return unless SPAM_DOMAINS . includes? @domain_name context . build_violation ( \"This domain name is not legit!\" ) . at_path ( \"domain_name\" ) . add end end Class Methods The callback method can also be defined as a class method. Since class methods do not have access to the related object instance, it is passed in as an argument. That argument is typed as AVD::Constraints::Callback::Value which exposes a AVD::Constraints::Callback::Value#get method that can be used as an easier syntax than .as . class Example include AVD :: Validatable SPAM_DOMAINS = [ \"fake.com\" , \"spam.net\" ] @[ Assert :: Callback ] def self . validate ( value : AVD :: Constraints :: Callback :: Value , context : AVD :: ExecutionContextInterface , payload : Hash ( String , String ) ?) : Nil # Get the object from the value, typed as our `Example` class. object = value . get self # Validate that the `domain_name` is not spammy. return unless SPAM_DOMAINS . includes? object . domain_name context . build_violation ( \"This domain name is not legit!\" ) . at_path ( \"domain_name\" ) . add end def initialize ( @domain_name : String ); end getter domain_name : String end Procs/Blocks When working with constraints in a non object context, a callback passed in as a proc/block. AVD::Constraints::Callback::CallbackProc alias can be used to more easily create a callback proc. AVD::Constraints::Callback.with_callback can be used to create a callback constraint, using the block as the callback proc. See the related types for more information. Proc/block based callbacks operate similarly to Class Methods in that they receive the value as an argument. Class methods .with_callback ( ** args , & block : AVD :: Constraints :: Callback :: ValueContainer , AVD::ExecutionContextInterface , Hash ( String , String )? -> ) : AVD::Constraints::Callback Convenience method for creating a AVD::Constraints::Callback with the given &block as the callback. # Instantiate a callback constraint, using the block as the callback constraint = AVD :: Constraints :: Callback . with_callback do | value , context , payload | next if ( value = value . get ( Int32 )) . even? context . add_violation \"This value should be even.\" end .new ( callback : AVD::Constraints::Callback::CallbackProc? = nil , callback_name : String ? = nil , groups : Array ( String ) | String | Nil = nil , payload : Hash ( String , String )? = nil ) Methods #callback : AVD::Constraints::Callback::CallbackProc? Returns the proc that this constraint should invoke. #callback_name : String ? Returns the name of the callback method this constraint should invoke. #validated_by : AVD :: ConstraintValidator . class Returns the AVD::ConstraintValidator.class that should handle validating self .","title":"Callback"},{"location":"Validator/Constraints/Callback/#Athena::Validator::Constraints::Callback","text":"Allows creating totally custom validation rules, assigning any violations to specific fields on your object. This process is achieved via using one or more callback methods which will be invoked during the validation process. NOTE: The callback method itself does fail or return any value. Instead it should directly add violations to the AVD::ExecutionContextInterface argument.","title":"Callback"},{"location":"Validator/Constraints/Callback/#Athena::Validator::Constraints::Callback--configuration","text":"","title":"Configuration"},{"location":"Validator/Constraints/Callback/#Athena::Validator::Constraints::Callback--required-arguments","text":"","title":"Required Arguments"},{"location":"Validator/Constraints/Callback/#Athena::Validator::Constraints::Callback--callback","text":"Type: AVD::Constraints::Callback::CallbackProc? Default: nil The proc that should be invoked as the callback for this constraint. NOTE: If this argument is not supplied, the callback_name argument must be.","title":"callback"},{"location":"Validator/Constraints/Callback/#Athena::Validator::Constraints::Callback--callback_name","text":"Type: String? Default: nil The name of the method that should be invoked as the callback for this constraint. NOTE: If this argument is not supplied, the callback argument must be.","title":"callback_name"},{"location":"Validator/Constraints/Callback/#Athena::Validator::Constraints::Callback--optional-arguments","text":"NOTE: This constraint does not support a message argument.","title":"Optional Arguments"},{"location":"Validator/Constraints/Callback/#Athena::Validator::Constraints::Callback--groups","text":"Type: Array(String) | String | Nil Default: nil The validation groups this constraint belongs to. AVD::Constraint::DEFAULT_GROUP is assumed if nil .","title":"groups"},{"location":"Validator/Constraints/Callback/#Athena::Validator::Constraints::Callback--payload","text":"Type: Hash(String, String)? Default: nil Any arbitrary domain-specific data that should be stored with this constraint. The payload is not used by Athena::Validator , but its processing is completely up to you.","title":"payload"},{"location":"Validator/Constraints/Callback/#Athena::Validator::Constraints::Callback--usage","text":"The callback constraint supports two callback methods when validating objects, and one callback method when using the constraint directly.","title":"Usage"},{"location":"Validator/Constraints/Callback/#Athena::Validator::Constraints::Callback--instance-methods","text":"To define an instance callback method, apply the @[Assert::Callback] method to a public instance method defined within an object. This method should accept two arguments: the AVD::ExecutionContextInterface to which violations should be added, and the AVD::Constraint@payload from the related constraint. More than one callback method can exist on a type, and the method name does not have to be validate . class Example include AVD :: Validatable SPAM_DOMAINS = [ \"fake.com\" , \"spam.net\" ] def initialize ( @domain_name : String ); end @[ Assert :: Callback ] def validate ( context : AVD :: ExecutionContextInterface , payload : Hash ( String , String ) ?) : Nil # Validate that the `domain_name` is not spammy. return unless SPAM_DOMAINS . includes? @domain_name context . build_violation ( \"This domain name is not legit!\" ) . at_path ( \"domain_name\" ) . add end end","title":"Instance Methods"},{"location":"Validator/Constraints/Callback/#Athena::Validator::Constraints::Callback--class-methods","text":"The callback method can also be defined as a class method. Since class methods do not have access to the related object instance, it is passed in as an argument. That argument is typed as AVD::Constraints::Callback::Value which exposes a AVD::Constraints::Callback::Value#get method that can be used as an easier syntax than .as . class Example include AVD :: Validatable SPAM_DOMAINS = [ \"fake.com\" , \"spam.net\" ] @[ Assert :: Callback ] def self . validate ( value : AVD :: Constraints :: Callback :: Value , context : AVD :: ExecutionContextInterface , payload : Hash ( String , String ) ?) : Nil # Get the object from the value, typed as our `Example` class. object = value . get self # Validate that the `domain_name` is not spammy. return unless SPAM_DOMAINS . includes? object . domain_name context . build_violation ( \"This domain name is not legit!\" ) . at_path ( \"domain_name\" ) . add end def initialize ( @domain_name : String ); end getter domain_name : String end","title":"Class Methods"},{"location":"Validator/Constraints/Callback/#Athena::Validator::Constraints::Callback--procsblocks","text":"When working with constraints in a non object context, a callback passed in as a proc/block. AVD::Constraints::Callback::CallbackProc alias can be used to more easily create a callback proc. AVD::Constraints::Callback.with_callback can be used to create a callback constraint, using the block as the callback proc. See the related types for more information. Proc/block based callbacks operate similarly to Class Methods in that they receive the value as an argument.","title":"Procs/Blocks"},{"location":"Validator/Constraints/Callback/#class-methods","text":"","title":"Class methods"},{"location":"Validator/Constraints/Callback/#Athena::Validator::Constraints::Callback.with_callback(**args,&)","text":"Convenience method for creating a AVD::Constraints::Callback with the given &block as the callback. # Instantiate a callback constraint, using the block as the callback constraint = AVD :: Constraints :: Callback . with_callback do | value , context , payload | next if ( value = value . get ( Int32 )) . even? context . add_violation \"This value should be even.\" end","title":".with_callback"},{"location":"Validator/Constraints/Callback/#Athena::Validator::Constraints::Callback.new(callback,callback_name,groups,payload)","text":"","title":".new"},{"location":"Validator/Constraints/Callback/#methods","text":"","title":"Methods"},{"location":"Validator/Constraints/Callback/#Athena::Validator::Constraints::Callback#callback()","text":"Returns the proc that this constraint should invoke.","title":"#callback"},{"location":"Validator/Constraints/Callback/#Athena::Validator::Constraints::Callback#callback_name()","text":"Returns the name of the callback method this constraint should invoke.","title":"#callback_name"},{"location":"Validator/Constraints/Callback/#Athena::Validator::Constraints::Callback#validated_by()","text":"Returns the AVD::ConstraintValidator.class that should handle validating self .","title":"#validated_by"},{"location":"Validator/Constraints/Callback/CallbackProc/","text":"alias Athena::Validator::Constraints::Callback::CallbackProc Convenience alias to make creating AVD::Constraints::Callback procs easier. # Create a proc to handle the validation callback = AVD :: Constraints :: Callback :: CallbackProc . new do | value , context , payload | return if ( value = value . get ( Int32 )) . even? context . add_violation \"This value should be even.\" end # Instantiate a callback constraint with this proc constraint = AVD :: Constraints :: Callback . new callback : callback Alias definition Athena :: Validator :: Constraints :: Callback :: ValueContainer , Athena::Validator::ExecutionContextInterface , Hash ( String , String )? -> Nil","title":"CallbackProc"},{"location":"Validator/Constraints/Callback/CallbackProc/#Athena::Validator::Constraints::Callback::CallbackProc","text":"Convenience alias to make creating AVD::Constraints::Callback procs easier. # Create a proc to handle the validation callback = AVD :: Constraints :: Callback :: CallbackProc . new do | value , context , payload | return if ( value = value . get ( Int32 )) . even? context . add_violation \"This value should be even.\" end # Instantiate a callback constraint with this proc constraint = AVD :: Constraints :: Callback . new callback : callback","title":"CallbackProc"},{"location":"Validator/Constraints/Callback/CallbackProc/#alias-definition","text":"Athena :: Validator :: Constraints :: Callback :: ValueContainer , Athena::Validator::ExecutionContextInterface , Hash ( String , String )? -> Nil","title":"Alias definition"},{"location":"Validator/Constraints/Callback/Validator/","text":"struct Athena::Validator::Constraints::Callback::Validator inherits Athena::Validator::ConstraintValidator Methods #validate ( value : _ , constraint : AVD::Constraints::Callback ) : Nil :inherit:","title":"Validator"},{"location":"Validator/Constraints/Callback/Validator/#Athena::Validator::Constraints::Callback::Validator","text":"","title":"Validator"},{"location":"Validator/Constraints/Callback/Validator/#methods","text":"","title":"Methods"},{"location":"Validator/Constraints/Callback/Validator/#Athena::Validator::Constraints::Callback::Validator#validate(value,constraint)","text":":inherit:","title":"#validate"},{"location":"Validator/Constraints/Callback/Value/","text":"struct Athena::Validator::Constraints::Callback::Value(T) inherits Athena::Validator::Constraints::Callback::ValueContainer Wrapper type to allow passing arbitrarily typed values as arguments in the AVD::Constraints::Callback::CallbackProc . Class methods .new ( value : T ) Methods #== ( other ) : Bool Returns true if this struct is equal to other . Both structs' instance vars are compared to each other. Thus, two structs are considered equal if each of their instance variables are equal. Subclasses should override this method to provide specific equality semantics. struct Point def initialize ( @x : Int32 , @y : Int32 ) end end p1 = Point . new 1 , 2 p2 = Point . new 1 , 2 p3 = Point . new 3 , 4 p1 == p2 # => true p1 == p3 # => false #clone #copy_with ( value _value = @value ) #get ( as _t : T . class ) : T forall T Returns the value as T . If used inside a AVD::Constraints::Callback@class-method . # Get the wrapped value as the type of the current class. object = value . get self If used inside a AVD::Constraints::Callback@procsblocks . ``` Get the wrapped value as the expected type. value = value.get Int32 Alternatively, can use normal Crystal semantics for narrowing the type. value = value.value case value when Int32 then \"value is Int32\" when String then \"value is String\" end #value : T Macros method_missing ( call )","title":"Value"},{"location":"Validator/Constraints/Callback/Value/#Athena::Validator::Constraints::Callback::Value","text":"Wrapper type to allow passing arbitrarily typed values as arguments in the AVD::Constraints::Callback::CallbackProc .","title":"Value"},{"location":"Validator/Constraints/Callback/Value/#class-methods","text":"","title":"Class methods"},{"location":"Validator/Constraints/Callback/Value/#Athena::Validator::Constraints::Callback::Value.new(value)","text":"","title":".new"},{"location":"Validator/Constraints/Callback/Value/#methods","text":"","title":"Methods"},{"location":"Validator/Constraints/Callback/Value/#Athena::Validator::Constraints::Callback::Value#==(other)","text":"Returns true if this struct is equal to other . Both structs' instance vars are compared to each other. Thus, two structs are considered equal if each of their instance variables are equal. Subclasses should override this method to provide specific equality semantics. struct Point def initialize ( @x : Int32 , @y : Int32 ) end end p1 = Point . new 1 , 2 p2 = Point . new 1 , 2 p3 = Point . new 3 , 4 p1 == p2 # => true p1 == p3 # => false","title":"#=="},{"location":"Validator/Constraints/Callback/Value/#Athena::Validator::Constraints::Callback::Value#clone()","text":"","title":"#clone"},{"location":"Validator/Constraints/Callback/Value/#Athena::Validator::Constraints::Callback::Value#copy_with(value)","text":"","title":"#copy_with"},{"location":"Validator/Constraints/Callback/Value/#Athena::Validator::Constraints::Callback::Value#get(as)","text":"Returns the value as T . If used inside a AVD::Constraints::Callback@class-method . # Get the wrapped value as the type of the current class. object = value . get self If used inside a AVD::Constraints::Callback@procsblocks . ```","title":"#get"},{"location":"Validator/Constraints/Callback/Value/#Athena::Validator::Constraints::Callback::Value#get(as)--get-the-wrapped-value-as-the-expected-type","text":"value = value.get Int32","title":"Get the wrapped value as the expected type."},{"location":"Validator/Constraints/Callback/Value/#Athena::Validator::Constraints::Callback::Value#get(as)--alternatively-can-use-normal-crystal-semantics-for-narrowing-the-type","text":"value = value.value case value when Int32 then \"value is Int32\" when String then \"value is String\" end","title":"Alternatively, can use normal Crystal semantics for narrowing the type."},{"location":"Validator/Constraints/Callback/Value/#Athena::Validator::Constraints::Callback::Value#value()","text":"","title":"#value"},{"location":"Validator/Constraints/Callback/Value/#macros","text":"","title":"Macros"},{"location":"Validator/Constraints/Callback/Value/#Athena::Validator::Constraints::Callback::Value:method_missing(call)","text":"","title":"method_missing"},{"location":"Validator/Constraints/Choice/","text":"class Athena::Validator::Constraints::Choice inherits Athena::Validator::Constraint Validates that a value is one of a given set of valid choices; can also be used to validate that each item in a collection is one of those valid values. Configuration Required Arguments choices Type: Array(String | Number::Primitive | Symbol) The choices that are considered valid. Optional Arguments message Type: String Default: This value is not a valid choice. The message that will be shown if the value is not a valid choice and multiple is false . Placeholders The following placeholders can be used in this message: {{ value }} - The current (invalid) value. {{ choices }} - The available choices. multiple_message Type: String Default: One or more of the given values is invalid. The message that will be shown if one of the values is not a valid choice and multiple is true . Placeholders The following placeholders can be used in this message: {{ value }} - The current (invalid) value. {{ choices }} - The available choices. min_message Type: String Default: You must select at least {{ limit }} choice.|You must select at least {{ limit }} choices. The message that will be shown if too few choices are chosen as per the range option. Placeholders The following placeholders can be used in this message: {{ value }} - The current (invalid) value. {{ choices }} - The available choices. {{ limit }} - If multiple is true, enforces that at most this many values may be selected in order to be valid. max_message Type: String Default: You must select at most {{ limit }} choice.|You must select at most {{ limit }} choices. The message that will be shown if too many choices are chosen as per the range option. Placeholders The following placeholders can be used in this message: {{ value }} - The current (invalid) value. {{ choices }} - The available choices. {{ limit }} - If multiple is true, enforces that no more than this many values may be selected in order to be valid. range Type: ::Range? Default: nil If multiple is true, is used to define the \"range\" of how many choices must be valid for the value to be considered valid. For example, if set to (3..) , but there are only 2 valid items in the input enumerable then validation will fail. Beginless/endless ranges can be used to define only a lower/upper bound. multiple Type: Bool Default: false If true , the input value is expected to be an Enumerable instead of a single scalar value. The constraint will check each item in the enumerable is valid choice. groups Type: Array(String) | String | Nil Default: nil The validation groups this constraint belongs to. AVD::Constraint::DEFAULT_GROUP is assumed if nil . payload Type: Hash(String, String)? Default: nil Any arbitrary domain-specific data that should be stored with this constraint. The payload is not used by Athena::Validator , but its processing is completely up to you. Constants NO_SUCH_CHOICE_ERROR = \"c7398ea5-e787-4ee9-9fca-5f2c130614d6\" TOO_FEW_ERROR = \"3573357d-c9a8-4633-a742-c001086fd5aa\" TOO_MANY_ERROR = \"91d0d22b-a693-4b9c-8b41-bc6392cf89f4\" Class methods .new ( choices : Array ( String | Number :: Primitive | Symbol ), message : String = \"This value is not a valid choice.\" , multiple_message : String = \"One or more of the given values is invalid.\" , min_message : String = \"You must select at least {{ limit }} choice.|You must select at least {{ limit }} choices.\" , max_message : String = \"You must select at most {{ limit }} choice.|You must select at most {{ limit }} choices.\" , multiple : Bool = false , range : :: Range ? = nil , groups : Array ( String ) | String | Nil = nil , payload : Hash ( String , String )? = nil ) Methods #choices : Array ( String | Number :: Primitive | Symbol ) #max : Number :: Primitive? #max_message : String #min : Number :: Primitive? #min_message : String #multiple? : Bool #multiple_message : String #validated_by : AVD :: ConstraintValidator . class Returns the AVD::ConstraintValidator.class that should handle validating self .","title":"Choice"},{"location":"Validator/Constraints/Choice/#Athena::Validator::Constraints::Choice","text":"Validates that a value is one of a given set of valid choices; can also be used to validate that each item in a collection is one of those valid values.","title":"Choice"},{"location":"Validator/Constraints/Choice/#Athena::Validator::Constraints::Choice--configuration","text":"","title":"Configuration"},{"location":"Validator/Constraints/Choice/#Athena::Validator::Constraints::Choice--required-arguments","text":"","title":"Required Arguments"},{"location":"Validator/Constraints/Choice/#Athena::Validator::Constraints::Choice--choices","text":"Type: Array(String | Number::Primitive | Symbol) The choices that are considered valid.","title":"choices"},{"location":"Validator/Constraints/Choice/#Athena::Validator::Constraints::Choice--optional-arguments","text":"","title":"Optional Arguments"},{"location":"Validator/Constraints/Choice/#Athena::Validator::Constraints::Choice--message","text":"Type: String Default: This value is not a valid choice. The message that will be shown if the value is not a valid choice and multiple is false .","title":"message"},{"location":"Validator/Constraints/Choice/#Athena::Validator::Constraints::Choice--placeholders","text":"The following placeholders can be used in this message: {{ value }} - The current (invalid) value. {{ choices }} - The available choices.","title":"Placeholders"},{"location":"Validator/Constraints/Choice/#Athena::Validator::Constraints::Choice--multiple_message","text":"Type: String Default: One or more of the given values is invalid. The message that will be shown if one of the values is not a valid choice and multiple is true .","title":"multiple_message"},{"location":"Validator/Constraints/Choice/#Athena::Validator::Constraints::Choice--placeholders_1","text":"The following placeholders can be used in this message: {{ value }} - The current (invalid) value. {{ choices }} - The available choices.","title":"Placeholders"},{"location":"Validator/Constraints/Choice/#Athena::Validator::Constraints::Choice--min_message","text":"Type: String Default: You must select at least {{ limit }} choice.|You must select at least {{ limit }} choices. The message that will be shown if too few choices are chosen as per the range option.","title":"min_message"},{"location":"Validator/Constraints/Choice/#Athena::Validator::Constraints::Choice--placeholders_2","text":"The following placeholders can be used in this message: {{ value }} - The current (invalid) value. {{ choices }} - The available choices. {{ limit }} - If multiple is true, enforces that at most this many values may be selected in order to be valid.","title":"Placeholders"},{"location":"Validator/Constraints/Choice/#Athena::Validator::Constraints::Choice--max_message","text":"Type: String Default: You must select at most {{ limit }} choice.|You must select at most {{ limit }} choices. The message that will be shown if too many choices are chosen as per the range option.","title":"max_message"},{"location":"Validator/Constraints/Choice/#Athena::Validator::Constraints::Choice--placeholders_3","text":"The following placeholders can be used in this message: {{ value }} - The current (invalid) value. {{ choices }} - The available choices. {{ limit }} - If multiple is true, enforces that no more than this many values may be selected in order to be valid.","title":"Placeholders"},{"location":"Validator/Constraints/Choice/#Athena::Validator::Constraints::Choice--range","text":"Type: ::Range? Default: nil If multiple is true, is used to define the \"range\" of how many choices must be valid for the value to be considered valid. For example, if set to (3..) , but there are only 2 valid items in the input enumerable then validation will fail. Beginless/endless ranges can be used to define only a lower/upper bound.","title":"range"},{"location":"Validator/Constraints/Choice/#Athena::Validator::Constraints::Choice--multiple","text":"Type: Bool Default: false If true , the input value is expected to be an Enumerable instead of a single scalar value. The constraint will check each item in the enumerable is valid choice.","title":"multiple"},{"location":"Validator/Constraints/Choice/#Athena::Validator::Constraints::Choice--groups","text":"Type: Array(String) | String | Nil Default: nil The validation groups this constraint belongs to. AVD::Constraint::DEFAULT_GROUP is assumed if nil .","title":"groups"},{"location":"Validator/Constraints/Choice/#Athena::Validator::Constraints::Choice--payload","text":"Type: Hash(String, String)? Default: nil Any arbitrary domain-specific data that should be stored with this constraint. The payload is not used by Athena::Validator , but its processing is completely up to you.","title":"payload"},{"location":"Validator/Constraints/Choice/#constants","text":"","title":"Constants"},{"location":"Validator/Constraints/Choice/#Athena::Validator::Constraints::Choice::NO_SUCH_CHOICE_ERROR","text":"","title":"NO_SUCH_CHOICE_ERROR"},{"location":"Validator/Constraints/Choice/#Athena::Validator::Constraints::Choice::TOO_FEW_ERROR","text":"","title":"TOO_FEW_ERROR"},{"location":"Validator/Constraints/Choice/#Athena::Validator::Constraints::Choice::TOO_MANY_ERROR","text":"","title":"TOO_MANY_ERROR"},{"location":"Validator/Constraints/Choice/#class-methods","text":"","title":"Class methods"},{"location":"Validator/Constraints/Choice/#Athena::Validator::Constraints::Choice.new(choices,message,multiple_message,min_message,max_message,multiple,range,groups,payload)","text":"","title":".new"},{"location":"Validator/Constraints/Choice/#methods","text":"","title":"Methods"},{"location":"Validator/Constraints/Choice/#Athena::Validator::Constraints::Choice#choices()","text":"","title":"#choices"},{"location":"Validator/Constraints/Choice/#Athena::Validator::Constraints::Choice#max()","text":"","title":"#max"},{"location":"Validator/Constraints/Choice/#Athena::Validator::Constraints::Choice#max_message()","text":"","title":"#max_message"},{"location":"Validator/Constraints/Choice/#Athena::Validator::Constraints::Choice#min()","text":"","title":"#min"},{"location":"Validator/Constraints/Choice/#Athena::Validator::Constraints::Choice#min_message()","text":"","title":"#min_message"},{"location":"Validator/Constraints/Choice/#Athena::Validator::Constraints::Choice#multiple?()","text":"","title":"#multiple?"},{"location":"Validator/Constraints/Choice/#Athena::Validator::Constraints::Choice#multiple_message()","text":"","title":"#multiple_message"},{"location":"Validator/Constraints/Choice/#Athena::Validator::Constraints::Choice#validated_by()","text":"Returns the AVD::ConstraintValidator.class that should handle validating self .","title":"#validated_by"},{"location":"Validator/Constraints/Choice/Validator/","text":"struct Athena::Validator::Constraints::Choice::Validator inherits Athena::Validator::ConstraintValidator Methods #validate ( value : Enumerable? , constraint : AVD::Constraints::Choice ) : Nil :inherit: #validate ( value : _ , constraint : AVD::Constraints::Choice ) : Nil :inherit:","title":"Validator"},{"location":"Validator/Constraints/Choice/Validator/#Athena::Validator::Constraints::Choice::Validator","text":"","title":"Validator"},{"location":"Validator/Constraints/Choice/Validator/#methods","text":"","title":"Methods"},{"location":"Validator/Constraints/Choice/Validator/#Athena::Validator::Constraints::Choice::Validator#validate(value,constraint)","text":":inherit:","title":"#validate"},{"location":"Validator/Constraints/Choice/Validator/#Athena::Validator::Constraints::Choice::Validator#validate(value,constraint)","text":":inherit:","title":"#validate"},{"location":"Validator/Constraints/ComparisonValidator/","text":"abstract struct Athena::Validator::Constraints::ComparisonValidator inherits Athena::Validator::ConstraintValidator Defines common logic for comparison based constraint validators. Direct known subclasses Athena::Validator::Constraints::EqualTo::Validator Athena::Validator::Constraints::GreaterThan::Validator Athena::Validator::Constraints::GreaterThanOrEqual::Validator Athena::Validator::Constraints::LessThan::Validator Athena::Validator::Constraints::LessThanOrEqual::Validator Athena::Validator::Constraints::NotEqualTo::Validator Methods abstract #compare_values ( actual : _ , expected : _ ) : Bool Returns true if the provided actual and expected values are compatible, otherwise false . abstract #error_code : String Returns the expected error code for self . #validate ( value : _ , constraint : AVD::Constraints::AbstractComparison ) : Nil :inherit:","title":"ComparisonValidator"},{"location":"Validator/Constraints/ComparisonValidator/#Athena::Validator::Constraints::ComparisonValidator","text":"Defines common logic for comparison based constraint validators.","title":"ComparisonValidator"},{"location":"Validator/Constraints/ComparisonValidator/#direct-known-subclasses","text":"Athena::Validator::Constraints::EqualTo::Validator Athena::Validator::Constraints::GreaterThan::Validator Athena::Validator::Constraints::GreaterThanOrEqual::Validator Athena::Validator::Constraints::LessThan::Validator Athena::Validator::Constraints::LessThanOrEqual::Validator Athena::Validator::Constraints::NotEqualTo::Validator","title":"Direct known subclasses"},{"location":"Validator/Constraints/ComparisonValidator/#methods","text":"","title":"Methods"},{"location":"Validator/Constraints/ComparisonValidator/#Athena::Validator::Constraints::ComparisonValidator#compare_values(actual,expected)","text":"Returns true if the provided actual and expected values are compatible, otherwise false .","title":"#compare_values"},{"location":"Validator/Constraints/ComparisonValidator/#Athena::Validator::Constraints::ComparisonValidator#error_code()","text":"Returns the expected error code for self .","title":"#error_code"},{"location":"Validator/Constraints/ComparisonValidator/#Athena::Validator::Constraints::ComparisonValidator#validate(value,constraint)","text":":inherit:","title":"#validate"},{"location":"Validator/Constraints/Composite/","text":"abstract class Athena::Validator::Constraints::Composite inherits Athena::Validator::Constraint A constraint composed of other constraints. handles normalizing the groups of the nested constraints, via the following algorithm: If groups are passed explicitly to the composite constraint, but not to the nested constraints, the options of the composite constraint are copied to the nested constraints If groups are passed explicitly to the nested constraints, but not to the composite constraint, the groups of all nested constraints are merged and used as groups for the composite constraint If groups are passed explicitly to both the composite and its nested constraints, the groups of the nested constraints must be a subset of the groups of the composite constraint. NOTE: You most likely want to use AVD::Constraints::Compound instead of this type. Direct known subclasses Athena::Validator::Constraints::All Athena::Validator::Constraints::AtLeastOneOf Athena::Validator::Constraints::Compound Athena::Validator::Constraints::Sequentially Class methods .new ( constraints : Array ( AVD::Constraint ) | AVD::Constraint , message : String , groups : Array ( String ) | String | Nil = nil , payload : Hash ( String , String )? = nil ) Methods #add_implicit_group ( group : String ) : Nil Adds the provided group to #groups if self is in the AVD::Constraint::DEFAULT_GROUP . #constraints : Array ( AVD::Constraint )","title":"Composite"},{"location":"Validator/Constraints/Composite/#Athena::Validator::Constraints::Composite","text":"A constraint composed of other constraints. handles normalizing the groups of the nested constraints, via the following algorithm: If groups are passed explicitly to the composite constraint, but not to the nested constraints, the options of the composite constraint are copied to the nested constraints If groups are passed explicitly to the nested constraints, but not to the composite constraint, the groups of all nested constraints are merged and used as groups for the composite constraint If groups are passed explicitly to both the composite and its nested constraints, the groups of the nested constraints must be a subset of the groups of the composite constraint. NOTE: You most likely want to use AVD::Constraints::Compound instead of this type.","title":"Composite"},{"location":"Validator/Constraints/Composite/#direct-known-subclasses","text":"Athena::Validator::Constraints::All Athena::Validator::Constraints::AtLeastOneOf Athena::Validator::Constraints::Compound Athena::Validator::Constraints::Sequentially","title":"Direct known subclasses"},{"location":"Validator/Constraints/Composite/#class-methods","text":"","title":"Class methods"},{"location":"Validator/Constraints/Composite/#Athena::Validator::Constraints::Composite.new(constraints,message,groups,payload)","text":"","title":".new"},{"location":"Validator/Constraints/Composite/#methods","text":"","title":"Methods"},{"location":"Validator/Constraints/Composite/#Athena::Validator::Constraints::Composite#add_implicit_group(group)","text":"Adds the provided group to #groups if self is in the AVD::Constraint::DEFAULT_GROUP .","title":"#add_implicit_group"},{"location":"Validator/Constraints/Composite/#Athena::Validator::Constraints::Composite#constraints()","text":"","title":"#constraints"},{"location":"Validator/Constraints/Compound/","text":"abstract class Athena::Validator::Constraints::Compound inherits Athena::Validator::Constraints::Composite Allows creating a custom set of reusable constraints, representing rules to use consistently across your application. NOTE: See AVD::Constraint@custom-constraints for common documentation on defining custom constraints. Configuration Optional Arguments NOTE: This constraint does not support a message argument. groups Type: Array(String) | String | Nil Default: nil The validation groups this constraint belongs to. AVD::Constraint::DEFAULT_GROUP is assumed if nil . payload Type: Hash(String, String)? Default: nil Any arbitrary domain-specific data that should be stored with this constraint. The payload is not used by Athena::Validator , but its processing is completely up to you. Usage This constraint is not used directly on its own; instead it's used to create another constraint. # Define a compound constraint to centralize the logic to validate a password. # # NOTE: The constraint _MUST_ be defined within the `AVD::Constraints` namespace for implementation reasons. This may change in the future. class AVD::Constraints:: ValidPassword < AVD :: Constraints :: Compound # Define a method that returns an array of the constraints we want to be a part of `self`. def constraints : Array ( AVD :: Constraint ) [ AVD :: Constraints :: NotBlank . new , # Not empty/null AVD :: Constraints :: Size . new ( 12 .. ), # At least 12 characters longs AVD :: Constraints :: Regex . new ( /^\\d.*/ ), # Must start with a number ] end end We can then use this constraint as we would any other. Either as an annotation @[ Assert :: ValidPassword ] getter password : String or directly. constraint = AVD :: Constraints :: ValidPassword . new Class methods .new ( groups : Array ( String ) | String | Nil = nil , payload : Hash ( String , String )? = nil ) Methods abstract #constraints : Array ( AVD::Constraint ) #validated_by : AVD :: ConstraintValidator . class Returns the AVD::ConstraintValidator.class that should handle validating self .","title":"Compound"},{"location":"Validator/Constraints/Compound/#Athena::Validator::Constraints::Compound","text":"Allows creating a custom set of reusable constraints, representing rules to use consistently across your application. NOTE: See AVD::Constraint@custom-constraints for common documentation on defining custom constraints.","title":"Compound"},{"location":"Validator/Constraints/Compound/#Athena::Validator::Constraints::Compound--configuration","text":"","title":"Configuration"},{"location":"Validator/Constraints/Compound/#Athena::Validator::Constraints::Compound--optional-arguments","text":"NOTE: This constraint does not support a message argument.","title":"Optional Arguments"},{"location":"Validator/Constraints/Compound/#Athena::Validator::Constraints::Compound--groups","text":"Type: Array(String) | String | Nil Default: nil The validation groups this constraint belongs to. AVD::Constraint::DEFAULT_GROUP is assumed if nil .","title":"groups"},{"location":"Validator/Constraints/Compound/#Athena::Validator::Constraints::Compound--payload","text":"Type: Hash(String, String)? Default: nil Any arbitrary domain-specific data that should be stored with this constraint. The payload is not used by Athena::Validator , but its processing is completely up to you.","title":"payload"},{"location":"Validator/Constraints/Compound/#Athena::Validator::Constraints::Compound--usage","text":"This constraint is not used directly on its own; instead it's used to create another constraint. # Define a compound constraint to centralize the logic to validate a password. # # NOTE: The constraint _MUST_ be defined within the `AVD::Constraints` namespace for implementation reasons. This may change in the future. class AVD::Constraints:: ValidPassword < AVD :: Constraints :: Compound # Define a method that returns an array of the constraints we want to be a part of `self`. def constraints : Array ( AVD :: Constraint ) [ AVD :: Constraints :: NotBlank . new , # Not empty/null AVD :: Constraints :: Size . new ( 12 .. ), # At least 12 characters longs AVD :: Constraints :: Regex . new ( /^\\d.*/ ), # Must start with a number ] end end We can then use this constraint as we would any other. Either as an annotation @[ Assert :: ValidPassword ] getter password : String or directly. constraint = AVD :: Constraints :: ValidPassword . new","title":"Usage"},{"location":"Validator/Constraints/Compound/#class-methods","text":"","title":"Class methods"},{"location":"Validator/Constraints/Compound/#Athena::Validator::Constraints::Compound.new(groups,payload)","text":"","title":".new"},{"location":"Validator/Constraints/Compound/#methods","text":"","title":"Methods"},{"location":"Validator/Constraints/Compound/#Athena::Validator::Constraints::Compound#constraints()","text":"","title":"#constraints"},{"location":"Validator/Constraints/Compound/#Athena::Validator::Constraints::Compound#validated_by()","text":"Returns the AVD::ConstraintValidator.class that should handle validating self .","title":"#validated_by"},{"location":"Validator/Constraints/Compound/Validator/","text":"struct Athena::Validator::Constraints::Compound::Validator inherits Athena::Validator::ConstraintValidator Methods #validate ( value : _ , constraint : AVD::Constraints::Compound ) : Nil :inherit:","title":"Validator"},{"location":"Validator/Constraints/Compound/Validator/#Athena::Validator::Constraints::Compound::Validator","text":"","title":"Validator"},{"location":"Validator/Constraints/Compound/Validator/#methods","text":"","title":"Methods"},{"location":"Validator/Constraints/Compound/Validator/#Athena::Validator::Constraints::Compound::Validator#validate(value,constraint)","text":":inherit:","title":"#validate"},{"location":"Validator/Constraints/Email/","text":"class Athena::Validator::Constraints::Email inherits Athena::Validator::Constraint Validates that a value is a valid email address. The underlying value is converted to a string via #to_s before being validated. NOTE: As with most other constraints, nil and empty strings are considered valid values, in order to allow the value to be optional. If the value is required, consider combining this constraint with AVD::Constraints::NotBlank . Configuration Optional Arguments mode Type: AVD::Constraints::Email::Mode Default: AVD::Constraints::Email::Mode::Loose Defines the pattern that should be used to validate the email address. message Type: String Default: This value is not a valid email address. The message that will be shown if the value is not a valid email address. Placeholders The following placeholders can be used in this message: {{ value }} - The current (invalid) value. groups Type: Array(String) | String | Nil Default: nil The validation groups this constraint belongs to. AVD::Constraint::DEFAULT_GROUP is assumed if nil . payload Type: Hash(String, String)? Default: nil Any arbitrary domain-specific data that should be stored with this constraint. The payload is not used by Athena::Validator , but its processing is completely up to you. Constants INVALID_FORMAT_ERROR = \"ad9d877d-9ad1-4dd7-b77b-e419934e5910\" Class methods .new ( mode : AVD::Constraints::Email::Mode = :loose , message : String = \"This value is not a valid email address.\" , groups : Array ( String ) | String | Nil = nil , payload : Hash ( String , String )? = nil ) Methods #mode : AVD::Constraints::Email::Mode #validated_by : AVD :: ConstraintValidator . class Returns the AVD::ConstraintValidator.class that should handle validating self .","title":"Email"},{"location":"Validator/Constraints/Email/#Athena::Validator::Constraints::Email","text":"Validates that a value is a valid email address. The underlying value is converted to a string via #to_s before being validated. NOTE: As with most other constraints, nil and empty strings are considered valid values, in order to allow the value to be optional. If the value is required, consider combining this constraint with AVD::Constraints::NotBlank .","title":"Email"},{"location":"Validator/Constraints/Email/#Athena::Validator::Constraints::Email--configuration","text":"","title":"Configuration"},{"location":"Validator/Constraints/Email/#Athena::Validator::Constraints::Email--optional-arguments","text":"","title":"Optional Arguments"},{"location":"Validator/Constraints/Email/#Athena::Validator::Constraints::Email--mode","text":"Type: AVD::Constraints::Email::Mode Default: AVD::Constraints::Email::Mode::Loose Defines the pattern that should be used to validate the email address.","title":"mode"},{"location":"Validator/Constraints/Email/#Athena::Validator::Constraints::Email--message","text":"Type: String Default: This value is not a valid email address. The message that will be shown if the value is not a valid email address.","title":"message"},{"location":"Validator/Constraints/Email/#Athena::Validator::Constraints::Email--placeholders","text":"The following placeholders can be used in this message: {{ value }} - The current (invalid) value.","title":"Placeholders"},{"location":"Validator/Constraints/Email/#Athena::Validator::Constraints::Email--groups","text":"Type: Array(String) | String | Nil Default: nil The validation groups this constraint belongs to. AVD::Constraint::DEFAULT_GROUP is assumed if nil .","title":"groups"},{"location":"Validator/Constraints/Email/#Athena::Validator::Constraints::Email--payload","text":"Type: Hash(String, String)? Default: nil Any arbitrary domain-specific data that should be stored with this constraint. The payload is not used by Athena::Validator , but its processing is completely up to you.","title":"payload"},{"location":"Validator/Constraints/Email/#constants","text":"","title":"Constants"},{"location":"Validator/Constraints/Email/#Athena::Validator::Constraints::Email::INVALID_FORMAT_ERROR","text":"","title":"INVALID_FORMAT_ERROR"},{"location":"Validator/Constraints/Email/#class-methods","text":"","title":"Class methods"},{"location":"Validator/Constraints/Email/#Athena::Validator::Constraints::Email.new(mode,message,groups,payload)","text":"","title":".new"},{"location":"Validator/Constraints/Email/#methods","text":"","title":"Methods"},{"location":"Validator/Constraints/Email/#Athena::Validator::Constraints::Email#mode()","text":"","title":"#mode"},{"location":"Validator/Constraints/Email/#Athena::Validator::Constraints::Email#validated_by()","text":"Returns the AVD::ConstraintValidator.class that should handle validating self .","title":"#validated_by"},{"location":"Validator/Constraints/Email/Mode/","text":"enum Athena::Validator::Constraints::Email::Mode Determines how the email address should be validated. Members Loose = 0 Validates the email against a simple ::Regex that allows all values with an @ symbol and a . in the host part of the email address. HTML5 = 1 Validates the email against the HTML5 input pattern . Methods #html5? #loose? #pattern : :: Regex Returns the ::Regex pattern for self .","title":"Mode"},{"location":"Validator/Constraints/Email/Mode/#Athena::Validator::Constraints::Email::Mode","text":"Determines how the email address should be validated.","title":"Mode"},{"location":"Validator/Constraints/Email/Mode/#members","text":"","title":"Members"},{"location":"Validator/Constraints/Email/Mode/#Athena::Validator::Constraints::Email::Mode::Loose","text":"Validates the email against a simple ::Regex that allows all values with an @ symbol and a . in the host part of the email address.","title":"Loose"},{"location":"Validator/Constraints/Email/Mode/#Athena::Validator::Constraints::Email::Mode::HTML5","text":"Validates the email against the HTML5 input pattern .","title":"HTML5"},{"location":"Validator/Constraints/Email/Mode/#methods","text":"","title":"Methods"},{"location":"Validator/Constraints/Email/Mode/#Athena::Validator::Constraints::Email::Mode#html5?()","text":"","title":"#html5?"},{"location":"Validator/Constraints/Email/Mode/#Athena::Validator::Constraints::Email::Mode#loose?()","text":"","title":"#loose?"},{"location":"Validator/Constraints/Email/Mode/#Athena::Validator::Constraints::Email::Mode#pattern()","text":"Returns the ::Regex pattern for self .","title":"#pattern"},{"location":"Validator/Constraints/Email/Validator/","text":"struct Athena::Validator::Constraints::Email::Validator inherits Athena::Validator::ConstraintValidator Methods #validate ( value : _ , constraint : AVD::Constraints::Email ) : Nil :inherit:","title":"Validator"},{"location":"Validator/Constraints/Email/Validator/#Athena::Validator::Constraints::Email::Validator","text":"","title":"Validator"},{"location":"Validator/Constraints/Email/Validator/#methods","text":"","title":"Methods"},{"location":"Validator/Constraints/Email/Validator/#Athena::Validator::Constraints::Email::Validator#validate(value,constraint)","text":":inherit:","title":"#validate"},{"location":"Validator/Constraints/EqualTo/","text":"class Athena::Validator::Constraints::EqualTo(ValueType) inherits Athena::Validator::Constraint Validates that a value is equal to another. Configuration Required Arguments value Defines the value that the value being validated should be compared to. Optional Arguments message Type: String Default: This value should be equal to {{ compared_value }}. The message that will be shown if the value is not equal to the comparison value. Placeholders The following placeholders can be used in this message: {{ value }} - The current (invalid) value. {{ compared_value }} - The expected value. {{ compared_value_type }} - The type of the expected value. groups Type: Array(String) | String | Nil Default: nil The validation groups this constraint belongs to. AVD::Constraint::DEFAULT_GROUP is assumed if nil . payload Type: Hash(String, String)? Default: nil Any arbitrary domain-specific data that should be stored with this constraint. The payload is not used by Athena::Validator , but its processing is completely up to you. Included modules Athena::Validator::Constraints::AbstractComparison Constants NOT_EQUAL_ERROR = \"47d83d11-15d5-4267-b469-1444f80fd169\" Class methods .new ( value : ValueType , message : String = default_error_message , groups : Array ( String ) | String | Nil = nil , payload : Hash ( String , String )? = nil ) Methods #default_error_message : String Returns the AVD::Constraint#message for this constraint. #validated_by : AVD :: ConstraintValidator . class Returns the AVD::ConstraintValidator.class that should handle validating self .","title":"EqualTo"},{"location":"Validator/Constraints/EqualTo/#Athena::Validator::Constraints::EqualTo","text":"Validates that a value is equal to another.","title":"EqualTo"},{"location":"Validator/Constraints/EqualTo/#Athena::Validator::Constraints::EqualTo--configuration","text":"","title":"Configuration"},{"location":"Validator/Constraints/EqualTo/#Athena::Validator::Constraints::EqualTo--required-arguments","text":"","title":"Required Arguments"},{"location":"Validator/Constraints/EqualTo/#Athena::Validator::Constraints::EqualTo--value","text":"Defines the value that the value being validated should be compared to.","title":"value"},{"location":"Validator/Constraints/EqualTo/#Athena::Validator::Constraints::EqualTo--optional-arguments","text":"","title":"Optional Arguments"},{"location":"Validator/Constraints/EqualTo/#Athena::Validator::Constraints::EqualTo--message","text":"Type: String Default: This value should be equal to {{ compared_value }}. The message that will be shown if the value is not equal to the comparison value.","title":"message"},{"location":"Validator/Constraints/EqualTo/#Athena::Validator::Constraints::EqualTo--placeholders","text":"The following placeholders can be used in this message: {{ value }} - The current (invalid) value. {{ compared_value }} - The expected value. {{ compared_value_type }} - The type of the expected value.","title":"Placeholders"},{"location":"Validator/Constraints/EqualTo/#Athena::Validator::Constraints::EqualTo--groups","text":"Type: Array(String) | String | Nil Default: nil The validation groups this constraint belongs to. AVD::Constraint::DEFAULT_GROUP is assumed if nil .","title":"groups"},{"location":"Validator/Constraints/EqualTo/#Athena::Validator::Constraints::EqualTo--payload","text":"Type: Hash(String, String)? Default: nil Any arbitrary domain-specific data that should be stored with this constraint. The payload is not used by Athena::Validator , but its processing is completely up to you.","title":"payload"},{"location":"Validator/Constraints/EqualTo/#included-modules","text":"Athena::Validator::Constraints::AbstractComparison","title":"Included modules"},{"location":"Validator/Constraints/EqualTo/#constants","text":"","title":"Constants"},{"location":"Validator/Constraints/EqualTo/#Athena::Validator::Constraints::EqualTo::NOT_EQUAL_ERROR","text":"","title":"NOT_EQUAL_ERROR"},{"location":"Validator/Constraints/EqualTo/#class-methods","text":"","title":"Class methods"},{"location":"Validator/Constraints/EqualTo/#Athena::Validator::Constraints::EqualTo.new(value,message,groups,payload)","text":"","title":".new"},{"location":"Validator/Constraints/EqualTo/#methods","text":"","title":"Methods"},{"location":"Validator/Constraints/EqualTo/#Athena::Validator::Constraints::EqualTo#default_error_message()","text":"Returns the AVD::Constraint#message for this constraint.","title":"#default_error_message"},{"location":"Validator/Constraints/EqualTo/#Athena::Validator::Constraints::EqualTo#validated_by()","text":"Returns the AVD::ConstraintValidator.class that should handle validating self .","title":"#validated_by"},{"location":"Validator/Constraints/EqualTo/Validator/","text":"struct Athena::Validator::Constraints::EqualTo::Validator inherits Athena::Validator::Constraints::ComparisonValidator Methods #compare_values ( actual : _ , expected : _ ) : Bool Returns true if the provided actual and expected values are compatible, otherwise false . #error_code : String Returns the expected error code for self .","title":"Validator"},{"location":"Validator/Constraints/EqualTo/Validator/#Athena::Validator::Constraints::EqualTo::Validator","text":"","title":"Validator"},{"location":"Validator/Constraints/EqualTo/Validator/#methods","text":"","title":"Methods"},{"location":"Validator/Constraints/EqualTo/Validator/#Athena::Validator::Constraints::EqualTo::Validator#compare_values(actual,expected)","text":"Returns true if the provided actual and expected values are compatible, otherwise false .","title":"#compare_values"},{"location":"Validator/Constraints/EqualTo/Validator/#Athena::Validator::Constraints::EqualTo::Validator#error_code()","text":"Returns the expected error code for self .","title":"#error_code"},{"location":"Validator/Constraints/GreaterThan/","text":"class Athena::Validator::Constraints::GreaterThan(ValueType) inherits Athena::Validator::Constraint Validates that a value is greater than another. Configuration Required Arguments value Type: Number | String | Time Defines the value that the value being validated should be compared to. Optional Arguments message Type: String Default: This value should be greater than {{ compared_value }}. The message that will be shown if the value is not greater than the comparison value. Placeholders The following placeholders can be used in this message: {{ value }} - The current (invalid) value. {{ compared_value }} - The expected value. {{ compared_value_type }} - The type of the expected value. groups Type: Array(String) | String | Nil Default: nil The validation groups this constraint belongs to. AVD::Constraint::DEFAULT_GROUP is assumed if nil . payload Type: Hash(String, String)? Default: nil Any arbitrary domain-specific data that should be stored with this constraint. The payload is not used by Athena::Validator , but its processing is completely up to you. Included modules Athena::Validator::Constraints::AbstractComparison Direct known subclasses Athena::Validator::Constraints::Positive Constants TOO_LOW_ERROR = \"a221096d-d125-44e8-a865-4270379ac11a\" Class methods .new ( value : ValueType , message : String = default_error_message , groups : Array ( String ) | String | Nil = nil , payload : Hash ( String , String )? = nil ) Methods #default_error_message : String Returns the AVD::Constraint#message for this constraint. #validated_by : AVD :: ConstraintValidator . class Returns the AVD::ConstraintValidator.class that should handle validating self .","title":"GreaterThan"},{"location":"Validator/Constraints/GreaterThan/#Athena::Validator::Constraints::GreaterThan","text":"Validates that a value is greater than another.","title":"GreaterThan"},{"location":"Validator/Constraints/GreaterThan/#Athena::Validator::Constraints::GreaterThan--configuration","text":"","title":"Configuration"},{"location":"Validator/Constraints/GreaterThan/#Athena::Validator::Constraints::GreaterThan--required-arguments","text":"","title":"Required Arguments"},{"location":"Validator/Constraints/GreaterThan/#Athena::Validator::Constraints::GreaterThan--value","text":"Type: Number | String | Time Defines the value that the value being validated should be compared to.","title":"value"},{"location":"Validator/Constraints/GreaterThan/#Athena::Validator::Constraints::GreaterThan--optional-arguments","text":"","title":"Optional Arguments"},{"location":"Validator/Constraints/GreaterThan/#Athena::Validator::Constraints::GreaterThan--message","text":"Type: String Default: This value should be greater than {{ compared_value }}. The message that will be shown if the value is not greater than the comparison value.","title":"message"},{"location":"Validator/Constraints/GreaterThan/#Athena::Validator::Constraints::GreaterThan--placeholders","text":"The following placeholders can be used in this message: {{ value }} - The current (invalid) value. {{ compared_value }} - The expected value. {{ compared_value_type }} - The type of the expected value.","title":"Placeholders"},{"location":"Validator/Constraints/GreaterThan/#Athena::Validator::Constraints::GreaterThan--groups","text":"Type: Array(String) | String | Nil Default: nil The validation groups this constraint belongs to. AVD::Constraint::DEFAULT_GROUP is assumed if nil .","title":"groups"},{"location":"Validator/Constraints/GreaterThan/#Athena::Validator::Constraints::GreaterThan--payload","text":"Type: Hash(String, String)? Default: nil Any arbitrary domain-specific data that should be stored with this constraint. The payload is not used by Athena::Validator , but its processing is completely up to you.","title":"payload"},{"location":"Validator/Constraints/GreaterThan/#included-modules","text":"Athena::Validator::Constraints::AbstractComparison","title":"Included modules"},{"location":"Validator/Constraints/GreaterThan/#direct-known-subclasses","text":"Athena::Validator::Constraints::Positive","title":"Direct known subclasses"},{"location":"Validator/Constraints/GreaterThan/#constants","text":"","title":"Constants"},{"location":"Validator/Constraints/GreaterThan/#Athena::Validator::Constraints::GreaterThan::TOO_LOW_ERROR","text":"","title":"TOO_LOW_ERROR"},{"location":"Validator/Constraints/GreaterThan/#class-methods","text":"","title":"Class methods"},{"location":"Validator/Constraints/GreaterThan/#Athena::Validator::Constraints::GreaterThan.new(value,message,groups,payload)","text":"","title":".new"},{"location":"Validator/Constraints/GreaterThan/#methods","text":"","title":"Methods"},{"location":"Validator/Constraints/GreaterThan/#Athena::Validator::Constraints::GreaterThan#default_error_message()","text":"Returns the AVD::Constraint#message for this constraint.","title":"#default_error_message"},{"location":"Validator/Constraints/GreaterThan/#Athena::Validator::Constraints::GreaterThan#validated_by()","text":"Returns the AVD::ConstraintValidator.class that should handle validating self .","title":"#validated_by"},{"location":"Validator/Constraints/GreaterThan/Validator/","text":"struct Athena::Validator::Constraints::GreaterThan::Validator inherits Athena::Validator::Constraints::ComparisonValidator Methods #compare_values ( actual : Number , expected : Number ) : Bool #compare_values ( actual : String , expected : String ) : Bool #compare_values ( actual : Time , expected : Time ) : Bool #compare_values ( actual : _ , expected : _ ) : NoReturn Returns true if the provided actual and expected values are compatible, otherwise false . #error_code : String Returns the expected error code for self .","title":"Validator"},{"location":"Validator/Constraints/GreaterThan/Validator/#Athena::Validator::Constraints::GreaterThan::Validator","text":"","title":"Validator"},{"location":"Validator/Constraints/GreaterThan/Validator/#methods","text":"","title":"Methods"},{"location":"Validator/Constraints/GreaterThan/Validator/#Athena::Validator::Constraints::GreaterThan::Validator#compare_values(actual,expected)","text":"","title":"#compare_values"},{"location":"Validator/Constraints/GreaterThan/Validator/#Athena::Validator::Constraints::GreaterThan::Validator#compare_values(actual,expected)","text":"","title":"#compare_values"},{"location":"Validator/Constraints/GreaterThan/Validator/#Athena::Validator::Constraints::GreaterThan::Validator#compare_values(actual,expected)","text":"","title":"#compare_values"},{"location":"Validator/Constraints/GreaterThan/Validator/#Athena::Validator::Constraints::GreaterThan::Validator#compare_values(actual,expected)","text":"Returns true if the provided actual and expected values are compatible, otherwise false .","title":"#compare_values"},{"location":"Validator/Constraints/GreaterThan/Validator/#Athena::Validator::Constraints::GreaterThan::Validator#error_code()","text":"Returns the expected error code for self .","title":"#error_code"},{"location":"Validator/Constraints/GreaterThanOrEqual/","text":"class Athena::Validator::Constraints::GreaterThanOrEqual(ValueType) inherits Athena::Validator::Constraint Validates that a value is greater than or equal to another. Configuration Required Arguments value Type: Number | String | Time Defines the value that the value being validated should be compared to. Optional Arguments message Type: String Default: This value should be greater than or equal to {{ compared_value }}. The message that will be shown if the value is not greater than or equal to the comparison value. Placeholders The following placeholders can be used in this message: {{ value }} - The current (invalid) value. {{ compared_value }} - The expected value. {{ compared_value_type }} - The type of the expected value. groups Type: Array(String) | String | Nil Default: nil The validation groups this constraint belongs to. AVD::Constraint::DEFAULT_GROUP is assumed if nil . payload Type: Hash(String, String)? Default: nil Any arbitrary domain-specific data that should be stored with this constraint. The payload is not used by Athena::Validator , but its processing is completely up to you. Included modules Athena::Validator::Constraints::AbstractComparison Direct known subclasses Athena::Validator::Constraints::PositiveOrZero Constants TOO_LOW_ERROR = \"e09e52d0-b549-4ba1-8b4e-420aad76f0de\" Class methods .new ( value : ValueType , message : String = default_error_message , groups : Array ( String ) | String | Nil = nil , payload : Hash ( String , String )? = nil ) Methods #default_error_message : String Returns the AVD::Constraint#message for this constraint. #validated_by : AVD :: ConstraintValidator . class Returns the AVD::ConstraintValidator.class that should handle validating self .","title":"GreaterThanOrEqual"},{"location":"Validator/Constraints/GreaterThanOrEqual/#Athena::Validator::Constraints::GreaterThanOrEqual","text":"Validates that a value is greater than or equal to another.","title":"GreaterThanOrEqual"},{"location":"Validator/Constraints/GreaterThanOrEqual/#Athena::Validator::Constraints::GreaterThanOrEqual--configuration","text":"","title":"Configuration"},{"location":"Validator/Constraints/GreaterThanOrEqual/#Athena::Validator::Constraints::GreaterThanOrEqual--required-arguments","text":"","title":"Required Arguments"},{"location":"Validator/Constraints/GreaterThanOrEqual/#Athena::Validator::Constraints::GreaterThanOrEqual--value","text":"Type: Number | String | Time Defines the value that the value being validated should be compared to.","title":"value"},{"location":"Validator/Constraints/GreaterThanOrEqual/#Athena::Validator::Constraints::GreaterThanOrEqual--optional-arguments","text":"","title":"Optional Arguments"},{"location":"Validator/Constraints/GreaterThanOrEqual/#Athena::Validator::Constraints::GreaterThanOrEqual--message","text":"Type: String Default: This value should be greater than or equal to {{ compared_value }}. The message that will be shown if the value is not greater than or equal to the comparison value.","title":"message"},{"location":"Validator/Constraints/GreaterThanOrEqual/#Athena::Validator::Constraints::GreaterThanOrEqual--placeholders","text":"The following placeholders can be used in this message: {{ value }} - The current (invalid) value. {{ compared_value }} - The expected value. {{ compared_value_type }} - The type of the expected value.","title":"Placeholders"},{"location":"Validator/Constraints/GreaterThanOrEqual/#Athena::Validator::Constraints::GreaterThanOrEqual--groups","text":"Type: Array(String) | String | Nil Default: nil The validation groups this constraint belongs to. AVD::Constraint::DEFAULT_GROUP is assumed if nil .","title":"groups"},{"location":"Validator/Constraints/GreaterThanOrEqual/#Athena::Validator::Constraints::GreaterThanOrEqual--payload","text":"Type: Hash(String, String)? Default: nil Any arbitrary domain-specific data that should be stored with this constraint. The payload is not used by Athena::Validator , but its processing is completely up to you.","title":"payload"},{"location":"Validator/Constraints/GreaterThanOrEqual/#included-modules","text":"Athena::Validator::Constraints::AbstractComparison","title":"Included modules"},{"location":"Validator/Constraints/GreaterThanOrEqual/#direct-known-subclasses","text":"Athena::Validator::Constraints::PositiveOrZero","title":"Direct known subclasses"},{"location":"Validator/Constraints/GreaterThanOrEqual/#constants","text":"","title":"Constants"},{"location":"Validator/Constraints/GreaterThanOrEqual/#Athena::Validator::Constraints::GreaterThanOrEqual::TOO_LOW_ERROR","text":"","title":"TOO_LOW_ERROR"},{"location":"Validator/Constraints/GreaterThanOrEqual/#class-methods","text":"","title":"Class methods"},{"location":"Validator/Constraints/GreaterThanOrEqual/#Athena::Validator::Constraints::GreaterThanOrEqual.new(value,message,groups,payload)","text":"","title":".new"},{"location":"Validator/Constraints/GreaterThanOrEqual/#methods","text":"","title":"Methods"},{"location":"Validator/Constraints/GreaterThanOrEqual/#Athena::Validator::Constraints::GreaterThanOrEqual#default_error_message()","text":"Returns the AVD::Constraint#message for this constraint.","title":"#default_error_message"},{"location":"Validator/Constraints/GreaterThanOrEqual/#Athena::Validator::Constraints::GreaterThanOrEqual#validated_by()","text":"Returns the AVD::ConstraintValidator.class that should handle validating self .","title":"#validated_by"},{"location":"Validator/Constraints/GreaterThanOrEqual/Validator/","text":"struct Athena::Validator::Constraints::GreaterThanOrEqual::Validator inherits Athena::Validator::Constraints::ComparisonValidator Methods #compare_values ( actual : Number , expected : Number ) : Bool #compare_values ( actual : String , expected : String ) : Bool #compare_values ( actual : Time , expected : Time ) : Bool #compare_values ( actual : _ , expected : _ ) : NoReturn Returns true if the provided actual and expected values are compatible, otherwise false . #error_code : String Returns the expected error code for self .","title":"Validator"},{"location":"Validator/Constraints/GreaterThanOrEqual/Validator/#Athena::Validator::Constraints::GreaterThanOrEqual::Validator","text":"","title":"Validator"},{"location":"Validator/Constraints/GreaterThanOrEqual/Validator/#methods","text":"","title":"Methods"},{"location":"Validator/Constraints/GreaterThanOrEqual/Validator/#Athena::Validator::Constraints::GreaterThanOrEqual::Validator#compare_values(actual,expected)","text":"","title":"#compare_values"},{"location":"Validator/Constraints/GreaterThanOrEqual/Validator/#Athena::Validator::Constraints::GreaterThanOrEqual::Validator#compare_values(actual,expected)","text":"","title":"#compare_values"},{"location":"Validator/Constraints/GreaterThanOrEqual/Validator/#Athena::Validator::Constraints::GreaterThanOrEqual::Validator#compare_values(actual,expected)","text":"","title":"#compare_values"},{"location":"Validator/Constraints/GreaterThanOrEqual/Validator/#Athena::Validator::Constraints::GreaterThanOrEqual::Validator#compare_values(actual,expected)","text":"Returns true if the provided actual and expected values are compatible, otherwise false .","title":"#compare_values"},{"location":"Validator/Constraints/GreaterThanOrEqual/Validator/#Athena::Validator::Constraints::GreaterThanOrEqual::Validator#error_code()","text":"Returns the expected error code for self .","title":"#error_code"},{"location":"Validator/Constraints/GroupSequence/","text":"struct Athena::Validator::Constraints::GroupSequence inherits Struct Allows validating your AVD::Constraint@validation-groups in steps. I.e. only continue to the next group if all constraints in the first group are valid. @[ Assert :: GroupSequence ( \"User\" , \"strict\" ) ] class User include AVD :: Validatable @[ Assert :: NotBlank ] property name : String @[ Assert :: NotBlank ] property password : String def initialize ( @name : String , @password : String ); end @[ Assert :: IsTrue ( message : \"Your password cannot be the same as your name.\" , groups : \"strict\" ) ] def is_safe_password? : Bool @name != @password end end In this case, it'll validate the name and password properties are not blank before validating they are not the same. If either property is blank, the is_safe_password? validation will be skipped. NOTE: The default group is not allowed as part of a group sequence. NOTE: Calling validate with a group in the sequence, such as strict , will cause violations to ONLY use that group and not all groups within the sequence. This is because the group sequence is now referred to as the default group. See AVD::Constraints::GroupSequence::Provider for a way to dynamically determine the sequence an object should use. Class methods .new ( groups : Array ( String )) .new ( groups : Array ( String | Array ( String ))) Methods #groups : Array ( String | Array ( String ))","title":"GroupSequence"},{"location":"Validator/Constraints/GroupSequence/#Athena::Validator::Constraints::GroupSequence","text":"Allows validating your AVD::Constraint@validation-groups in steps. I.e. only continue to the next group if all constraints in the first group are valid. @[ Assert :: GroupSequence ( \"User\" , \"strict\" ) ] class User include AVD :: Validatable @[ Assert :: NotBlank ] property name : String @[ Assert :: NotBlank ] property password : String def initialize ( @name : String , @password : String ); end @[ Assert :: IsTrue ( message : \"Your password cannot be the same as your name.\" , groups : \"strict\" ) ] def is_safe_password? : Bool @name != @password end end In this case, it'll validate the name and password properties are not blank before validating they are not the same. If either property is blank, the is_safe_password? validation will be skipped. NOTE: The default group is not allowed as part of a group sequence. NOTE: Calling validate with a group in the sequence, such as strict , will cause violations to ONLY use that group and not all groups within the sequence. This is because the group sequence is now referred to as the default group. See AVD::Constraints::GroupSequence::Provider for a way to dynamically determine the sequence an object should use.","title":"GroupSequence"},{"location":"Validator/Constraints/GroupSequence/#class-methods","text":"","title":"Class methods"},{"location":"Validator/Constraints/GroupSequence/#Athena::Validator::Constraints::GroupSequence.new(groups)","text":"","title":".new"},{"location":"Validator/Constraints/GroupSequence/#Athena::Validator::Constraints::GroupSequence.new(groups)","text":"","title":".new"},{"location":"Validator/Constraints/GroupSequence/#methods","text":"","title":"Methods"},{"location":"Validator/Constraints/GroupSequence/#Athena::Validator::Constraints::GroupSequence#groups()","text":"","title":"#groups"},{"location":"Validator/Constraints/GroupSequence/Provider/","text":"module Athena::Validator::Constraints::GroupSequence::Provider AVD::Constraints::GroupSequence s can be a good way to create efficient validations. However, since the sequence is static, it is not a very flexible solution. Group sequence providers allow the sequence to be dynamically determined at runtime. This allows running specific validations only when the object is in a specific state, such as validating a \"registered\" user differently than a non-registered user. class User include AVD :: Validatable # Include the interface that informs the validator this object will provide its sequence. include AVD :: Constraints :: GroupSequence :: Provider @[ Assert :: NotBlank ] property name : String # Only validate the `email` property if the `#group_sequence` method includes \"registered\" # Which can be determined using the current state of the object. @[ Assert :: Email ( groups : \"registered\" ) ] @[ Assert :: NotBlank ( groups : \"registered\" ) ] property email : String ? def initialize ( @name : String , @email : String ); end # Define a method that returns the sequence. def group_sequence : Array ( String | Array ( String )) | AVD :: Constraints :: GroupSequence # When returning a 1D array, if there is a vaiolation in any group # the rest of the groups are not validated. E.g. if `User` fails, # `registered` and `api` are not validated: return [ \"User\" , \"registered\" , \"api\" ] # When returning a nested array, all groups included in each array are validated. # E.g. if `User` fails, `Premium` is also validated (and you'll get its violations), # but `api` will not be validated return [[ \"User\" , \"registered\" ] , \"api\" ] end end See AVD::Constraints::Sequentially for a more straightforward method of applying constraints sequentially on a single property. Direct including types Athena::Validator::Spec::EntityGroupSequenceProvider Athena::Validator::Spec::EntitySequenceProvider Methods abstract #group_sequence : Array ( String | Array ( String )) | AVD::Constraints::GroupSequence","title":"Provider"},{"location":"Validator/Constraints/GroupSequence/Provider/#Athena::Validator::Constraints::GroupSequence::Provider","text":"AVD::Constraints::GroupSequence s can be a good way to create efficient validations. However, since the sequence is static, it is not a very flexible solution. Group sequence providers allow the sequence to be dynamically determined at runtime. This allows running specific validations only when the object is in a specific state, such as validating a \"registered\" user differently than a non-registered user. class User include AVD :: Validatable # Include the interface that informs the validator this object will provide its sequence. include AVD :: Constraints :: GroupSequence :: Provider @[ Assert :: NotBlank ] property name : String # Only validate the `email` property if the `#group_sequence` method includes \"registered\" # Which can be determined using the current state of the object. @[ Assert :: Email ( groups : \"registered\" ) ] @[ Assert :: NotBlank ( groups : \"registered\" ) ] property email : String ? def initialize ( @name : String , @email : String ); end # Define a method that returns the sequence. def group_sequence : Array ( String | Array ( String )) | AVD :: Constraints :: GroupSequence # When returning a 1D array, if there is a vaiolation in any group # the rest of the groups are not validated. E.g. if `User` fails, # `registered` and `api` are not validated: return [ \"User\" , \"registered\" , \"api\" ] # When returning a nested array, all groups included in each array are validated. # E.g. if `User` fails, `Premium` is also validated (and you'll get its violations), # but `api` will not be validated return [[ \"User\" , \"registered\" ] , \"api\" ] end end See AVD::Constraints::Sequentially for a more straightforward method of applying constraints sequentially on a single property.","title":"Provider"},{"location":"Validator/Constraints/GroupSequence/Provider/#direct-including-types","text":"Athena::Validator::Spec::EntityGroupSequenceProvider Athena::Validator::Spec::EntitySequenceProvider","title":"Direct including types"},{"location":"Validator/Constraints/GroupSequence/Provider/#methods","text":"","title":"Methods"},{"location":"Validator/Constraints/GroupSequence/Provider/#Athena::Validator::Constraints::GroupSequence::Provider#group_sequence()","text":"","title":"#group_sequence"},{"location":"Validator/Constraints/IP/","text":"class Athena::Validator::Constraints::IP inherits Athena::Validator::Constraint Validates that a value is a valid IP address. By default validates the value as an IPv4 address, but can be customized to validate IPv6 s, or both. The underlying value is converted to a string via #to_s before being validated. NOTE: As with most other constraints, nil and empty strings are considered valid values, in order to allow the value to be optional. If the value is required, consider combining this constraint with AVD::Constraints::NotBlank . Configuration Optional Arguments version Type: AVD::Constraints::IP::Version Default: AVD::Constraints::IP::Version::V4 Defines the pattern that should be used to validate the IP address. message Type: String Default: This is not a valid IP address. The message that will be shown if the value is not a valid IP address. Placeholders The following placeholders can be used in this message: {{ value }} - The current (invalid) value. groups Type: Array(String) | String | Nil Default: nil The validation groups this constraint belongs to. AVD::Constraint::DEFAULT_GROUP is assumed if nil . payload Type: Hash(String, String)? Default: nil Any arbitrary domain-specific data that should be stored with this constraint. The payload is not used by Athena::Validator , but its processing is completely up to you. Constants INVALID_IP_ERROR = \"326b0aa4-3871-404d-986d-fe3e6c82005c\" Class methods .new ( version : AVD::Constraints::IP::Version = :v4 , message : String = \"This value is not a valid IP address.\" , groups : Array ( String ) | String | Nil = nil , payload : Hash ( String , String )? = nil ) Methods #validated_by : AVD :: ConstraintValidator . class Returns the AVD::ConstraintValidator.class that should handle validating self . #version : AVD::Constraints::IP::Version","title":"IP"},{"location":"Validator/Constraints/IP/#Athena::Validator::Constraints::IP","text":"Validates that a value is a valid IP address. By default validates the value as an IPv4 address, but can be customized to validate IPv6 s, or both. The underlying value is converted to a string via #to_s before being validated. NOTE: As with most other constraints, nil and empty strings are considered valid values, in order to allow the value to be optional. If the value is required, consider combining this constraint with AVD::Constraints::NotBlank .","title":"IP"},{"location":"Validator/Constraints/IP/#Athena::Validator::Constraints::IP--configuration","text":"","title":"Configuration"},{"location":"Validator/Constraints/IP/#Athena::Validator::Constraints::IP--optional-arguments","text":"","title":"Optional Arguments"},{"location":"Validator/Constraints/IP/#Athena::Validator::Constraints::IP--version","text":"Type: AVD::Constraints::IP::Version Default: AVD::Constraints::IP::Version::V4 Defines the pattern that should be used to validate the IP address.","title":"version"},{"location":"Validator/Constraints/IP/#Athena::Validator::Constraints::IP--message","text":"Type: String Default: This is not a valid IP address. The message that will be shown if the value is not a valid IP address.","title":"message"},{"location":"Validator/Constraints/IP/#Athena::Validator::Constraints::IP--placeholders","text":"The following placeholders can be used in this message: {{ value }} - The current (invalid) value.","title":"Placeholders"},{"location":"Validator/Constraints/IP/#Athena::Validator::Constraints::IP--groups","text":"Type: Array(String) | String | Nil Default: nil The validation groups this constraint belongs to. AVD::Constraint::DEFAULT_GROUP is assumed if nil .","title":"groups"},{"location":"Validator/Constraints/IP/#Athena::Validator::Constraints::IP--payload","text":"Type: Hash(String, String)? Default: nil Any arbitrary domain-specific data that should be stored with this constraint. The payload is not used by Athena::Validator , but its processing is completely up to you.","title":"payload"},{"location":"Validator/Constraints/IP/#constants","text":"","title":"Constants"},{"location":"Validator/Constraints/IP/#Athena::Validator::Constraints::IP::INVALID_IP_ERROR","text":"","title":"INVALID_IP_ERROR"},{"location":"Validator/Constraints/IP/#class-methods","text":"","title":"Class methods"},{"location":"Validator/Constraints/IP/#Athena::Validator::Constraints::IP.new(version,message,groups,payload)","text":"","title":".new"},{"location":"Validator/Constraints/IP/#methods","text":"","title":"Methods"},{"location":"Validator/Constraints/IP/#Athena::Validator::Constraints::IP#validated_by()","text":"Returns the AVD::ConstraintValidator.class that should handle validating self .","title":"#validated_by"},{"location":"Validator/Constraints/IP/#Athena::Validator::Constraints::IP#version()","text":"","title":"#version"},{"location":"Validator/Constraints/IP/Validator/","text":"struct Athena::Validator::Constraints::IP::Validator inherits Athena::Validator::ConstraintValidator Methods #validate ( value : _ , constraint : AVD::Constraints::IP ) : Nil :inherit:","title":"Validator"},{"location":"Validator/Constraints/IP/Validator/#Athena::Validator::Constraints::IP::Validator","text":"","title":"Validator"},{"location":"Validator/Constraints/IP/Validator/#methods","text":"","title":"Methods"},{"location":"Validator/Constraints/IP/Validator/#Athena::Validator::Constraints::IP::Validator#validate(value,constraint)","text":":inherit:","title":"#validate"},{"location":"Validator/Constraints/IP/Version/","text":"enum Athena::Validator::Constraints::IP::Version Determines how the IP address should be validated. Members V4 = 0 Validates for IPv4 addresses. V6 = 1 Validates for IPv6 addresses. V4_V6 = 2 Validates for IPv4 or IPv6 addresses. Methods #pattern : :: Regex Returns the ::Regex pattern for self . #v4? #v4_v6? #v6?","title":"Version"},{"location":"Validator/Constraints/IP/Version/#Athena::Validator::Constraints::IP::Version","text":"Determines how the IP address should be validated.","title":"Version"},{"location":"Validator/Constraints/IP/Version/#members","text":"","title":"Members"},{"location":"Validator/Constraints/IP/Version/#Athena::Validator::Constraints::IP::Version::V4","text":"Validates for IPv4 addresses.","title":"V4"},{"location":"Validator/Constraints/IP/Version/#Athena::Validator::Constraints::IP::Version::V6","text":"Validates for IPv6 addresses.","title":"V6"},{"location":"Validator/Constraints/IP/Version/#Athena::Validator::Constraints::IP::Version::V4_V6","text":"Validates for IPv4 or IPv6 addresses.","title":"V4_V6"},{"location":"Validator/Constraints/IP/Version/#methods","text":"","title":"Methods"},{"location":"Validator/Constraints/IP/Version/#Athena::Validator::Constraints::IP::Version#pattern()","text":"Returns the ::Regex pattern for self .","title":"#pattern"},{"location":"Validator/Constraints/IP/Version/#Athena::Validator::Constraints::IP::Version#v4?()","text":"","title":"#v4?"},{"location":"Validator/Constraints/IP/Version/#Athena::Validator::Constraints::IP::Version#v4_v6?()","text":"","title":"#v4_v6?"},{"location":"Validator/Constraints/IP/Version/#Athena::Validator::Constraints::IP::Version#v6?()","text":"","title":"#v6?"},{"location":"Validator/Constraints/ISBN/","text":"class Athena::Validator::Constraints::ISBN inherits Athena::Validator::Constraint Validates that an International Standard Book Number (ISBN) is either a valid ISBN-10 or ISBN-13 . The underlying value is converted to a string via #to_s before being validated. NOTE: As with most other constraints, nil and empty strings are considered valid values, in order to allow the value to be optional. If the value is required, consider combining this constraint with AVD::Constraints::NotBlank . Configuration Optional Arguments type Type: AVD::Constraints::ISBN::Type Default: AVD::Constraints::ISBN::Type::Both Type of ISBN to validate against. message Type: String Default: \"\" The message that will be shown if the value is invalid. This message has priority over the other messages if not empty. Placeholders The following placeholders can be used in this message: {{ value }} - The current (invalid) value. isbn10_message Type: String Default: This value is not a valid ISBN-10. The message that will be shown if type is AVD::Constraints::ISBN::Type::ISBN10 and the value is invalid. Placeholders The following placeholders can be used in this message: {{ value }} - The current (invalid) value. isbn13_message Type: String Default: This value is not a valid ISBN-13. The message that will be shown if type is AVD::Constraints::ISBN::Type::ISBN13 and the value is invalid. Placeholders The following placeholders can be used in this message: {{ value }} - The current (invalid) value. both_message Type: String Default: This value is neither a valid ISBN-10 nor a valid ISBN-13. The message that will be shown if type is AVD::Constraints::ISBN::Type::Both and the value is invalid. Placeholders The following placeholders can be used in this message: {{ value }} - The current (invalid) value. groups Type: Array(String) | String | Nil Default: nil The validation groups this constraint belongs to. AVD::Constraint::DEFAULT_GROUP is assumed if nil . payload Type: Hash(String, String)? Default: nil Any arbitrary domain-specific data that should be stored with this constraint. The payload is not used by Athena::Validator , but its processing is completely up to you. Constants CHECKSUM_FAILED_ERROR = \"f51bae62-6833-43b1-bc27-ae4445c59e30\" INVALID_CHARACTERS_ERROR = \"25d35907-d822-4bcc-82cc-852e30c89c0d\" TOO_LONG_ERROR = \"ebd28c75-bb42-43d6-9053-f0ea2ea93d44\" TOO_SHORT_ERROR = \"5da9e91f-7956-40f7-9788-4124463d783e\" TYPE_NOT_RECOGNIZED_ERROR = \"8d83f04d-2503-4547-97a1-935fcccd1ae1\" Class methods .new ( type : AVD::Constraints::ISBN::Type = :both , isbn10_message : String = \"This value is not a valid ISBN-10.\" , isbn13_message : String = \"This value is not a valid ISBN-13.\" , both_message : String = \"This value is neither a valid ISBN-10 nor a valid ISBN-13.\" , message : String = \"\" , groups : Array ( String ) | String | Nil = nil , payload : Hash ( String , String )? = nil ) Methods #both_message : String #isbn10_message : String #isbn13_message : String #message : String Returns the message that should be rendered if self is found to be invalid. NOTE: Some subtypes do not use this and instead define multiple message properties in order to support more specific error messages. #type : AVD::Constraints::ISBN::Type #validated_by : AVD :: ConstraintValidator . class Returns the AVD::ConstraintValidator.class that should handle validating self .","title":"ISBN"},{"location":"Validator/Constraints/ISBN/#Athena::Validator::Constraints::ISBN","text":"Validates that an International Standard Book Number (ISBN) is either a valid ISBN-10 or ISBN-13 . The underlying value is converted to a string via #to_s before being validated. NOTE: As with most other constraints, nil and empty strings are considered valid values, in order to allow the value to be optional. If the value is required, consider combining this constraint with AVD::Constraints::NotBlank .","title":"ISBN"},{"location":"Validator/Constraints/ISBN/#Athena::Validator::Constraints::ISBN--configuration","text":"","title":"Configuration"},{"location":"Validator/Constraints/ISBN/#Athena::Validator::Constraints::ISBN--optional-arguments","text":"","title":"Optional Arguments"},{"location":"Validator/Constraints/ISBN/#Athena::Validator::Constraints::ISBN--type","text":"Type: AVD::Constraints::ISBN::Type Default: AVD::Constraints::ISBN::Type::Both Type of ISBN to validate against.","title":"type"},{"location":"Validator/Constraints/ISBN/#Athena::Validator::Constraints::ISBN--message","text":"Type: String Default: \"\" The message that will be shown if the value is invalid. This message has priority over the other messages if not empty.","title":"message"},{"location":"Validator/Constraints/ISBN/#Athena::Validator::Constraints::ISBN--placeholders","text":"The following placeholders can be used in this message: {{ value }} - The current (invalid) value.","title":"Placeholders"},{"location":"Validator/Constraints/ISBN/#Athena::Validator::Constraints::ISBN--isbn10_message","text":"Type: String Default: This value is not a valid ISBN-10. The message that will be shown if type is AVD::Constraints::ISBN::Type::ISBN10 and the value is invalid.","title":"isbn10_message"},{"location":"Validator/Constraints/ISBN/#Athena::Validator::Constraints::ISBN--placeholders_1","text":"The following placeholders can be used in this message: {{ value }} - The current (invalid) value.","title":"Placeholders"},{"location":"Validator/Constraints/ISBN/#Athena::Validator::Constraints::ISBN--isbn13_message","text":"Type: String Default: This value is not a valid ISBN-13. The message that will be shown if type is AVD::Constraints::ISBN::Type::ISBN13 and the value is invalid.","title":"isbn13_message"},{"location":"Validator/Constraints/ISBN/#Athena::Validator::Constraints::ISBN--placeholders_2","text":"The following placeholders can be used in this message: {{ value }} - The current (invalid) value.","title":"Placeholders"},{"location":"Validator/Constraints/ISBN/#Athena::Validator::Constraints::ISBN--both_message","text":"Type: String Default: This value is neither a valid ISBN-10 nor a valid ISBN-13. The message that will be shown if type is AVD::Constraints::ISBN::Type::Both and the value is invalid.","title":"both_message"},{"location":"Validator/Constraints/ISBN/#Athena::Validator::Constraints::ISBN--placeholders_3","text":"The following placeholders can be used in this message: {{ value }} - The current (invalid) value.","title":"Placeholders"},{"location":"Validator/Constraints/ISBN/#Athena::Validator::Constraints::ISBN--groups","text":"Type: Array(String) | String | Nil Default: nil The validation groups this constraint belongs to. AVD::Constraint::DEFAULT_GROUP is assumed if nil .","title":"groups"},{"location":"Validator/Constraints/ISBN/#Athena::Validator::Constraints::ISBN--payload","text":"Type: Hash(String, String)? Default: nil Any arbitrary domain-specific data that should be stored with this constraint. The payload is not used by Athena::Validator , but its processing is completely up to you.","title":"payload"},{"location":"Validator/Constraints/ISBN/#constants","text":"","title":"Constants"},{"location":"Validator/Constraints/ISBN/#Athena::Validator::Constraints::ISBN::CHECKSUM_FAILED_ERROR","text":"","title":"CHECKSUM_FAILED_ERROR"},{"location":"Validator/Constraints/ISBN/#Athena::Validator::Constraints::ISBN::INVALID_CHARACTERS_ERROR","text":"","title":"INVALID_CHARACTERS_ERROR"},{"location":"Validator/Constraints/ISBN/#Athena::Validator::Constraints::ISBN::TOO_LONG_ERROR","text":"","title":"TOO_LONG_ERROR"},{"location":"Validator/Constraints/ISBN/#Athena::Validator::Constraints::ISBN::TOO_SHORT_ERROR","text":"","title":"TOO_SHORT_ERROR"},{"location":"Validator/Constraints/ISBN/#Athena::Validator::Constraints::ISBN::TYPE_NOT_RECOGNIZED_ERROR","text":"","title":"TYPE_NOT_RECOGNIZED_ERROR"},{"location":"Validator/Constraints/ISBN/#class-methods","text":"","title":"Class methods"},{"location":"Validator/Constraints/ISBN/#Athena::Validator::Constraints::ISBN.new(type,isbn10_message,isbn13_message,both_message,message,groups,payload)","text":"","title":".new"},{"location":"Validator/Constraints/ISBN/#methods","text":"","title":"Methods"},{"location":"Validator/Constraints/ISBN/#Athena::Validator::Constraints::ISBN#both_message()","text":"","title":"#both_message"},{"location":"Validator/Constraints/ISBN/#Athena::Validator::Constraints::ISBN#isbn10_message()","text":"","title":"#isbn10_message"},{"location":"Validator/Constraints/ISBN/#Athena::Validator::Constraints::ISBN#isbn13_message()","text":"","title":"#isbn13_message"},{"location":"Validator/Constraints/ISBN/#Athena::Validator::Constraints::ISBN#message()","text":"Returns the message that should be rendered if self is found to be invalid. NOTE: Some subtypes do not use this and instead define multiple message properties in order to support more specific error messages.","title":"#message"},{"location":"Validator/Constraints/ISBN/#Athena::Validator::Constraints::ISBN#type()","text":"","title":"#type"},{"location":"Validator/Constraints/ISBN/#Athena::Validator::Constraints::ISBN#validated_by()","text":"Returns the AVD::ConstraintValidator.class that should handle validating self .","title":"#validated_by"},{"location":"Validator/Constraints/ISBN/Type/","text":"enum Athena::Validator::Constraints::ISBN::Type Members ISBN10 = 0 ISBN13 = 1 Both = 2 Methods #both? #isbn10? #isbn13? #message ( constraint : AVD::Constraints::ISBN ) : String","title":"Type"},{"location":"Validator/Constraints/ISBN/Type/#Athena::Validator::Constraints::ISBN::Type","text":"","title":"Type"},{"location":"Validator/Constraints/ISBN/Type/#members","text":"","title":"Members"},{"location":"Validator/Constraints/ISBN/Type/#Athena::Validator::Constraints::ISBN::Type::ISBN10","text":"","title":"ISBN10"},{"location":"Validator/Constraints/ISBN/Type/#Athena::Validator::Constraints::ISBN::Type::ISBN13","text":"","title":"ISBN13"},{"location":"Validator/Constraints/ISBN/Type/#Athena::Validator::Constraints::ISBN::Type::Both","text":"","title":"Both"},{"location":"Validator/Constraints/ISBN/Type/#methods","text":"","title":"Methods"},{"location":"Validator/Constraints/ISBN/Type/#Athena::Validator::Constraints::ISBN::Type#both?()","text":"","title":"#both?"},{"location":"Validator/Constraints/ISBN/Type/#Athena::Validator::Constraints::ISBN::Type#isbn10?()","text":"","title":"#isbn10?"},{"location":"Validator/Constraints/ISBN/Type/#Athena::Validator::Constraints::ISBN::Type#isbn13?()","text":"","title":"#isbn13?"},{"location":"Validator/Constraints/ISBN/Type/#Athena::Validator::Constraints::ISBN::Type#message(constraint)","text":"","title":"#message"},{"location":"Validator/Constraints/ISBN/Validator/","text":"struct Athena::Validator::Constraints::ISBN::Validator inherits Athena::Validator::ConstraintValidator Methods #validate ( value : _ , constraint : AVD::Constraints::ISBN ) : Nil :inherit:","title":"Validator"},{"location":"Validator/Constraints/ISBN/Validator/#Athena::Validator::Constraints::ISBN::Validator","text":"","title":"Validator"},{"location":"Validator/Constraints/ISBN/Validator/#methods","text":"","title":"Methods"},{"location":"Validator/Constraints/ISBN/Validator/#Athena::Validator::Constraints::ISBN::Validator#validate(value,constraint)","text":":inherit:","title":"#validate"},{"location":"Validator/Constraints/ISIN/","text":"class Athena::Validator::Constraints::ISIN inherits Athena::Validator::Constraint Validates that a value is a valid International Securities Identification Number (ISIN) . The underlying value is converted to a string via #to_s before being validated. NOTE: As with most other constraints, nil and empty strings are considered valid values, in order to allow the value to be optional. If the value is required, consider combining this constraint with AVD::Constraints::NotBlank . Configuration Optional Arguments message Type: String Default: This value is not a valid International Securities Identification Number (ISIN). The message that will be shown if the value is not a valid ISIN. Placeholders The following placeholders can be used in this message: {{ value }} - The current (invalid) value. groups Type: Array(String) | String | Nil Default: nil The validation groups this constraint belongs to. AVD::Constraint::DEFAULT_GROUP is assumed if nil . payload Type: Hash(String, String)? Default: nil Any arbitrary domain-specific data that should be stored with this constraint. The payload is not used by Athena::Validator , but its processing is completely up to you. Constants INVALID_CHECKSUM_ERROR = \"c7d37ffb-0273-4f57-91f7-f47bf49aad08\" INVALID_LENGTH_ERROR = \"1d1c3fbe-5b6f-42be-afa5-6840655865da\" INVALID_PATTERN_ERROR = \"0b6ba8c4-b6aa-44dc-afac-a6f7a9a2556d\" Class methods .new ( message : String = \"This value is not a valid International Securities Identification Number (ISIN).\" , groups : Array ( String ) | String | Nil = nil , payload : Hash ( String , String )? = nil ) Methods #validated_by : AVD :: ConstraintValidator . class Returns the AVD::ConstraintValidator.class that should handle validating self .","title":"ISIN"},{"location":"Validator/Constraints/ISIN/#Athena::Validator::Constraints::ISIN","text":"Validates that a value is a valid International Securities Identification Number (ISIN) . The underlying value is converted to a string via #to_s before being validated. NOTE: As with most other constraints, nil and empty strings are considered valid values, in order to allow the value to be optional. If the value is required, consider combining this constraint with AVD::Constraints::NotBlank .","title":"ISIN"},{"location":"Validator/Constraints/ISIN/#Athena::Validator::Constraints::ISIN--configuration","text":"","title":"Configuration"},{"location":"Validator/Constraints/ISIN/#Athena::Validator::Constraints::ISIN--optional-arguments","text":"","title":"Optional Arguments"},{"location":"Validator/Constraints/ISIN/#Athena::Validator::Constraints::ISIN--message","text":"Type: String Default: This value is not a valid International Securities Identification Number (ISIN). The message that will be shown if the value is not a valid ISIN.","title":"message"},{"location":"Validator/Constraints/ISIN/#Athena::Validator::Constraints::ISIN--placeholders","text":"The following placeholders can be used in this message: {{ value }} - The current (invalid) value.","title":"Placeholders"},{"location":"Validator/Constraints/ISIN/#Athena::Validator::Constraints::ISIN--groups","text":"Type: Array(String) | String | Nil Default: nil The validation groups this constraint belongs to. AVD::Constraint::DEFAULT_GROUP is assumed if nil .","title":"groups"},{"location":"Validator/Constraints/ISIN/#Athena::Validator::Constraints::ISIN--payload","text":"Type: Hash(String, String)? Default: nil Any arbitrary domain-specific data that should be stored with this constraint. The payload is not used by Athena::Validator , but its processing is completely up to you.","title":"payload"},{"location":"Validator/Constraints/ISIN/#constants","text":"","title":"Constants"},{"location":"Validator/Constraints/ISIN/#Athena::Validator::Constraints::ISIN::INVALID_CHECKSUM_ERROR","text":"","title":"INVALID_CHECKSUM_ERROR"},{"location":"Validator/Constraints/ISIN/#Athena::Validator::Constraints::ISIN::INVALID_LENGTH_ERROR","text":"","title":"INVALID_LENGTH_ERROR"},{"location":"Validator/Constraints/ISIN/#Athena::Validator::Constraints::ISIN::INVALID_PATTERN_ERROR","text":"","title":"INVALID_PATTERN_ERROR"},{"location":"Validator/Constraints/ISIN/#class-methods","text":"","title":"Class methods"},{"location":"Validator/Constraints/ISIN/#Athena::Validator::Constraints::ISIN.new(message,groups,payload)","text":"","title":".new"},{"location":"Validator/Constraints/ISIN/#methods","text":"","title":"Methods"},{"location":"Validator/Constraints/ISIN/#Athena::Validator::Constraints::ISIN#validated_by()","text":"Returns the AVD::ConstraintValidator.class that should handle validating self .","title":"#validated_by"},{"location":"Validator/Constraints/ISIN/Validator/","text":"struct Athena::Validator::Constraints::ISIN::Validator inherits Athena::Validator::ConstraintValidator Methods #validate ( value : _ , constraint : AVD::Constraints::ISIN ) : Nil :inherit:","title":"Validator"},{"location":"Validator/Constraints/ISIN/Validator/#Athena::Validator::Constraints::ISIN::Validator","text":"","title":"Validator"},{"location":"Validator/Constraints/ISIN/Validator/#methods","text":"","title":"Methods"},{"location":"Validator/Constraints/ISIN/Validator/#Athena::Validator::Constraints::ISIN::Validator#validate(value,constraint)","text":":inherit:","title":"#validate"},{"location":"Validator/Constraints/ISSN/","text":"class Athena::Validator::Constraints::ISSN inherits Athena::Validator::Constraint Validates that a value is a valid International Standard Serial Number (ISSN) . The underlying value is converted to a string via #to_s before being validated. NOTE: As with most other constraints, nil and empty strings are considered valid values, in order to allow the value to be optional. If the value is required, consider combining this constraint with AVD::Constraints::NotBlank . Configuration Optional Arguments case_sensitive Type: Bool Default: false The validator will allow ISSN values to end with a lowercase x by default. When set to true , this requires an uppcase case X . require_hypen Type: Bool Default: false The validator will allow non hyphenated values by default. When set to true , this requires a hyphenated ISSN value. message Type: String Default: This value is not a valid International Standard Serial Number (ISSN). The message that will be shown if the value is not a valid ISSN. Placeholders The following placeholders can be used in this message: {{ value }} - The current (invalid) value. groups Type: Array(String) | String | Nil Default: nil The validation groups this constraint belongs to. AVD::Constraint::DEFAULT_GROUP is assumed if nil . payload Type: Hash(String, String)? Default: nil Any arbitrary domain-specific data that should be stored with this constraint. The payload is not used by Athena::Validator , but its processing is completely up to you. Constants CHECKSUM_FAILED_ERROR = \"62c01bab-fe8f-4072-aac8-aa4bdcde8361\" INVALID_CASE_ERROR = \"66f892f3-9eed-4176-b823-0dafde72202a\" INVALID_CHARACTERS_ERROR = \"85c5d3aa-fd0a-4cd0-8cf7-e014e6379d59\" MISSING_HYPHEN_ERROR = \"d6c120a9-0b56-4e45-b4bc-7fd186f2cfbd\" TOO_LONG_ERROR = \"fab8e3ea-2f77-4da7-b40f-d9b24ff8c0cc\" TOO_SHORT_ERROR = \"85c5d3aa-fd0a-4cd0-8cf7-e014e6379d59\" Class methods .new ( case_sensitive : Bool = false , require_hypen : Bool = false , message : String = \"This value is not a valid International Standard Serial Number (ISSN).\" , groups : Array ( String ) | String | Nil = nil , payload : Hash ( String , String )? = nil ) Methods #case_sensitive? : Bool #require_hypen? : Bool #validated_by : AVD :: ConstraintValidator . class Returns the AVD::ConstraintValidator.class that should handle validating self .","title":"ISSN"},{"location":"Validator/Constraints/ISSN/#Athena::Validator::Constraints::ISSN","text":"Validates that a value is a valid International Standard Serial Number (ISSN) . The underlying value is converted to a string via #to_s before being validated. NOTE: As with most other constraints, nil and empty strings are considered valid values, in order to allow the value to be optional. If the value is required, consider combining this constraint with AVD::Constraints::NotBlank .","title":"ISSN"},{"location":"Validator/Constraints/ISSN/#Athena::Validator::Constraints::ISSN--configuration","text":"","title":"Configuration"},{"location":"Validator/Constraints/ISSN/#Athena::Validator::Constraints::ISSN--optional-arguments","text":"","title":"Optional Arguments"},{"location":"Validator/Constraints/ISSN/#Athena::Validator::Constraints::ISSN--case_sensitive","text":"Type: Bool Default: false The validator will allow ISSN values to end with a lowercase x by default. When set to true , this requires an uppcase case X .","title":"case_sensitive"},{"location":"Validator/Constraints/ISSN/#Athena::Validator::Constraints::ISSN--require_hypen","text":"Type: Bool Default: false The validator will allow non hyphenated values by default. When set to true , this requires a hyphenated ISSN value.","title":"require_hypen"},{"location":"Validator/Constraints/ISSN/#Athena::Validator::Constraints::ISSN--message","text":"Type: String Default: This value is not a valid International Standard Serial Number (ISSN). The message that will be shown if the value is not a valid ISSN.","title":"message"},{"location":"Validator/Constraints/ISSN/#Athena::Validator::Constraints::ISSN--placeholders","text":"The following placeholders can be used in this message: {{ value }} - The current (invalid) value.","title":"Placeholders"},{"location":"Validator/Constraints/ISSN/#Athena::Validator::Constraints::ISSN--groups","text":"Type: Array(String) | String | Nil Default: nil The validation groups this constraint belongs to. AVD::Constraint::DEFAULT_GROUP is assumed if nil .","title":"groups"},{"location":"Validator/Constraints/ISSN/#Athena::Validator::Constraints::ISSN--payload","text":"Type: Hash(String, String)? Default: nil Any arbitrary domain-specific data that should be stored with this constraint. The payload is not used by Athena::Validator , but its processing is completely up to you.","title":"payload"},{"location":"Validator/Constraints/ISSN/#constants","text":"","title":"Constants"},{"location":"Validator/Constraints/ISSN/#Athena::Validator::Constraints::ISSN::CHECKSUM_FAILED_ERROR","text":"","title":"CHECKSUM_FAILED_ERROR"},{"location":"Validator/Constraints/ISSN/#Athena::Validator::Constraints::ISSN::INVALID_CASE_ERROR","text":"","title":"INVALID_CASE_ERROR"},{"location":"Validator/Constraints/ISSN/#Athena::Validator::Constraints::ISSN::INVALID_CHARACTERS_ERROR","text":"","title":"INVALID_CHARACTERS_ERROR"},{"location":"Validator/Constraints/ISSN/#Athena::Validator::Constraints::ISSN::MISSING_HYPHEN_ERROR","text":"","title":"MISSING_HYPHEN_ERROR"},{"location":"Validator/Constraints/ISSN/#Athena::Validator::Constraints::ISSN::TOO_LONG_ERROR","text":"","title":"TOO_LONG_ERROR"},{"location":"Validator/Constraints/ISSN/#Athena::Validator::Constraints::ISSN::TOO_SHORT_ERROR","text":"","title":"TOO_SHORT_ERROR"},{"location":"Validator/Constraints/ISSN/#class-methods","text":"","title":"Class methods"},{"location":"Validator/Constraints/ISSN/#Athena::Validator::Constraints::ISSN.new(case_sensitive,require_hypen,message,groups,payload)","text":"","title":".new"},{"location":"Validator/Constraints/ISSN/#methods","text":"","title":"Methods"},{"location":"Validator/Constraints/ISSN/#Athena::Validator::Constraints::ISSN#case_sensitive?()","text":"","title":"#case_sensitive?"},{"location":"Validator/Constraints/ISSN/#Athena::Validator::Constraints::ISSN#require_hypen?()","text":"","title":"#require_hypen?"},{"location":"Validator/Constraints/ISSN/#Athena::Validator::Constraints::ISSN#validated_by()","text":"Returns the AVD::ConstraintValidator.class that should handle validating self .","title":"#validated_by"},{"location":"Validator/Constraints/ISSN/Validator/","text":"struct Athena::Validator::Constraints::ISSN::Validator inherits Athena::Validator::ConstraintValidator Methods #validate ( value : _ , constraint : AVD::Constraints::ISSN ) : Nil :inherit:","title":"Validator"},{"location":"Validator/Constraints/ISSN/Validator/#Athena::Validator::Constraints::ISSN::Validator","text":"","title":"Validator"},{"location":"Validator/Constraints/ISSN/Validator/#methods","text":"","title":"Methods"},{"location":"Validator/Constraints/ISSN/Validator/#Athena::Validator::Constraints::ISSN::Validator#validate(value,constraint)","text":":inherit:","title":"#validate"},{"location":"Validator/Constraints/IsFalse/","text":"class Athena::Validator::Constraints::IsFalse inherits Athena::Validator::Constraint Validates that a value is false . Configuration Optional Arguments message Type: String Default: This value should be false. The message that will be shown if the value is not false . Placeholders The following placeholders can be used in this message: {{ value }} - The current (invalid) value. groups Type: Array(String) | String | Nil Default: nil The validation groups this constraint belongs to. AVD::Constraint::DEFAULT_GROUP is assumed if nil . payload Type: Hash(String, String)? Default: nil Any arbitrary domain-specific data that should be stored with this constraint. The payload is not used by Athena::Validator , but its processing is completely up to you. Constants NOT_FALSE_ERROR = \"55c076a0-dbaf-453c-90cf-b94664276dbc\" Class methods .new ( message : String = \"This value should be false.\" , groups : Array ( String ) | String | Nil = nil , payload : Hash ( String , String )? = nil ) Methods #validated_by : AVD :: ConstraintValidator . class Returns the AVD::ConstraintValidator.class that should handle validating self .","title":"IsFalse"},{"location":"Validator/Constraints/IsFalse/#Athena::Validator::Constraints::IsFalse","text":"Validates that a value is false .","title":"IsFalse"},{"location":"Validator/Constraints/IsFalse/#Athena::Validator::Constraints::IsFalse--configuration","text":"","title":"Configuration"},{"location":"Validator/Constraints/IsFalse/#Athena::Validator::Constraints::IsFalse--optional-arguments","text":"","title":"Optional Arguments"},{"location":"Validator/Constraints/IsFalse/#Athena::Validator::Constraints::IsFalse--message","text":"Type: String Default: This value should be false. The message that will be shown if the value is not false .","title":"message"},{"location":"Validator/Constraints/IsFalse/#Athena::Validator::Constraints::IsFalse--placeholders","text":"The following placeholders can be used in this message: {{ value }} - The current (invalid) value.","title":"Placeholders"},{"location":"Validator/Constraints/IsFalse/#Athena::Validator::Constraints::IsFalse--groups","text":"Type: Array(String) | String | Nil Default: nil The validation groups this constraint belongs to. AVD::Constraint::DEFAULT_GROUP is assumed if nil .","title":"groups"},{"location":"Validator/Constraints/IsFalse/#Athena::Validator::Constraints::IsFalse--payload","text":"Type: Hash(String, String)? Default: nil Any arbitrary domain-specific data that should be stored with this constraint. The payload is not used by Athena::Validator , but its processing is completely up to you.","title":"payload"},{"location":"Validator/Constraints/IsFalse/#constants","text":"","title":"Constants"},{"location":"Validator/Constraints/IsFalse/#Athena::Validator::Constraints::IsFalse::NOT_FALSE_ERROR","text":"","title":"NOT_FALSE_ERROR"},{"location":"Validator/Constraints/IsFalse/#class-methods","text":"","title":"Class methods"},{"location":"Validator/Constraints/IsFalse/#Athena::Validator::Constraints::IsFalse.new(message,groups,payload)","text":"","title":".new"},{"location":"Validator/Constraints/IsFalse/#methods","text":"","title":"Methods"},{"location":"Validator/Constraints/IsFalse/#Athena::Validator::Constraints::IsFalse#validated_by()","text":"Returns the AVD::ConstraintValidator.class that should handle validating self .","title":"#validated_by"},{"location":"Validator/Constraints/IsFalse/Validator/","text":"struct Athena::Validator::Constraints::IsFalse::Validator inherits Athena::Validator::ConstraintValidator Methods #validate ( value : _ , constraint : AVD::Constraints::IsFalse ) : Nil :inherit:","title":"Validator"},{"location":"Validator/Constraints/IsFalse/Validator/#Athena::Validator::Constraints::IsFalse::Validator","text":"","title":"Validator"},{"location":"Validator/Constraints/IsFalse/Validator/#methods","text":"","title":"Methods"},{"location":"Validator/Constraints/IsFalse/Validator/#Athena::Validator::Constraints::IsFalse::Validator#validate(value,constraint)","text":":inherit:","title":"#validate"},{"location":"Validator/Constraints/IsNil/","text":"class Athena::Validator::Constraints::IsNil inherits Athena::Validator::Constraint Validates that a value is nil . Configuration Optional Arguments message Type: String Default: This value should be null. The message that will be shown if the value is not nil . Placeholders The following placeholders can be used in this message: {{ value }} - The current (invalid) value. groups Type: Array(String) | String | Nil Default: nil The validation groups this constraint belongs to. AVD::Constraint::DEFAULT_GROUP is assumed if nil . payload Type: Hash(String, String)? Default: nil Any arbitrary domain-specific data that should be stored with this constraint. The payload is not used by Athena::Validator , but its processing is completely up to you. Constants NOT_NIL_ERROR = \"2c88e3c7-9275-4b9b-81b4-48c6c44b1804\" Class methods .new ( message : String = \"This value should be null.\" , groups : Array ( String ) | String | Nil = nil , payload : Hash ( String , String )? = nil ) Methods #validated_by : AVD :: ConstraintValidator . class Returns the AVD::ConstraintValidator.class that should handle validating self .","title":"IsNil"},{"location":"Validator/Constraints/IsNil/#Athena::Validator::Constraints::IsNil","text":"Validates that a value is nil .","title":"IsNil"},{"location":"Validator/Constraints/IsNil/#Athena::Validator::Constraints::IsNil--configuration","text":"","title":"Configuration"},{"location":"Validator/Constraints/IsNil/#Athena::Validator::Constraints::IsNil--optional-arguments","text":"","title":"Optional Arguments"},{"location":"Validator/Constraints/IsNil/#Athena::Validator::Constraints::IsNil--message","text":"Type: String Default: This value should be null. The message that will be shown if the value is not nil .","title":"message"},{"location":"Validator/Constraints/IsNil/#Athena::Validator::Constraints::IsNil--placeholders","text":"The following placeholders can be used in this message: {{ value }} - The current (invalid) value.","title":"Placeholders"},{"location":"Validator/Constraints/IsNil/#Athena::Validator::Constraints::IsNil--groups","text":"Type: Array(String) | String | Nil Default: nil The validation groups this constraint belongs to. AVD::Constraint::DEFAULT_GROUP is assumed if nil .","title":"groups"},{"location":"Validator/Constraints/IsNil/#Athena::Validator::Constraints::IsNil--payload","text":"Type: Hash(String, String)? Default: nil Any arbitrary domain-specific data that should be stored with this constraint. The payload is not used by Athena::Validator , but its processing is completely up to you.","title":"payload"},{"location":"Validator/Constraints/IsNil/#constants","text":"","title":"Constants"},{"location":"Validator/Constraints/IsNil/#Athena::Validator::Constraints::IsNil::NOT_NIL_ERROR","text":"","title":"NOT_NIL_ERROR"},{"location":"Validator/Constraints/IsNil/#class-methods","text":"","title":"Class methods"},{"location":"Validator/Constraints/IsNil/#Athena::Validator::Constraints::IsNil.new(message,groups,payload)","text":"","title":".new"},{"location":"Validator/Constraints/IsNil/#methods","text":"","title":"Methods"},{"location":"Validator/Constraints/IsNil/#Athena::Validator::Constraints::IsNil#validated_by()","text":"Returns the AVD::ConstraintValidator.class that should handle validating self .","title":"#validated_by"},{"location":"Validator/Constraints/IsNil/Validator/","text":"struct Athena::Validator::Constraints::IsNil::Validator inherits Athena::Validator::ConstraintValidator Methods #validate ( value : _ , constraint : AVD::Constraints::IsNil ) : Nil :inherit:","title":"Validator"},{"location":"Validator/Constraints/IsNil/Validator/#Athena::Validator::Constraints::IsNil::Validator","text":"","title":"Validator"},{"location":"Validator/Constraints/IsNil/Validator/#methods","text":"","title":"Methods"},{"location":"Validator/Constraints/IsNil/Validator/#Athena::Validator::Constraints::IsNil::Validator#validate(value,constraint)","text":":inherit:","title":"#validate"},{"location":"Validator/Constraints/IsTrue/","text":"class Athena::Validator::Constraints::IsTrue inherits Athena::Validator::Constraint Validates that a value is true . Configuration Optional Arguments message Type: String Default: This value should be true. The message that will be shown if the value is not true . Placeholders The following placeholders can be used in this message: {{ value }} - The current (invalid) value. groups Type: Array(String) | String | Nil Default: nil The validation groups this constraint belongs to. AVD::Constraint::DEFAULT_GROUP is assumed if nil . payload Type: Hash(String, String)? Default: nil Any arbitrary domain-specific data that should be stored with this constraint. The payload is not used by Athena::Validator , but its processing is completely up to you. Constants NOT_TRUE_ERROR = \"beabd93e-3673-4dfc-8796-01bd1504dd19\" Class methods .new ( message : String = \"This value should be true.\" , groups : Array ( String ) | String | Nil = nil , payload : Hash ( String , String )? = nil ) Methods #validated_by : AVD :: ConstraintValidator . class Returns the AVD::ConstraintValidator.class that should handle validating self .","title":"IsTrue"},{"location":"Validator/Constraints/IsTrue/#Athena::Validator::Constraints::IsTrue","text":"Validates that a value is true .","title":"IsTrue"},{"location":"Validator/Constraints/IsTrue/#Athena::Validator::Constraints::IsTrue--configuration","text":"","title":"Configuration"},{"location":"Validator/Constraints/IsTrue/#Athena::Validator::Constraints::IsTrue--optional-arguments","text":"","title":"Optional Arguments"},{"location":"Validator/Constraints/IsTrue/#Athena::Validator::Constraints::IsTrue--message","text":"Type: String Default: This value should be true. The message that will be shown if the value is not true .","title":"message"},{"location":"Validator/Constraints/IsTrue/#Athena::Validator::Constraints::IsTrue--placeholders","text":"The following placeholders can be used in this message: {{ value }} - The current (invalid) value.","title":"Placeholders"},{"location":"Validator/Constraints/IsTrue/#Athena::Validator::Constraints::IsTrue--groups","text":"Type: Array(String) | String | Nil Default: nil The validation groups this constraint belongs to. AVD::Constraint::DEFAULT_GROUP is assumed if nil .","title":"groups"},{"location":"Validator/Constraints/IsTrue/#Athena::Validator::Constraints::IsTrue--payload","text":"Type: Hash(String, String)? Default: nil Any arbitrary domain-specific data that should be stored with this constraint. The payload is not used by Athena::Validator , but its processing is completely up to you.","title":"payload"},{"location":"Validator/Constraints/IsTrue/#constants","text":"","title":"Constants"},{"location":"Validator/Constraints/IsTrue/#Athena::Validator::Constraints::IsTrue::NOT_TRUE_ERROR","text":"","title":"NOT_TRUE_ERROR"},{"location":"Validator/Constraints/IsTrue/#class-methods","text":"","title":"Class methods"},{"location":"Validator/Constraints/IsTrue/#Athena::Validator::Constraints::IsTrue.new(message,groups,payload)","text":"","title":".new"},{"location":"Validator/Constraints/IsTrue/#methods","text":"","title":"Methods"},{"location":"Validator/Constraints/IsTrue/#Athena::Validator::Constraints::IsTrue#validated_by()","text":"Returns the AVD::ConstraintValidator.class that should handle validating self .","title":"#validated_by"},{"location":"Validator/Constraints/IsTrue/Validator/","text":"struct Athena::Validator::Constraints::IsTrue::Validator inherits Athena::Validator::ConstraintValidator Methods #validate ( value : _ , constraint : AVD::Constraints::IsTrue ) : Nil :inherit:","title":"Validator"},{"location":"Validator/Constraints/IsTrue/Validator/#Athena::Validator::Constraints::IsTrue::Validator","text":"","title":"Validator"},{"location":"Validator/Constraints/IsTrue/Validator/#methods","text":"","title":"Methods"},{"location":"Validator/Constraints/IsTrue/Validator/#Athena::Validator::Constraints::IsTrue::Validator#validate(value,constraint)","text":":inherit:","title":"#validate"},{"location":"Validator/Constraints/LessThan/","text":"class Athena::Validator::Constraints::LessThan(ValueType) inherits Athena::Validator::Constraint Validates that a value is less than another. Configuration Required Arguments value Type: Number | String | Time Defines the value that the value being validated should be compared to. Optional Arguments message Type: String Default: This value should be less than {{ compared_value }}. The message that will be shown if the value is not less than the comparison value. Placeholders The following placeholders can be used in this message: {{ value }} - The current (invalid) value. {{ compared_value }} - The expected value. {{ compared_value_type }} - The type of the expected value. groups Type: Array(String) | String | Nil Default: nil The validation groups this constraint belongs to. AVD::Constraint::DEFAULT_GROUP is assumed if nil . payload Type: Hash(String, String)? Default: nil Any arbitrary domain-specific data that should be stored with this constraint. The payload is not used by Athena::Validator , but its processing is completely up to you. Included modules Athena::Validator::Constraints::AbstractComparison Direct known subclasses Athena::Validator::Constraints::Negative Constants TOO_HIGH_ERROR = \"d9fbedb3-c576-45b5-b4dc-996030349bbf\" Class methods .new ( value : ValueType , message : String = default_error_message , groups : Array ( String ) | String | Nil = nil , payload : Hash ( String , String )? = nil ) Methods #default_error_message : String Returns the AVD::Constraint#message for this constraint. #validated_by : AVD :: ConstraintValidator . class Returns the AVD::ConstraintValidator.class that should handle validating self .","title":"LessThan"},{"location":"Validator/Constraints/LessThan/#Athena::Validator::Constraints::LessThan","text":"Validates that a value is less than another.","title":"LessThan"},{"location":"Validator/Constraints/LessThan/#Athena::Validator::Constraints::LessThan--configuration","text":"","title":"Configuration"},{"location":"Validator/Constraints/LessThan/#Athena::Validator::Constraints::LessThan--required-arguments","text":"","title":"Required Arguments"},{"location":"Validator/Constraints/LessThan/#Athena::Validator::Constraints::LessThan--value","text":"Type: Number | String | Time Defines the value that the value being validated should be compared to.","title":"value"},{"location":"Validator/Constraints/LessThan/#Athena::Validator::Constraints::LessThan--optional-arguments","text":"","title":"Optional Arguments"},{"location":"Validator/Constraints/LessThan/#Athena::Validator::Constraints::LessThan--message","text":"Type: String Default: This value should be less than {{ compared_value }}. The message that will be shown if the value is not less than the comparison value.","title":"message"},{"location":"Validator/Constraints/LessThan/#Athena::Validator::Constraints::LessThan--placeholders","text":"The following placeholders can be used in this message: {{ value }} - The current (invalid) value. {{ compared_value }} - The expected value. {{ compared_value_type }} - The type of the expected value.","title":"Placeholders"},{"location":"Validator/Constraints/LessThan/#Athena::Validator::Constraints::LessThan--groups","text":"Type: Array(String) | String | Nil Default: nil The validation groups this constraint belongs to. AVD::Constraint::DEFAULT_GROUP is assumed if nil .","title":"groups"},{"location":"Validator/Constraints/LessThan/#Athena::Validator::Constraints::LessThan--payload","text":"Type: Hash(String, String)? Default: nil Any arbitrary domain-specific data that should be stored with this constraint. The payload is not used by Athena::Validator , but its processing is completely up to you.","title":"payload"},{"location":"Validator/Constraints/LessThan/#included-modules","text":"Athena::Validator::Constraints::AbstractComparison","title":"Included modules"},{"location":"Validator/Constraints/LessThan/#direct-known-subclasses","text":"Athena::Validator::Constraints::Negative","title":"Direct known subclasses"},{"location":"Validator/Constraints/LessThan/#constants","text":"","title":"Constants"},{"location":"Validator/Constraints/LessThan/#Athena::Validator::Constraints::LessThan::TOO_HIGH_ERROR","text":"","title":"TOO_HIGH_ERROR"},{"location":"Validator/Constraints/LessThan/#class-methods","text":"","title":"Class methods"},{"location":"Validator/Constraints/LessThan/#Athena::Validator::Constraints::LessThan.new(value,message,groups,payload)","text":"","title":".new"},{"location":"Validator/Constraints/LessThan/#methods","text":"","title":"Methods"},{"location":"Validator/Constraints/LessThan/#Athena::Validator::Constraints::LessThan#default_error_message()","text":"Returns the AVD::Constraint#message for this constraint.","title":"#default_error_message"},{"location":"Validator/Constraints/LessThan/#Athena::Validator::Constraints::LessThan#validated_by()","text":"Returns the AVD::ConstraintValidator.class that should handle validating self .","title":"#validated_by"},{"location":"Validator/Constraints/LessThan/Validator/","text":"struct Athena::Validator::Constraints::LessThan::Validator inherits Athena::Validator::Constraints::ComparisonValidator Methods #compare_values ( actual : Number , expected : Number ) : Bool #compare_values ( actual : String , expected : String ) : Bool #compare_values ( actual : Time , expected : Time ) : Bool #compare_values ( actual : _ , expected : _ ) : NoReturn Returns true if the provided actual and expected values are compatible, otherwise false . #error_code : String Returns the expected error code for self .","title":"Validator"},{"location":"Validator/Constraints/LessThan/Validator/#Athena::Validator::Constraints::LessThan::Validator","text":"","title":"Validator"},{"location":"Validator/Constraints/LessThan/Validator/#methods","text":"","title":"Methods"},{"location":"Validator/Constraints/LessThan/Validator/#Athena::Validator::Constraints::LessThan::Validator#compare_values(actual,expected)","text":"","title":"#compare_values"},{"location":"Validator/Constraints/LessThan/Validator/#Athena::Validator::Constraints::LessThan::Validator#compare_values(actual,expected)","text":"","title":"#compare_values"},{"location":"Validator/Constraints/LessThan/Validator/#Athena::Validator::Constraints::LessThan::Validator#compare_values(actual,expected)","text":"","title":"#compare_values"},{"location":"Validator/Constraints/LessThan/Validator/#Athena::Validator::Constraints::LessThan::Validator#compare_values(actual,expected)","text":"Returns true if the provided actual and expected values are compatible, otherwise false .","title":"#compare_values"},{"location":"Validator/Constraints/LessThan/Validator/#Athena::Validator::Constraints::LessThan::Validator#error_code()","text":"Returns the expected error code for self .","title":"#error_code"},{"location":"Validator/Constraints/LessThanOrEqual/","text":"class Athena::Validator::Constraints::LessThanOrEqual(ValueType) inherits Athena::Validator::Constraint Validates that a value is less than or equal to another. Configuration Required Arguments value Type: Number | String | Time Defines the value that the value being validated should be compared to. Optional Arguments message Type: String Default: This value should be less than or equal to {{ compared_value }}. The message that will be shown if the value is not less than or equal to the comparison value. Placeholders The following placeholders can be used in this message: {{ value }} - The current (invalid) value. {{ compared_value }} - The expected value. {{ compared_value_type }} - The type of the expected value. groups Type: Array(String) | String | Nil Default: nil The validation groups this constraint belongs to. AVD::Constraint::DEFAULT_GROUP is assumed if nil . payload Type: Hash(String, String)? Default: nil Any arbitrary domain-specific data that should be stored with this constraint. The payload is not used by Athena::Validator , but its processing is completely up to you. Included modules Athena::Validator::Constraints::AbstractComparison Direct known subclasses Athena::Validator::Constraints::NegativeOrZero Constants TOO_HIGH_ERROR = \"515a12ff-82f2-4434-9635-137164d5b467\" Class methods .new ( value : ValueType , message : String = default_error_message , groups : Array ( String ) | String | Nil = nil , payload : Hash ( String , String )? = nil ) Methods #default_error_message : String Returns the AVD::Constraint#message for this constraint. #validated_by : AVD :: ConstraintValidator . class Returns the AVD::ConstraintValidator.class that should handle validating self .","title":"LessThanOrEqual"},{"location":"Validator/Constraints/LessThanOrEqual/#Athena::Validator::Constraints::LessThanOrEqual","text":"Validates that a value is less than or equal to another.","title":"LessThanOrEqual"},{"location":"Validator/Constraints/LessThanOrEqual/#Athena::Validator::Constraints::LessThanOrEqual--configuration","text":"","title":"Configuration"},{"location":"Validator/Constraints/LessThanOrEqual/#Athena::Validator::Constraints::LessThanOrEqual--required-arguments","text":"","title":"Required Arguments"},{"location":"Validator/Constraints/LessThanOrEqual/#Athena::Validator::Constraints::LessThanOrEqual--value","text":"Type: Number | String | Time Defines the value that the value being validated should be compared to.","title":"value"},{"location":"Validator/Constraints/LessThanOrEqual/#Athena::Validator::Constraints::LessThanOrEqual--optional-arguments","text":"","title":"Optional Arguments"},{"location":"Validator/Constraints/LessThanOrEqual/#Athena::Validator::Constraints::LessThanOrEqual--message","text":"Type: String Default: This value should be less than or equal to {{ compared_value }}. The message that will be shown if the value is not less than or equal to the comparison value.","title":"message"},{"location":"Validator/Constraints/LessThanOrEqual/#Athena::Validator::Constraints::LessThanOrEqual--placeholders","text":"The following placeholders can be used in this message: {{ value }} - The current (invalid) value. {{ compared_value }} - The expected value. {{ compared_value_type }} - The type of the expected value.","title":"Placeholders"},{"location":"Validator/Constraints/LessThanOrEqual/#Athena::Validator::Constraints::LessThanOrEqual--groups","text":"Type: Array(String) | String | Nil Default: nil The validation groups this constraint belongs to. AVD::Constraint::DEFAULT_GROUP is assumed if nil .","title":"groups"},{"location":"Validator/Constraints/LessThanOrEqual/#Athena::Validator::Constraints::LessThanOrEqual--payload","text":"Type: Hash(String, String)? Default: nil Any arbitrary domain-specific data that should be stored with this constraint. The payload is not used by Athena::Validator , but its processing is completely up to you.","title":"payload"},{"location":"Validator/Constraints/LessThanOrEqual/#included-modules","text":"Athena::Validator::Constraints::AbstractComparison","title":"Included modules"},{"location":"Validator/Constraints/LessThanOrEqual/#direct-known-subclasses","text":"Athena::Validator::Constraints::NegativeOrZero","title":"Direct known subclasses"},{"location":"Validator/Constraints/LessThanOrEqual/#constants","text":"","title":"Constants"},{"location":"Validator/Constraints/LessThanOrEqual/#Athena::Validator::Constraints::LessThanOrEqual::TOO_HIGH_ERROR","text":"","title":"TOO_HIGH_ERROR"},{"location":"Validator/Constraints/LessThanOrEqual/#class-methods","text":"","title":"Class methods"},{"location":"Validator/Constraints/LessThanOrEqual/#Athena::Validator::Constraints::LessThanOrEqual.new(value,message,groups,payload)","text":"","title":".new"},{"location":"Validator/Constraints/LessThanOrEqual/#methods","text":"","title":"Methods"},{"location":"Validator/Constraints/LessThanOrEqual/#Athena::Validator::Constraints::LessThanOrEqual#default_error_message()","text":"Returns the AVD::Constraint#message for this constraint.","title":"#default_error_message"},{"location":"Validator/Constraints/LessThanOrEqual/#Athena::Validator::Constraints::LessThanOrEqual#validated_by()","text":"Returns the AVD::ConstraintValidator.class that should handle validating self .","title":"#validated_by"},{"location":"Validator/Constraints/LessThanOrEqual/Validator/","text":"struct Athena::Validator::Constraints::LessThanOrEqual::Validator inherits Athena::Validator::Constraints::ComparisonValidator Methods #compare_values ( actual : Number , expected : Number ) : Bool #compare_values ( actual : String , expected : String ) : Bool #compare_values ( actual : Time , expected : Time ) : Bool #compare_values ( actual : _ , expected : _ ) : NoReturn Returns true if the provided actual and expected values are compatible, otherwise false . #error_code : String Returns the expected error code for self .","title":"Validator"},{"location":"Validator/Constraints/LessThanOrEqual/Validator/#Athena::Validator::Constraints::LessThanOrEqual::Validator","text":"","title":"Validator"},{"location":"Validator/Constraints/LessThanOrEqual/Validator/#methods","text":"","title":"Methods"},{"location":"Validator/Constraints/LessThanOrEqual/Validator/#Athena::Validator::Constraints::LessThanOrEqual::Validator#compare_values(actual,expected)","text":"","title":"#compare_values"},{"location":"Validator/Constraints/LessThanOrEqual/Validator/#Athena::Validator::Constraints::LessThanOrEqual::Validator#compare_values(actual,expected)","text":"","title":"#compare_values"},{"location":"Validator/Constraints/LessThanOrEqual/Validator/#Athena::Validator::Constraints::LessThanOrEqual::Validator#compare_values(actual,expected)","text":"","title":"#compare_values"},{"location":"Validator/Constraints/LessThanOrEqual/Validator/#Athena::Validator::Constraints::LessThanOrEqual::Validator#compare_values(actual,expected)","text":"Returns true if the provided actual and expected values are compatible, otherwise false .","title":"#compare_values"},{"location":"Validator/Constraints/LessThanOrEqual/Validator/#Athena::Validator::Constraints::LessThanOrEqual::Validator#error_code()","text":"Returns the expected error code for self .","title":"#error_code"},{"location":"Validator/Constraints/Luhn/","text":"class Athena::Validator::Constraints::Luhn inherits Athena::Validator::Constraint Validates that a credit card number passes the Luhn algorithm ; a useful first step to validating a credit card. The underlying value is converted to a string via #to_s before being validated. NOTE: As with most other constraints, nil and empty strings are considered valid values, in order to allow the value to be optional. If the value is required, consider combining this constraint with AVD::Constraints::NotBlank . Configuration Optional Arguments message Type: String Default: This value is not a valid credit card number. The message that will be shown if the value is not pass the Luhn check. Placeholders The following placeholders can be used in this message: {{ value }} - The current (invalid) value. groups Type: Array(String) | String | Nil Default: nil The validation groups this constraint belongs to. AVD::Constraint::DEFAULT_GROUP is assumed if nil . payload Type: Hash(String, String)? Default: nil Any arbitrary domain-specific data that should be stored with this constraint. The payload is not used by Athena::Validator , but its processing is completely up to you. Constants CHECKSUM_FAILED_ERROR = \"a4f089dd-fd63-4d50-ac30-34ed2a8dc9dd\" INVALID_CHARACTERS_ERROR = \"c42b8d36-d9e9-4f5f-aad6-5190e27a1102\" Class methods .new ( message : String = \"This value is not a valid credit card number.\" , groups : Array ( String ) | String | Nil = nil , payload : Hash ( String , String )? = nil ) Methods #validated_by : AVD :: ConstraintValidator . class Returns the AVD::ConstraintValidator.class that should handle validating self .","title":"Luhn"},{"location":"Validator/Constraints/Luhn/#Athena::Validator::Constraints::Luhn","text":"Validates that a credit card number passes the Luhn algorithm ; a useful first step to validating a credit card. The underlying value is converted to a string via #to_s before being validated. NOTE: As with most other constraints, nil and empty strings are considered valid values, in order to allow the value to be optional. If the value is required, consider combining this constraint with AVD::Constraints::NotBlank .","title":"Luhn"},{"location":"Validator/Constraints/Luhn/#Athena::Validator::Constraints::Luhn--configuration","text":"","title":"Configuration"},{"location":"Validator/Constraints/Luhn/#Athena::Validator::Constraints::Luhn--optional-arguments","text":"","title":"Optional Arguments"},{"location":"Validator/Constraints/Luhn/#Athena::Validator::Constraints::Luhn--message","text":"Type: String Default: This value is not a valid credit card number. The message that will be shown if the value is not pass the Luhn check.","title":"message"},{"location":"Validator/Constraints/Luhn/#Athena::Validator::Constraints::Luhn--placeholders","text":"The following placeholders can be used in this message: {{ value }} - The current (invalid) value.","title":"Placeholders"},{"location":"Validator/Constraints/Luhn/#Athena::Validator::Constraints::Luhn--groups","text":"Type: Array(String) | String | Nil Default: nil The validation groups this constraint belongs to. AVD::Constraint::DEFAULT_GROUP is assumed if nil .","title":"groups"},{"location":"Validator/Constraints/Luhn/#Athena::Validator::Constraints::Luhn--payload","text":"Type: Hash(String, String)? Default: nil Any arbitrary domain-specific data that should be stored with this constraint. The payload is not used by Athena::Validator , but its processing is completely up to you.","title":"payload"},{"location":"Validator/Constraints/Luhn/#constants","text":"","title":"Constants"},{"location":"Validator/Constraints/Luhn/#Athena::Validator::Constraints::Luhn::CHECKSUM_FAILED_ERROR","text":"","title":"CHECKSUM_FAILED_ERROR"},{"location":"Validator/Constraints/Luhn/#Athena::Validator::Constraints::Luhn::INVALID_CHARACTERS_ERROR","text":"","title":"INVALID_CHARACTERS_ERROR"},{"location":"Validator/Constraints/Luhn/#class-methods","text":"","title":"Class methods"},{"location":"Validator/Constraints/Luhn/#Athena::Validator::Constraints::Luhn.new(message,groups,payload)","text":"","title":".new"},{"location":"Validator/Constraints/Luhn/#methods","text":"","title":"Methods"},{"location":"Validator/Constraints/Luhn/#Athena::Validator::Constraints::Luhn#validated_by()","text":"Returns the AVD::ConstraintValidator.class that should handle validating self .","title":"#validated_by"},{"location":"Validator/Constraints/Luhn/Validator/","text":"struct Athena::Validator::Constraints::Luhn::Validator inherits Athena::Validator::ConstraintValidator Methods #validate ( value : _ , constraint : AVD::Constraints::Luhn ) : Nil :inherit:","title":"Validator"},{"location":"Validator/Constraints/Luhn/Validator/#Athena::Validator::Constraints::Luhn::Validator","text":"","title":"Validator"},{"location":"Validator/Constraints/Luhn/Validator/#methods","text":"","title":"Methods"},{"location":"Validator/Constraints/Luhn/Validator/#Athena::Validator::Constraints::Luhn::Validator#validate(value,constraint)","text":":inherit:","title":"#validate"},{"location":"Validator/Constraints/Negative/","text":"class Athena::Validator::Constraints::Negative inherits Athena::Validator::Constraints::LessThan Validates that a value is a negative number. Use AVD::Constraints::NegativeOrZero if you wish to also allow 0 . Configuration Optional Arguments message Type: String Default: This value should be negative. The message that will be shown if the value is not less than 0 . Placeholders The following placeholders can be used in this message: {{ value }} - The current (invalid) value. {{ compared_value }} - The expected value. {{ compared_value_type }} - The type of the expected value. groups Type: Array(String) | String | Nil Default: nil The validation groups this constraint belongs to. AVD::Constraint::DEFAULT_GROUP is assumed if nil . payload Type: Hash(String, String)? Default: nil Any arbitrary domain-specific data that should be stored with this constraint. The payload is not used by Athena::Validator , but its processing is completely up to you. Class methods .new ( message : String = \"This value should be negative.\" , groups : Array ( String ) | String | Nil = nil , payload : Hash ( String , String )? = nil ) Methods #validated_by : AVD :: ConstraintValidator . class :inherit:","title":"Negative"},{"location":"Validator/Constraints/Negative/#Athena::Validator::Constraints::Negative","text":"Validates that a value is a negative number. Use AVD::Constraints::NegativeOrZero if you wish to also allow 0 .","title":"Negative"},{"location":"Validator/Constraints/Negative/#Athena::Validator::Constraints::Negative--configuration","text":"","title":"Configuration"},{"location":"Validator/Constraints/Negative/#Athena::Validator::Constraints::Negative--optional-arguments","text":"","title":"Optional Arguments"},{"location":"Validator/Constraints/Negative/#Athena::Validator::Constraints::Negative--message","text":"Type: String Default: This value should be negative. The message that will be shown if the value is not less than 0 .","title":"message"},{"location":"Validator/Constraints/Negative/#Athena::Validator::Constraints::Negative--placeholders","text":"The following placeholders can be used in this message: {{ value }} - The current (invalid) value. {{ compared_value }} - The expected value. {{ compared_value_type }} - The type of the expected value.","title":"Placeholders"},{"location":"Validator/Constraints/Negative/#Athena::Validator::Constraints::Negative--groups","text":"Type: Array(String) | String | Nil Default: nil The validation groups this constraint belongs to. AVD::Constraint::DEFAULT_GROUP is assumed if nil .","title":"groups"},{"location":"Validator/Constraints/Negative/#Athena::Validator::Constraints::Negative--payload","text":"Type: Hash(String, String)? Default: nil Any arbitrary domain-specific data that should be stored with this constraint. The payload is not used by Athena::Validator , but its processing is completely up to you.","title":"payload"},{"location":"Validator/Constraints/Negative/#class-methods","text":"","title":"Class methods"},{"location":"Validator/Constraints/Negative/#Athena::Validator::Constraints::Negative.new(message,groups,payload)","text":"","title":".new"},{"location":"Validator/Constraints/Negative/#methods","text":"","title":"Methods"},{"location":"Validator/Constraints/Negative/#Athena::Validator::Constraints::Negative#validated_by()","text":":inherit:","title":"#validated_by"},{"location":"Validator/Constraints/NegativeOrZero/","text":"class Athena::Validator::Constraints::NegativeOrZero inherits Athena::Validator::Constraints::LessThanOrEqual Validates that a value is a negative number, or 0 . Use AVD::Constraints::Negative if you don't want to allow 0 . Configuration Optional Arguments message Type: String Default: This value should be negative or zero. The message that will be shown if the value is not less than or equal to 0 . Placeholders The following placeholders can be used in this message: {{ value }} - The current (invalid) value. {{ compared_value }} - The expected value. {{ compared_value_type }} - The type of the expected value. groups Type: Array(String) | String | Nil Default: nil The validation groups this constraint belongs to. AVD::Constraint::DEFAULT_GROUP is assumed if nil . payload Type: Hash(String, String)? Default: nil Any arbitrary domain-specific data that should be stored with this constraint. The AVD::Constraint@payload is not used by Athena::Validator , but its processing is completely up to you Class methods .new ( message : String = \"This value should be negative or zero.\" , groups : Array ( String ) | String | Nil = nil , payload : Hash ( String , String )? = nil ) Methods #validated_by : AVD :: ConstraintValidator . class :inherit:","title":"NegativeOrZero"},{"location":"Validator/Constraints/NegativeOrZero/#Athena::Validator::Constraints::NegativeOrZero","text":"Validates that a value is a negative number, or 0 . Use AVD::Constraints::Negative if you don't want to allow 0 .","title":"NegativeOrZero"},{"location":"Validator/Constraints/NegativeOrZero/#Athena::Validator::Constraints::NegativeOrZero--configuration","text":"","title":"Configuration"},{"location":"Validator/Constraints/NegativeOrZero/#Athena::Validator::Constraints::NegativeOrZero--optional-arguments","text":"","title":"Optional Arguments"},{"location":"Validator/Constraints/NegativeOrZero/#Athena::Validator::Constraints::NegativeOrZero--message","text":"Type: String Default: This value should be negative or zero. The message that will be shown if the value is not less than or equal to 0 .","title":"message"},{"location":"Validator/Constraints/NegativeOrZero/#Athena::Validator::Constraints::NegativeOrZero--placeholders","text":"The following placeholders can be used in this message: {{ value }} - The current (invalid) value. {{ compared_value }} - The expected value. {{ compared_value_type }} - The type of the expected value.","title":"Placeholders"},{"location":"Validator/Constraints/NegativeOrZero/#Athena::Validator::Constraints::NegativeOrZero--groups","text":"Type: Array(String) | String | Nil Default: nil The validation groups this constraint belongs to. AVD::Constraint::DEFAULT_GROUP is assumed if nil .","title":"groups"},{"location":"Validator/Constraints/NegativeOrZero/#Athena::Validator::Constraints::NegativeOrZero--payload","text":"Type: Hash(String, String)? Default: nil Any arbitrary domain-specific data that should be stored with this constraint. The AVD::Constraint@payload is not used by Athena::Validator , but its processing is completely up to you","title":"payload"},{"location":"Validator/Constraints/NegativeOrZero/#class-methods","text":"","title":"Class methods"},{"location":"Validator/Constraints/NegativeOrZero/#Athena::Validator::Constraints::NegativeOrZero.new(message,groups,payload)","text":"","title":".new"},{"location":"Validator/Constraints/NegativeOrZero/#methods","text":"","title":"Methods"},{"location":"Validator/Constraints/NegativeOrZero/#Athena::Validator::Constraints::NegativeOrZero#validated_by()","text":":inherit:","title":"#validated_by"},{"location":"Validator/Constraints/NotBlank/","text":"class Athena::Validator::Constraints::NotBlank inherits Athena::Validator::Constraint Validates that a value is not blank; meaning not equal to a blank string, an empty Iterable , false , or optionally nil . Configuration Optional Arguments allow_nil Type: Bool Default: false If set to true , nil values are considered valid and will not trigger a violation. message Type: String Default: This value should not be blank. The message that will be shown if the value is blank. Placeholders The following placeholders can be used in this message: {{ value }} - The current (invalid) value. groups Type: Array(String) | String | Nil Default: nil The validation groups this constraint belongs to. AVD::Constraint::DEFAULT_GROUP is assumed if nil . payload Type: Hash(String, String)? Default: nil Any arbitrary domain-specific data that should be stored with this constraint. The payload is not used by Athena::Validator , but its processing is completely up to you. Constants IS_BLANK_ERROR = \"0d0c3254-3642-4cb0-9882-46ee5918e6e3\" Class methods .new ( allow_nil : Bool = false , message : String = \"This value should not be blank.\" , groups : Array ( String ) | String | Nil = nil , payload : Hash ( String , String )? = nil ) Methods #allow_nil? : Bool #validated_by : AVD :: ConstraintValidator . class Returns the AVD::ConstraintValidator.class that should handle validating self .","title":"NotBlank"},{"location":"Validator/Constraints/NotBlank/#Athena::Validator::Constraints::NotBlank","text":"Validates that a value is not blank; meaning not equal to a blank string, an empty Iterable , false , or optionally nil .","title":"NotBlank"},{"location":"Validator/Constraints/NotBlank/#Athena::Validator::Constraints::NotBlank--configuration","text":"","title":"Configuration"},{"location":"Validator/Constraints/NotBlank/#Athena::Validator::Constraints::NotBlank--optional-arguments","text":"","title":"Optional Arguments"},{"location":"Validator/Constraints/NotBlank/#Athena::Validator::Constraints::NotBlank--allow_nil","text":"Type: Bool Default: false If set to true , nil values are considered valid and will not trigger a violation.","title":"allow_nil"},{"location":"Validator/Constraints/NotBlank/#Athena::Validator::Constraints::NotBlank--message","text":"Type: String Default: This value should not be blank. The message that will be shown if the value is blank.","title":"message"},{"location":"Validator/Constraints/NotBlank/#Athena::Validator::Constraints::NotBlank--placeholders","text":"The following placeholders can be used in this message: {{ value }} - The current (invalid) value.","title":"Placeholders"},{"location":"Validator/Constraints/NotBlank/#Athena::Validator::Constraints::NotBlank--groups","text":"Type: Array(String) | String | Nil Default: nil The validation groups this constraint belongs to. AVD::Constraint::DEFAULT_GROUP is assumed if nil .","title":"groups"},{"location":"Validator/Constraints/NotBlank/#Athena::Validator::Constraints::NotBlank--payload","text":"Type: Hash(String, String)? Default: nil Any arbitrary domain-specific data that should be stored with this constraint. The payload is not used by Athena::Validator , but its processing is completely up to you.","title":"payload"},{"location":"Validator/Constraints/NotBlank/#constants","text":"","title":"Constants"},{"location":"Validator/Constraints/NotBlank/#Athena::Validator::Constraints::NotBlank::IS_BLANK_ERROR","text":"","title":"IS_BLANK_ERROR"},{"location":"Validator/Constraints/NotBlank/#class-methods","text":"","title":"Class methods"},{"location":"Validator/Constraints/NotBlank/#Athena::Validator::Constraints::NotBlank.new(allow_nil,message,groups,payload)","text":"","title":".new"},{"location":"Validator/Constraints/NotBlank/#methods","text":"","title":"Methods"},{"location":"Validator/Constraints/NotBlank/#Athena::Validator::Constraints::NotBlank#allow_nil?()","text":"","title":"#allow_nil?"},{"location":"Validator/Constraints/NotBlank/#Athena::Validator::Constraints::NotBlank#validated_by()","text":"Returns the AVD::ConstraintValidator.class that should handle validating self .","title":"#validated_by"},{"location":"Validator/Constraints/NotBlank/Validator/","text":"struct Athena::Validator::Constraints::NotBlank::Validator inherits Athena::Validator::ConstraintValidator Methods #validate ( value : String ?, constraint : AVD::Constraints::NotBlank ) : Nil :inherit: #validate ( value : Bool ?, constraint : AVD::Constraints::NotBlank ) : Nil :inherit: #validate ( value : Iterable? , constraint : AVD::Constraints::NotBlank ) : Nil :inherit:","title":"Validator"},{"location":"Validator/Constraints/NotBlank/Validator/#Athena::Validator::Constraints::NotBlank::Validator","text":"","title":"Validator"},{"location":"Validator/Constraints/NotBlank/Validator/#methods","text":"","title":"Methods"},{"location":"Validator/Constraints/NotBlank/Validator/#Athena::Validator::Constraints::NotBlank::Validator#validate(value,constraint)","text":":inherit:","title":"#validate"},{"location":"Validator/Constraints/NotBlank/Validator/#Athena::Validator::Constraints::NotBlank::Validator#validate(value,constraint)","text":":inherit:","title":"#validate"},{"location":"Validator/Constraints/NotBlank/Validator/#Athena::Validator::Constraints::NotBlank::Validator#validate(value,constraint)","text":":inherit:","title":"#validate"},{"location":"Validator/Constraints/NotEqualTo/","text":"class Athena::Validator::Constraints::NotEqualTo(ValueType) inherits Athena::Validator::Constraint Validates that a value is not equal to another. Configuration Required Arguments value Defines the value that the value being validated should be compared to. Optional Arguments message Type: String Default: This value should not be equal to {{ compared_value }}. The message that will be shown if the value is equal to the comparison value. Placeholders The following placeholders can be used in this message: {{ value }} - The current (invalid) value. {{ compared_value }} - The expected value. {{ compared_value_type }} - The type of the expected value. groups Type: Array(String) | String | Nil Default: nil The validation groups this constraint belongs to. AVD::Constraint::DEFAULT_GROUP is assumed if nil . payload Type: Hash(String, String)? Default: nil Any arbitrary domain-specific data that should be stored with this constraint. The payload is not used by Athena::Validator , but its processing is completely up to you. Included modules Athena::Validator::Constraints::AbstractComparison Constants IS_EQUAL_ERROR = \"984a0525-d73e-40c0-81c2-2ecbca7e4c96\" Class methods .new ( value : ValueType , message : String = default_error_message , groups : Array ( String ) | String | Nil = nil , payload : Hash ( String , String )? = nil ) Methods #default_error_message : String Returns the AVD::Constraint#message for this constraint. #validated_by : AVD :: ConstraintValidator . class Returns the AVD::ConstraintValidator.class that should handle validating self .","title":"NotEqualTo"},{"location":"Validator/Constraints/NotEqualTo/#Athena::Validator::Constraints::NotEqualTo","text":"Validates that a value is not equal to another.","title":"NotEqualTo"},{"location":"Validator/Constraints/NotEqualTo/#Athena::Validator::Constraints::NotEqualTo--configuration","text":"","title":"Configuration"},{"location":"Validator/Constraints/NotEqualTo/#Athena::Validator::Constraints::NotEqualTo--required-arguments","text":"","title":"Required Arguments"},{"location":"Validator/Constraints/NotEqualTo/#Athena::Validator::Constraints::NotEqualTo--value","text":"Defines the value that the value being validated should be compared to.","title":"value"},{"location":"Validator/Constraints/NotEqualTo/#Athena::Validator::Constraints::NotEqualTo--optional-arguments","text":"","title":"Optional Arguments"},{"location":"Validator/Constraints/NotEqualTo/#Athena::Validator::Constraints::NotEqualTo--message","text":"Type: String Default: This value should not be equal to {{ compared_value }}. The message that will be shown if the value is equal to the comparison value.","title":"message"},{"location":"Validator/Constraints/NotEqualTo/#Athena::Validator::Constraints::NotEqualTo--placeholders","text":"The following placeholders can be used in this message: {{ value }} - The current (invalid) value. {{ compared_value }} - The expected value. {{ compared_value_type }} - The type of the expected value.","title":"Placeholders"},{"location":"Validator/Constraints/NotEqualTo/#Athena::Validator::Constraints::NotEqualTo--groups","text":"Type: Array(String) | String | Nil Default: nil The validation groups this constraint belongs to. AVD::Constraint::DEFAULT_GROUP is assumed if nil .","title":"groups"},{"location":"Validator/Constraints/NotEqualTo/#Athena::Validator::Constraints::NotEqualTo--payload","text":"Type: Hash(String, String)? Default: nil Any arbitrary domain-specific data that should be stored with this constraint. The payload is not used by Athena::Validator , but its processing is completely up to you.","title":"payload"},{"location":"Validator/Constraints/NotEqualTo/#included-modules","text":"Athena::Validator::Constraints::AbstractComparison","title":"Included modules"},{"location":"Validator/Constraints/NotEqualTo/#constants","text":"","title":"Constants"},{"location":"Validator/Constraints/NotEqualTo/#Athena::Validator::Constraints::NotEqualTo::IS_EQUAL_ERROR","text":"","title":"IS_EQUAL_ERROR"},{"location":"Validator/Constraints/NotEqualTo/#class-methods","text":"","title":"Class methods"},{"location":"Validator/Constraints/NotEqualTo/#Athena::Validator::Constraints::NotEqualTo.new(value,message,groups,payload)","text":"","title":".new"},{"location":"Validator/Constraints/NotEqualTo/#methods","text":"","title":"Methods"},{"location":"Validator/Constraints/NotEqualTo/#Athena::Validator::Constraints::NotEqualTo#default_error_message()","text":"Returns the AVD::Constraint#message for this constraint.","title":"#default_error_message"},{"location":"Validator/Constraints/NotEqualTo/#Athena::Validator::Constraints::NotEqualTo#validated_by()","text":"Returns the AVD::ConstraintValidator.class that should handle validating self .","title":"#validated_by"},{"location":"Validator/Constraints/NotEqualTo/Validator/","text":"struct Athena::Validator::Constraints::NotEqualTo::Validator inherits Athena::Validator::Constraints::ComparisonValidator Methods #compare_values ( actual : _ , expected : _ ) : Bool Returns true if the provided actual and expected values are compatible, otherwise false . #error_code : String Returns the expected error code for self .","title":"Validator"},{"location":"Validator/Constraints/NotEqualTo/Validator/#Athena::Validator::Constraints::NotEqualTo::Validator","text":"","title":"Validator"},{"location":"Validator/Constraints/NotEqualTo/Validator/#methods","text":"","title":"Methods"},{"location":"Validator/Constraints/NotEqualTo/Validator/#Athena::Validator::Constraints::NotEqualTo::Validator#compare_values(actual,expected)","text":"Returns true if the provided actual and expected values are compatible, otherwise false .","title":"#compare_values"},{"location":"Validator/Constraints/NotEqualTo/Validator/#Athena::Validator::Constraints::NotEqualTo::Validator#error_code()","text":"Returns the expected error code for self .","title":"#error_code"},{"location":"Validator/Constraints/NotNil/","text":"class Athena::Validator::Constraints::NotNil inherits Athena::Validator::Constraint Validates that a value is not nil . NOTE: Due to Crystal's static typing, when validating objects the property's type must be nilable, otherwise nil is inherently not allowed due to the compiler's type checking. Configuration Optional Arguments message Type: String Default: This value should not be null. The message that will be shown if the value is nil . Placeholders The following placeholders can be used in this message: {{ value }} - The current (invalid) value. groups Type: Array(String) | String | Nil Default: nil The validation groups this constraint belongs to. AVD::Constraint::DEFAULT_GROUP is assumed if nil . payload Type: Hash(String, String)? Default: nil Any arbitrary domain-specific data that should be stored with this constraint. The payload is not used by Athena::Validator , but its processing is completely up to you. Constants IS_NIL_ERROR = \"c7e77b14-744e-44c0-aa7e-391c69cc335c\" Class methods .new ( message : String = \"This value should not be null.\" , groups : Array ( String ) | String | Nil = nil , payload : Hash ( String , String )? = nil ) Methods #validated_by : AVD :: ConstraintValidator . class Returns the AVD::ConstraintValidator.class that should handle validating self .","title":"NotNil"},{"location":"Validator/Constraints/NotNil/#Athena::Validator::Constraints::NotNil","text":"Validates that a value is not nil . NOTE: Due to Crystal's static typing, when validating objects the property's type must be nilable, otherwise nil is inherently not allowed due to the compiler's type checking.","title":"NotNil"},{"location":"Validator/Constraints/NotNil/#Athena::Validator::Constraints::NotNil--configuration","text":"","title":"Configuration"},{"location":"Validator/Constraints/NotNil/#Athena::Validator::Constraints::NotNil--optional-arguments","text":"","title":"Optional Arguments"},{"location":"Validator/Constraints/NotNil/#Athena::Validator::Constraints::NotNil--message","text":"Type: String Default: This value should not be null. The message that will be shown if the value is nil .","title":"message"},{"location":"Validator/Constraints/NotNil/#Athena::Validator::Constraints::NotNil--placeholders","text":"The following placeholders can be used in this message: {{ value }} - The current (invalid) value.","title":"Placeholders"},{"location":"Validator/Constraints/NotNil/#Athena::Validator::Constraints::NotNil--groups","text":"Type: Array(String) | String | Nil Default: nil The validation groups this constraint belongs to. AVD::Constraint::DEFAULT_GROUP is assumed if nil .","title":"groups"},{"location":"Validator/Constraints/NotNil/#Athena::Validator::Constraints::NotNil--payload","text":"Type: Hash(String, String)? Default: nil Any arbitrary domain-specific data that should be stored with this constraint. The payload is not used by Athena::Validator , but its processing is completely up to you.","title":"payload"},{"location":"Validator/Constraints/NotNil/#constants","text":"","title":"Constants"},{"location":"Validator/Constraints/NotNil/#Athena::Validator::Constraints::NotNil::IS_NIL_ERROR","text":"","title":"IS_NIL_ERROR"},{"location":"Validator/Constraints/NotNil/#class-methods","text":"","title":"Class methods"},{"location":"Validator/Constraints/NotNil/#Athena::Validator::Constraints::NotNil.new(message,groups,payload)","text":"","title":".new"},{"location":"Validator/Constraints/NotNil/#methods","text":"","title":"Methods"},{"location":"Validator/Constraints/NotNil/#Athena::Validator::Constraints::NotNil#validated_by()","text":"Returns the AVD::ConstraintValidator.class that should handle validating self .","title":"#validated_by"},{"location":"Validator/Constraints/NotNil/Validator/","text":"struct Athena::Validator::Constraints::NotNil::Validator inherits Athena::Validator::ConstraintValidator Methods #validate ( value : _ , constraint : AVD::Constraints::NotNil ) : Nil :inherit:","title":"Validator"},{"location":"Validator/Constraints/NotNil/Validator/#Athena::Validator::Constraints::NotNil::Validator","text":"","title":"Validator"},{"location":"Validator/Constraints/NotNil/Validator/#methods","text":"","title":"Methods"},{"location":"Validator/Constraints/NotNil/Validator/#Athena::Validator::Constraints::NotNil::Validator#validate(value,constraint)","text":":inherit:","title":"#validate"},{"location":"Validator/Constraints/Positive/","text":"class Athena::Validator::Constraints::Positive inherits Athena::Validator::Constraints::GreaterThan Validates that a value is a positive number. Use AVD::Constraints::PositiveOrZero if you wish to also allow 0 . Configuration Optional Arguments message Type: String Default: This value should be positive. The message that will be shown if the value is not greater than 0 . Placeholders The following placeholders can be used in this message: {{ value }} - The current (invalid) value. {{ compared_value }} - The expected value. {{ compared_value_type }} - The type of the expected value. groups Type: Array(String) | String | Nil Default: nil The validation groups this constraint belongs to. AVD::Constraint::DEFAULT_GROUP is assumed if nil . payload Type: Hash(String, String)? Default: nil Any arbitrary domain-specific data that should be stored with this constraint. The payload is not used by Athena::Validator , but its processing is completely up to you. Class methods .new ( message : String = \"This value should be positive.\" , groups : Array ( String ) | String | Nil = nil , payload : Hash ( String , String )? = nil ) Methods #validated_by : AVD :: ConstraintValidator . class :inherit:","title":"Positive"},{"location":"Validator/Constraints/Positive/#Athena::Validator::Constraints::Positive","text":"Validates that a value is a positive number. Use AVD::Constraints::PositiveOrZero if you wish to also allow 0 .","title":"Positive"},{"location":"Validator/Constraints/Positive/#Athena::Validator::Constraints::Positive--configuration","text":"","title":"Configuration"},{"location":"Validator/Constraints/Positive/#Athena::Validator::Constraints::Positive--optional-arguments","text":"","title":"Optional Arguments"},{"location":"Validator/Constraints/Positive/#Athena::Validator::Constraints::Positive--message","text":"Type: String Default: This value should be positive. The message that will be shown if the value is not greater than 0 .","title":"message"},{"location":"Validator/Constraints/Positive/#Athena::Validator::Constraints::Positive--placeholders","text":"The following placeholders can be used in this message: {{ value }} - The current (invalid) value. {{ compared_value }} - The expected value. {{ compared_value_type }} - The type of the expected value.","title":"Placeholders"},{"location":"Validator/Constraints/Positive/#Athena::Validator::Constraints::Positive--groups","text":"Type: Array(String) | String | Nil Default: nil The validation groups this constraint belongs to. AVD::Constraint::DEFAULT_GROUP is assumed if nil .","title":"groups"},{"location":"Validator/Constraints/Positive/#Athena::Validator::Constraints::Positive--payload","text":"Type: Hash(String, String)? Default: nil Any arbitrary domain-specific data that should be stored with this constraint. The payload is not used by Athena::Validator , but its processing is completely up to you.","title":"payload"},{"location":"Validator/Constraints/Positive/#class-methods","text":"","title":"Class methods"},{"location":"Validator/Constraints/Positive/#Athena::Validator::Constraints::Positive.new(message,groups,payload)","text":"","title":".new"},{"location":"Validator/Constraints/Positive/#methods","text":"","title":"Methods"},{"location":"Validator/Constraints/Positive/#Athena::Validator::Constraints::Positive#validated_by()","text":":inherit:","title":"#validated_by"},{"location":"Validator/Constraints/PositiveOrZero/","text":"class Athena::Validator::Constraints::PositiveOrZero inherits Athena::Validator::Constraints::GreaterThanOrEqual Validates that a value is a positive number, or 0 . Use AVD::Constraints::Positive if you don't want to allow 0 . Configuration Optional Arguments message Type: String Default: This value should be positive or zero. The message that will be shown if the value is not greater than or equal to 0 . Placeholders The following placeholders can be used in this message: {{ value }} - The current (invalid) value. {{ compared_value }} - The expected value. {{ compared_value_type }} - The type of the expected value. groups Type: Array(String) | String | Nil Default: nil The validation groups this constraint belongs to. AVD::Constraint::DEFAULT_GROUP is assumed if nil . payload Type: Hash(String, String)? Default: nil Any arbitrary domain-specific data that should be stored with this constraint. The payload is not used by Athena::Validator , but its processing is completely up to you. Class methods .new ( message : String = \"This value should be positive or zero.\" , groups : Array ( String ) | String | Nil = nil , payload : Hash ( String , String )? = nil ) Methods #validated_by : AVD :: ConstraintValidator . class :inherit:","title":"PositiveOrZero"},{"location":"Validator/Constraints/PositiveOrZero/#Athena::Validator::Constraints::PositiveOrZero","text":"Validates that a value is a positive number, or 0 . Use AVD::Constraints::Positive if you don't want to allow 0 .","title":"PositiveOrZero"},{"location":"Validator/Constraints/PositiveOrZero/#Athena::Validator::Constraints::PositiveOrZero--configuration","text":"","title":"Configuration"},{"location":"Validator/Constraints/PositiveOrZero/#Athena::Validator::Constraints::PositiveOrZero--optional-arguments","text":"","title":"Optional Arguments"},{"location":"Validator/Constraints/PositiveOrZero/#Athena::Validator::Constraints::PositiveOrZero--message","text":"Type: String Default: This value should be positive or zero. The message that will be shown if the value is not greater than or equal to 0 .","title":"message"},{"location":"Validator/Constraints/PositiveOrZero/#Athena::Validator::Constraints::PositiveOrZero--placeholders","text":"The following placeholders can be used in this message: {{ value }} - The current (invalid) value. {{ compared_value }} - The expected value. {{ compared_value_type }} - The type of the expected value.","title":"Placeholders"},{"location":"Validator/Constraints/PositiveOrZero/#Athena::Validator::Constraints::PositiveOrZero--groups","text":"Type: Array(String) | String | Nil Default: nil The validation groups this constraint belongs to. AVD::Constraint::DEFAULT_GROUP is assumed if nil .","title":"groups"},{"location":"Validator/Constraints/PositiveOrZero/#Athena::Validator::Constraints::PositiveOrZero--payload","text":"Type: Hash(String, String)? Default: nil Any arbitrary domain-specific data that should be stored with this constraint. The payload is not used by Athena::Validator , but its processing is completely up to you.","title":"payload"},{"location":"Validator/Constraints/PositiveOrZero/#class-methods","text":"","title":"Class methods"},{"location":"Validator/Constraints/PositiveOrZero/#Athena::Validator::Constraints::PositiveOrZero.new(message,groups,payload)","text":"","title":".new"},{"location":"Validator/Constraints/PositiveOrZero/#methods","text":"","title":"Methods"},{"location":"Validator/Constraints/PositiveOrZero/#Athena::Validator::Constraints::PositiveOrZero#validated_by()","text":":inherit:","title":"#validated_by"},{"location":"Validator/Constraints/Range/","text":"class Athena::Validator::Constraints::Range inherits Athena::Validator::Constraint Validates that a Number or Time value is between some minimum and maximum. Configuration Required Arguments range Type: ::Range The ::Range that defines the minimum and maximum values, if any. An endless range can be used to only have a minimum or maximum. Optional Arguments NOTE: This constraint does not support a message argument. not_in_range_message Type: String Default: This value should be between {{ min }} and {{ max }}. The message that will be shown if the value is less than the min or greater than the max. Placeholders The following placeholders can be used in this message: {{ value }} - The current (invalid) value. {{ min }} - The lower limit. {{ max }} - The upper limit. min_message Type: String Default: This value should be {{ limit }} or more. The message that will be shown if the value is less than the min, and no max has been provided. Placeholders The following placeholders can be used in this message: {{ value }} - The current (invalid) value. {{ limit }} - The lower limit. max_message Type: String Default: This value should be {{ limit }} or less. The message that will be shown if the value is more than the max, and no min has been provided. Placeholders The following placeholders can be used in this message: {{ value }} - The current (invalid) value. {{ limit }} - The upper limit. groups Type: Array(String) | String | Nil Default: nil The validation groups this constraint belongs to. AVD::Constraint::DEFAULT_GROUP is assumed if nil . payload Type: Hash(String, String)? Default: nil Any arbitrary domain-specific data that should be stored with this constraint. The payload is not used by Athena::Validator , but its processing is completely up to you. Constants NOT_IN_RANGE_ERROR = \"7e62386d-30ae-4e7c-918f-1b7e571c6d69\" TOO_HIGH_ERROR = \"5d9aed01-ac49-4d8e-9c16-e4aab74ea774\" TOO_LOW_ERROR = \"f0316644-882e-4779-a404-ee7ac97ddecc\" Class methods .new ( range : :: Range , not_in_range_message : String = \"This value should be between {{ min }} and {{ max }}.\" , min_message : String = \"This value should be {{ limit }} or more.\" , max_message : String = \"This value should be {{ limit }} or less.\" , groups : Array ( String ) | String | Nil = nil , payload : Hash ( String , String )? = nil ) Methods #max : Number :: Primitive | Time | Nil #max_message : String #min : Number :: Primitive | Time | Nil #min_message : String #not_in_range_message : String #validated_by : AVD :: ConstraintValidator . class Returns the AVD::ConstraintValidator.class that should handle validating self .","title":"Range"},{"location":"Validator/Constraints/Range/#Athena::Validator::Constraints::Range","text":"Validates that a Number or Time value is between some minimum and maximum.","title":"Range"},{"location":"Validator/Constraints/Range/#Athena::Validator::Constraints::Range--configuration","text":"","title":"Configuration"},{"location":"Validator/Constraints/Range/#Athena::Validator::Constraints::Range--required-arguments","text":"","title":"Required Arguments"},{"location":"Validator/Constraints/Range/#Athena::Validator::Constraints::Range--range","text":"Type: ::Range The ::Range that defines the minimum and maximum values, if any. An endless range can be used to only have a minimum or maximum.","title":"range"},{"location":"Validator/Constraints/Range/#Athena::Validator::Constraints::Range--optional-arguments","text":"NOTE: This constraint does not support a message argument.","title":"Optional Arguments"},{"location":"Validator/Constraints/Range/#Athena::Validator::Constraints::Range--not_in_range_message","text":"Type: String Default: This value should be between {{ min }} and {{ max }}. The message that will be shown if the value is less than the min or greater than the max.","title":"not_in_range_message"},{"location":"Validator/Constraints/Range/#Athena::Validator::Constraints::Range--placeholders","text":"The following placeholders can be used in this message: {{ value }} - The current (invalid) value. {{ min }} - The lower limit. {{ max }} - The upper limit.","title":"Placeholders"},{"location":"Validator/Constraints/Range/#Athena::Validator::Constraints::Range--min_message","text":"Type: String Default: This value should be {{ limit }} or more. The message that will be shown if the value is less than the min, and no max has been provided.","title":"min_message"},{"location":"Validator/Constraints/Range/#Athena::Validator::Constraints::Range--placeholders_1","text":"The following placeholders can be used in this message: {{ value }} - The current (invalid) value. {{ limit }} - The lower limit.","title":"Placeholders"},{"location":"Validator/Constraints/Range/#Athena::Validator::Constraints::Range--max_message","text":"Type: String Default: This value should be {{ limit }} or less. The message that will be shown if the value is more than the max, and no min has been provided.","title":"max_message"},{"location":"Validator/Constraints/Range/#Athena::Validator::Constraints::Range--placeholders_2","text":"The following placeholders can be used in this message: {{ value }} - The current (invalid) value. {{ limit }} - The upper limit.","title":"Placeholders"},{"location":"Validator/Constraints/Range/#Athena::Validator::Constraints::Range--groups","text":"Type: Array(String) | String | Nil Default: nil The validation groups this constraint belongs to. AVD::Constraint::DEFAULT_GROUP is assumed if nil .","title":"groups"},{"location":"Validator/Constraints/Range/#Athena::Validator::Constraints::Range--payload","text":"Type: Hash(String, String)? Default: nil Any arbitrary domain-specific data that should be stored with this constraint. The payload is not used by Athena::Validator , but its processing is completely up to you.","title":"payload"},{"location":"Validator/Constraints/Range/#constants","text":"","title":"Constants"},{"location":"Validator/Constraints/Range/#Athena::Validator::Constraints::Range::NOT_IN_RANGE_ERROR","text":"","title":"NOT_IN_RANGE_ERROR"},{"location":"Validator/Constraints/Range/#Athena::Validator::Constraints::Range::TOO_HIGH_ERROR","text":"","title":"TOO_HIGH_ERROR"},{"location":"Validator/Constraints/Range/#Athena::Validator::Constraints::Range::TOO_LOW_ERROR","text":"","title":"TOO_LOW_ERROR"},{"location":"Validator/Constraints/Range/#class-methods","text":"","title":"Class methods"},{"location":"Validator/Constraints/Range/#Athena::Validator::Constraints::Range.new(range,not_in_range_message,min_message,max_message,groups,payload)","text":"","title":".new"},{"location":"Validator/Constraints/Range/#methods","text":"","title":"Methods"},{"location":"Validator/Constraints/Range/#Athena::Validator::Constraints::Range#max()","text":"","title":"#max"},{"location":"Validator/Constraints/Range/#Athena::Validator::Constraints::Range#max_message()","text":"","title":"#max_message"},{"location":"Validator/Constraints/Range/#Athena::Validator::Constraints::Range#min()","text":"","title":"#min"},{"location":"Validator/Constraints/Range/#Athena::Validator::Constraints::Range#min_message()","text":"","title":"#min_message"},{"location":"Validator/Constraints/Range/#Athena::Validator::Constraints::Range#not_in_range_message()","text":"","title":"#not_in_range_message"},{"location":"Validator/Constraints/Range/#Athena::Validator::Constraints::Range#validated_by()","text":"Returns the AVD::ConstraintValidator.class that should handle validating self .","title":"#validated_by"},{"location":"Validator/Constraints/Range/Validator/","text":"struct Athena::Validator::Constraints::Range::Validator inherits Athena::Validator::ConstraintValidator Methods #validate ( value : Number | Time | Nil , constraint : AVD::Constraints::Range ) : Nil :inherit: ameba:disable Metrics/CyclomaticComplexity #validate ( value : _ , constraint : AVD::Constraints::Range ) : Nil","title":"Validator"},{"location":"Validator/Constraints/Range/Validator/#Athena::Validator::Constraints::Range::Validator","text":"","title":"Validator"},{"location":"Validator/Constraints/Range/Validator/#methods","text":"","title":"Methods"},{"location":"Validator/Constraints/Range/Validator/#Athena::Validator::Constraints::Range::Validator#validate(value,constraint)","text":":inherit: ameba:disable Metrics/CyclomaticComplexity","title":"#validate"},{"location":"Validator/Constraints/Range/Validator/#Athena::Validator::Constraints::Range::Validator#validate(value,constraint)","text":"","title":"#validate"},{"location":"Validator/Constraints/Regex/","text":"class Athena::Validator::Constraints::Regex inherits Athena::Validator::Constraint Validates that a value matches a regular expression. The underlying value is converted to a string via #to_s before being validated. NOTE: As with most other constraints, nil and empty strings are considered valid values, in order to allow the value to be optional. If the value is required, consider combining this constraint with AVD::Constraints::NotBlank . Configuration Required Arguments pattern Type: ::Regex The ::Regex pattern that the value should match. Optional Arguments match Type: Bool Default: true If set to false , validation will require the value does NOT match the pattern . message Type: String Default: This value should match '{{ pattern }}'. The message that will be shown if the value does not match the pattern . Placeholders The following placeholders can be used in this message: {{ value }} - The current (invalid) value. {{ pattern }} - The regular expression pattern that the value should match. groups Type: Array(String) | String | Nil Default: nil The validation groups this constraint belongs to. AVD::Constraint::DEFAULT_GROUP is assumed if nil . payload Type: Hash(String, String)? Default: nil Any arbitrary domain-specific data that should be stored with this constraint. The payload is not used by Athena::Validator , but its processing is completely up to you. Constants REGEX_FAILED_ERROR = \"108987a0-2d81-44a0-b8d4-1c7ab8815343\" Class methods .new ( pattern : :: Regex , match : Bool = true , message : String = \"This value should match '{{ pattern }}'.\" , groups : Array ( String ) | String | Nil = nil , payload : Hash ( String , String )? = nil ) Methods #match? : Bool #pattern : :: Regex #validated_by : AVD :: ConstraintValidator . class Returns the AVD::ConstraintValidator.class that should handle validating self .","title":"Regex"},{"location":"Validator/Constraints/Regex/#Athena::Validator::Constraints::Regex","text":"Validates that a value matches a regular expression. The underlying value is converted to a string via #to_s before being validated. NOTE: As with most other constraints, nil and empty strings are considered valid values, in order to allow the value to be optional. If the value is required, consider combining this constraint with AVD::Constraints::NotBlank .","title":"Regex"},{"location":"Validator/Constraints/Regex/#Athena::Validator::Constraints::Regex--configuration","text":"","title":"Configuration"},{"location":"Validator/Constraints/Regex/#Athena::Validator::Constraints::Regex--required-arguments","text":"","title":"Required Arguments"},{"location":"Validator/Constraints/Regex/#Athena::Validator::Constraints::Regex--pattern","text":"Type: ::Regex The ::Regex pattern that the value should match.","title":"pattern"},{"location":"Validator/Constraints/Regex/#Athena::Validator::Constraints::Regex--optional-arguments","text":"","title":"Optional Arguments"},{"location":"Validator/Constraints/Regex/#Athena::Validator::Constraints::Regex--match","text":"Type: Bool Default: true If set to false , validation will require the value does NOT match the pattern .","title":"match"},{"location":"Validator/Constraints/Regex/#Athena::Validator::Constraints::Regex--message","text":"Type: String Default: This value should match '{{ pattern }}'. The message that will be shown if the value does not match the pattern .","title":"message"},{"location":"Validator/Constraints/Regex/#Athena::Validator::Constraints::Regex--placeholders","text":"The following placeholders can be used in this message: {{ value }} - The current (invalid) value. {{ pattern }} - The regular expression pattern that the value should match.","title":"Placeholders"},{"location":"Validator/Constraints/Regex/#Athena::Validator::Constraints::Regex--groups","text":"Type: Array(String) | String | Nil Default: nil The validation groups this constraint belongs to. AVD::Constraint::DEFAULT_GROUP is assumed if nil .","title":"groups"},{"location":"Validator/Constraints/Regex/#Athena::Validator::Constraints::Regex--payload","text":"Type: Hash(String, String)? Default: nil Any arbitrary domain-specific data that should be stored with this constraint. The payload is not used by Athena::Validator , but its processing is completely up to you.","title":"payload"},{"location":"Validator/Constraints/Regex/#constants","text":"","title":"Constants"},{"location":"Validator/Constraints/Regex/#Athena::Validator::Constraints::Regex::REGEX_FAILED_ERROR","text":"","title":"REGEX_FAILED_ERROR"},{"location":"Validator/Constraints/Regex/#class-methods","text":"","title":"Class methods"},{"location":"Validator/Constraints/Regex/#Athena::Validator::Constraints::Regex.new(pattern,match,message,groups,payload)","text":"","title":".new"},{"location":"Validator/Constraints/Regex/#methods","text":"","title":"Methods"},{"location":"Validator/Constraints/Regex/#Athena::Validator::Constraints::Regex#match?()","text":"","title":"#match?"},{"location":"Validator/Constraints/Regex/#Athena::Validator::Constraints::Regex#pattern()","text":"","title":"#pattern"},{"location":"Validator/Constraints/Regex/#Athena::Validator::Constraints::Regex#validated_by()","text":"Returns the AVD::ConstraintValidator.class that should handle validating self .","title":"#validated_by"},{"location":"Validator/Constraints/Regex/Validator/","text":"struct Athena::Validator::Constraints::Regex::Validator inherits Athena::Validator::ConstraintValidator Methods #validate ( value : _ , constraint : AVD::Constraints::Regex ) : Nil :inherit:","title":"Validator"},{"location":"Validator/Constraints/Regex/Validator/#Athena::Validator::Constraints::Regex::Validator","text":"","title":"Validator"},{"location":"Validator/Constraints/Regex/Validator/#methods","text":"","title":"Methods"},{"location":"Validator/Constraints/Regex/Validator/#Athena::Validator::Constraints::Regex::Validator#validate(value,constraint)","text":":inherit:","title":"#validate"},{"location":"Validator/Constraints/Sequentially/","text":"class Athena::Validator::Constraints::Sequentially inherits Athena::Validator::Constraints::Composite Validates a value against a collection of constraints, stopping once the first violation is raised. Configuration Required Arguments constraints Type: Array(AVD::Constraint) | AVD::Constraint The AVD::Constraint (s) that are to be applied sequentially. Optional Arguments NOTE: This constraint does not support a message argument. groups Type: Array(String) | String | Nil Default: nil The validation groups this constraint belongs to. AVD::Constraint::DEFAULT_GROUP is assumed if nil . payload Type: Hash(String, String)? Default: nil Any arbitrary domain-specific data that should be stored with this constraint. The payload is not used by Athena::Validator , but its processing is completely up to you. Usage Suppose you have an object with a address property which should meet the following criteria: Is not a blank string Is at least 10 characters long Is in a specific format Is geolocalizable using an external API If you were to apply all of these constraints to the address property, you may run into some problems. For example, multiple violations may be added for the same property, or you may perform a useless and heavy external call to geolocalize the address when it is not in a proper format. To solve this we can validate these constraints sequentially. class Location include AVD :: Validatable PATTERN = /some_pattern/ def initialize ( @address : String ); end @[ Assert :: Sequentially ( [ @[ Assert :: NotBlank ] , @[ Assert :: Size ( 10 .. ) ] , @[ Assert :: Regex ( Location :: PATTERN ) ] , @[ Assert :: CustomGeolocalizationConstraint ] , ] ) ] getter address : String end NOTE: The annotation approach only supports two levels of nested annotations. Manually wire up the constraint via code if you require more than that. Class methods .new ( constraints : Array ( AVD::Constraint ) | AVD::Constraint , groups : Array ( String ) | String | Nil = nil , payload : Hash ( String , String )? = nil ) Methods #validated_by : AVD :: ConstraintValidator . class Returns the AVD::ConstraintValidator.class that should handle validating self .","title":"Sequentially"},{"location":"Validator/Constraints/Sequentially/#Athena::Validator::Constraints::Sequentially","text":"Validates a value against a collection of constraints, stopping once the first violation is raised.","title":"Sequentially"},{"location":"Validator/Constraints/Sequentially/#Athena::Validator::Constraints::Sequentially--configuration","text":"","title":"Configuration"},{"location":"Validator/Constraints/Sequentially/#Athena::Validator::Constraints::Sequentially--required-arguments","text":"","title":"Required Arguments"},{"location":"Validator/Constraints/Sequentially/#Athena::Validator::Constraints::Sequentially--constraints","text":"Type: Array(AVD::Constraint) | AVD::Constraint The AVD::Constraint (s) that are to be applied sequentially.","title":"constraints"},{"location":"Validator/Constraints/Sequentially/#Athena::Validator::Constraints::Sequentially--optional-arguments","text":"NOTE: This constraint does not support a message argument.","title":"Optional Arguments"},{"location":"Validator/Constraints/Sequentially/#Athena::Validator::Constraints::Sequentially--groups","text":"Type: Array(String) | String | Nil Default: nil The validation groups this constraint belongs to. AVD::Constraint::DEFAULT_GROUP is assumed if nil .","title":"groups"},{"location":"Validator/Constraints/Sequentially/#Athena::Validator::Constraints::Sequentially--payload","text":"Type: Hash(String, String)? Default: nil Any arbitrary domain-specific data that should be stored with this constraint. The payload is not used by Athena::Validator , but its processing is completely up to you.","title":"payload"},{"location":"Validator/Constraints/Sequentially/#Athena::Validator::Constraints::Sequentially--usage","text":"Suppose you have an object with a address property which should meet the following criteria: Is not a blank string Is at least 10 characters long Is in a specific format Is geolocalizable using an external API If you were to apply all of these constraints to the address property, you may run into some problems. For example, multiple violations may be added for the same property, or you may perform a useless and heavy external call to geolocalize the address when it is not in a proper format. To solve this we can validate these constraints sequentially. class Location include AVD :: Validatable PATTERN = /some_pattern/ def initialize ( @address : String ); end @[ Assert :: Sequentially ( [ @[ Assert :: NotBlank ] , @[ Assert :: Size ( 10 .. ) ] , @[ Assert :: Regex ( Location :: PATTERN ) ] , @[ Assert :: CustomGeolocalizationConstraint ] , ] ) ] getter address : String end NOTE: The annotation approach only supports two levels of nested annotations. Manually wire up the constraint via code if you require more than that.","title":"Usage"},{"location":"Validator/Constraints/Sequentially/#class-methods","text":"","title":"Class methods"},{"location":"Validator/Constraints/Sequentially/#Athena::Validator::Constraints::Sequentially.new(constraints,groups,payload)","text":"","title":".new"},{"location":"Validator/Constraints/Sequentially/#methods","text":"","title":"Methods"},{"location":"Validator/Constraints/Sequentially/#Athena::Validator::Constraints::Sequentially#validated_by()","text":"Returns the AVD::ConstraintValidator.class that should handle validating self .","title":"#validated_by"},{"location":"Validator/Constraints/Sequentially/Validator/","text":"struct Athena::Validator::Constraints::Sequentially::Validator inherits Athena::Validator::ConstraintValidator Methods #validate ( value : _ , constraint : AVD::Constraints::Sequentially ) : Nil :inherit:","title":"Validator"},{"location":"Validator/Constraints/Sequentially/Validator/#Athena::Validator::Constraints::Sequentially::Validator","text":"","title":"Validator"},{"location":"Validator/Constraints/Sequentially/Validator/#methods","text":"","title":"Methods"},{"location":"Validator/Constraints/Sequentially/Validator/#Athena::Validator::Constraints::Sequentially::Validator#validate(value,constraint)","text":":inherit:","title":"#validate"},{"location":"Validator/Constraints/Size/","text":"class Athena::Validator::Constraints::Size inherits Athena::Validator::Constraint Validates that the #size of a String or Indexable value is between some minimum and maximum. Configuration Required Arguments range Type: ::Range The ::Range that defines the minimum and maximum values, if any. An endless range can be used to only have a minimum or maximum. Optional Arguments NOTE: This constraint does not support a message argument. exact_message Type: String Default: This value should have exactly {{ limit }} {{ type }}.|This value should have exactly {{ limit }} {{ type }}s. The message that will be shown if min and max values are equal and the underlying value\u2019s size is not exactly this value. The message is pluralized depending on how many elements/characters the underlying value has. Placeholders The following placeholders can be used in this message: {{ value }} - The current (invalid) value. {{ limit }} - The exact expected size. {{ type }} - character if the value is a string or item if the value is an indexable. min_message Type: String Default: This value is too short. It should have {{ limit }} {{ type }} or more.|This value is too short. It should have {{ limit }} {{ type }}s or more. The message that will be shown if the underlying value\u2019s size is less than the min. The message is pluralized depending on how many elements/characters the underlying value has. Placeholders The following placeholders can be used in this message: {{ value }} - The current (invalid) value. {{ limit }} - The expected minimum size. {{ type }} - character if the value is a string or item if the value is an indexable. max_message Type: String Default: This value is too long. It should have {{ limit }} {{ type }} or less.|This value is too long. It should have {{ limit }} {{ type }}s or less. The message that will be shown if the underlying value\u2019s size is greater than the max. The message is pluralized depending on how many elements/characters the underlying value has. Placeholders The following placeholders can be used in this message: {{ value }} - The current (invalid) value. {{ limit }} - The expected minimum size. {{ type }} - character if the value is a string or item if the value is an indexable. groups Type: Array(String) | String | Nil Default: nil The validation groups this constraint belongs to. AVD::Constraint::DEFAULT_GROUP is assumed if nil . payload Type: Hash(String, String)? Default: nil Any arbitrary domain-specific data that should be stored with this constraint. The payload is not used by Athena::Validator , but its processing is completely up to you. Constants TOO_LONG_ERROR = \"a1fa7a63-ea3b-46a0-adcc-5e1bcc26f73a\" TOO_SHORT_ERROR = \"8ba31c71-1b37-4b76-8bc9-66896589b01f\" Class methods .new ( range : :: Range , min_message : String = \"This value is too short. It should have {{ limit }} {{ type }} or more.|This value is too short. It should have {{ limit }} {{ type }}s or more.\" , max_message : String = \"This value is too long. It should have {{ limit }} {{ type }} or less.|This value is too long. It should have {{ limit }} {{ type }}s or less.\" , exact_message : String = \"This value should have exactly {{ limit }} {{ type }}.|This value should have exactly {{ limit }} {{ type }}s.\" , groups : Array ( String ) | String | Nil = nil , payload : Hash ( String , String )? = nil ) Methods #exact_message : String #max : Int32 ? #max_message : String #min : Int32 ? #min_message : String #validated_by : AVD :: ConstraintValidator . class Returns the AVD::ConstraintValidator.class that should handle validating self .","title":"Size"},{"location":"Validator/Constraints/Size/#Athena::Validator::Constraints::Size","text":"Validates that the #size of a String or Indexable value is between some minimum and maximum.","title":"Size"},{"location":"Validator/Constraints/Size/#Athena::Validator::Constraints::Size--configuration","text":"","title":"Configuration"},{"location":"Validator/Constraints/Size/#Athena::Validator::Constraints::Size--required-arguments","text":"","title":"Required Arguments"},{"location":"Validator/Constraints/Size/#Athena::Validator::Constraints::Size--range","text":"Type: ::Range The ::Range that defines the minimum and maximum values, if any. An endless range can be used to only have a minimum or maximum.","title":"range"},{"location":"Validator/Constraints/Size/#Athena::Validator::Constraints::Size--optional-arguments","text":"NOTE: This constraint does not support a message argument.","title":"Optional Arguments"},{"location":"Validator/Constraints/Size/#Athena::Validator::Constraints::Size--exact_message","text":"Type: String Default: This value should have exactly {{ limit }} {{ type }}.|This value should have exactly {{ limit }} {{ type }}s. The message that will be shown if min and max values are equal and the underlying value\u2019s size is not exactly this value. The message is pluralized depending on how many elements/characters the underlying value has.","title":"exact_message"},{"location":"Validator/Constraints/Size/#Athena::Validator::Constraints::Size--placeholders","text":"The following placeholders can be used in this message: {{ value }} - The current (invalid) value. {{ limit }} - The exact expected size. {{ type }} - character if the value is a string or item if the value is an indexable.","title":"Placeholders"},{"location":"Validator/Constraints/Size/#Athena::Validator::Constraints::Size--min_message","text":"Type: String Default: This value is too short. It should have {{ limit }} {{ type }} or more.|This value is too short. It should have {{ limit }} {{ type }}s or more. The message that will be shown if the underlying value\u2019s size is less than the min. The message is pluralized depending on how many elements/characters the underlying value has.","title":"min_message"},{"location":"Validator/Constraints/Size/#Athena::Validator::Constraints::Size--placeholders_1","text":"The following placeholders can be used in this message: {{ value }} - The current (invalid) value. {{ limit }} - The expected minimum size. {{ type }} - character if the value is a string or item if the value is an indexable.","title":"Placeholders"},{"location":"Validator/Constraints/Size/#Athena::Validator::Constraints::Size--max_message","text":"Type: String Default: This value is too long. It should have {{ limit }} {{ type }} or less.|This value is too long. It should have {{ limit }} {{ type }}s or less. The message that will be shown if the underlying value\u2019s size is greater than the max. The message is pluralized depending on how many elements/characters the underlying value has.","title":"max_message"},{"location":"Validator/Constraints/Size/#Athena::Validator::Constraints::Size--placeholders_2","text":"The following placeholders can be used in this message: {{ value }} - The current (invalid) value. {{ limit }} - The expected minimum size. {{ type }} - character if the value is a string or item if the value is an indexable.","title":"Placeholders"},{"location":"Validator/Constraints/Size/#Athena::Validator::Constraints::Size--groups","text":"Type: Array(String) | String | Nil Default: nil The validation groups this constraint belongs to. AVD::Constraint::DEFAULT_GROUP is assumed if nil .","title":"groups"},{"location":"Validator/Constraints/Size/#Athena::Validator::Constraints::Size--payload","text":"Type: Hash(String, String)? Default: nil Any arbitrary domain-specific data that should be stored with this constraint. The payload is not used by Athena::Validator , but its processing is completely up to you.","title":"payload"},{"location":"Validator/Constraints/Size/#constants","text":"","title":"Constants"},{"location":"Validator/Constraints/Size/#Athena::Validator::Constraints::Size::TOO_LONG_ERROR","text":"","title":"TOO_LONG_ERROR"},{"location":"Validator/Constraints/Size/#Athena::Validator::Constraints::Size::TOO_SHORT_ERROR","text":"","title":"TOO_SHORT_ERROR"},{"location":"Validator/Constraints/Size/#class-methods","text":"","title":"Class methods"},{"location":"Validator/Constraints/Size/#Athena::Validator::Constraints::Size.new(range,min_message,max_message,exact_message,groups,payload)","text":"","title":".new"},{"location":"Validator/Constraints/Size/#methods","text":"","title":"Methods"},{"location":"Validator/Constraints/Size/#Athena::Validator::Constraints::Size#exact_message()","text":"","title":"#exact_message"},{"location":"Validator/Constraints/Size/#Athena::Validator::Constraints::Size#max()","text":"","title":"#max"},{"location":"Validator/Constraints/Size/#Athena::Validator::Constraints::Size#max_message()","text":"","title":"#max_message"},{"location":"Validator/Constraints/Size/#Athena::Validator::Constraints::Size#min()","text":"","title":"#min"},{"location":"Validator/Constraints/Size/#Athena::Validator::Constraints::Size#min_message()","text":"","title":"#min_message"},{"location":"Validator/Constraints/Size/#Athena::Validator::Constraints::Size#validated_by()","text":"Returns the AVD::ConstraintValidator.class that should handle validating self .","title":"#validated_by"},{"location":"Validator/Constraints/Size/Validator/","text":"struct Athena::Validator::Constraints::Size::Validator inherits Athena::Validator::ConstraintValidator Methods #validate ( value : String | Indexable , constraint : AVD::Constraints::Size ) : Nil :inherit:","title":"Validator"},{"location":"Validator/Constraints/Size/Validator/#Athena::Validator::Constraints::Size::Validator","text":"","title":"Validator"},{"location":"Validator/Constraints/Size/Validator/#methods","text":"","title":"Methods"},{"location":"Validator/Constraints/Size/Validator/#Athena::Validator::Constraints::Size::Validator#validate(value,constraint)","text":":inherit:","title":"#validate"},{"location":"Validator/Constraints/URL/","text":"class Athena::Validator::Constraints::URL inherits Athena::Validator::Constraint Validates that a value is a valid URL string. The underlying value is converted to a string via #to_s before being validated. NOTE: As with most other constraints, nil and empty strings are considered valid values, in order to allow the value to be optional. If the value is required, consider combining this constraint with AVD::Constraints::NotBlank . Configuration Optional Arguments protocols Type: Array(String) Default: [\"http\", \"https\"] The protocols considered to be valid for the URL. relative_protocol Type: Bool Default: false If true the protocol is considered optional. message Type: String Default: This value is not a valid URL. The message that will be shown if the URL is not valid. Placeholders The following placeholders can be used in this message: {{ value }} - The current (invalid) value. groups Type: Array(String) | String | Nil Default: nil The validation groups this constraint belongs to. AVD::Constraint::DEFAULT_GROUP is assumed if nil . payload Type: Hash(String, String)? Default: nil Any arbitrary domain-specific data that should be stored with this constraint. The payload is not used by Athena::Validator , but its processing is completely up to you. Constants INVALID_URL_ERROR = \"e87ceba6-a896-4906-9957-b102045272ee\" Class methods .new ( protocols : Array ( String ) = [ \"http\" , \"https\" ] , relative_protocol : Bool = false , message : String = \"This value is not a valid URL.\" , groups : Array ( String ) | String | Nil = nil , payload : Hash ( String , String )? = nil ) Methods #protocols : Array ( String ) #relative_protocol? : Bool #validated_by : AVD :: ConstraintValidator . class Returns the AVD::ConstraintValidator.class that should handle validating self .","title":"URL"},{"location":"Validator/Constraints/URL/#Athena::Validator::Constraints::URL","text":"Validates that a value is a valid URL string. The underlying value is converted to a string via #to_s before being validated. NOTE: As with most other constraints, nil and empty strings are considered valid values, in order to allow the value to be optional. If the value is required, consider combining this constraint with AVD::Constraints::NotBlank .","title":"URL"},{"location":"Validator/Constraints/URL/#Athena::Validator::Constraints::URL--configuration","text":"","title":"Configuration"},{"location":"Validator/Constraints/URL/#Athena::Validator::Constraints::URL--optional-arguments","text":"","title":"Optional Arguments"},{"location":"Validator/Constraints/URL/#Athena::Validator::Constraints::URL--protocols","text":"Type: Array(String) Default: [\"http\", \"https\"] The protocols considered to be valid for the URL.","title":"protocols"},{"location":"Validator/Constraints/URL/#Athena::Validator::Constraints::URL--relative_protocol","text":"Type: Bool Default: false If true the protocol is considered optional.","title":"relative_protocol"},{"location":"Validator/Constraints/URL/#Athena::Validator::Constraints::URL--message","text":"Type: String Default: This value is not a valid URL. The message that will be shown if the URL is not valid.","title":"message"},{"location":"Validator/Constraints/URL/#Athena::Validator::Constraints::URL--placeholders","text":"The following placeholders can be used in this message: {{ value }} - The current (invalid) value.","title":"Placeholders"},{"location":"Validator/Constraints/URL/#Athena::Validator::Constraints::URL--groups","text":"Type: Array(String) | String | Nil Default: nil The validation groups this constraint belongs to. AVD::Constraint::DEFAULT_GROUP is assumed if nil .","title":"groups"},{"location":"Validator/Constraints/URL/#Athena::Validator::Constraints::URL--payload","text":"Type: Hash(String, String)? Default: nil Any arbitrary domain-specific data that should be stored with this constraint. The payload is not used by Athena::Validator , but its processing is completely up to you.","title":"payload"},{"location":"Validator/Constraints/URL/#constants","text":"","title":"Constants"},{"location":"Validator/Constraints/URL/#Athena::Validator::Constraints::URL::INVALID_URL_ERROR","text":"","title":"INVALID_URL_ERROR"},{"location":"Validator/Constraints/URL/#class-methods","text":"","title":"Class methods"},{"location":"Validator/Constraints/URL/#Athena::Validator::Constraints::URL.new(protocols,relative_protocol,message,groups,payload)","text":"","title":".new"},{"location":"Validator/Constraints/URL/#methods","text":"","title":"Methods"},{"location":"Validator/Constraints/URL/#Athena::Validator::Constraints::URL#protocols()","text":"","title":"#protocols"},{"location":"Validator/Constraints/URL/#Athena::Validator::Constraints::URL#relative_protocol?()","text":"","title":"#relative_protocol?"},{"location":"Validator/Constraints/URL/#Athena::Validator::Constraints::URL#validated_by()","text":"Returns the AVD::ConstraintValidator.class that should handle validating self .","title":"#validated_by"},{"location":"Validator/Constraints/URL/Validator/","text":"struct Athena::Validator::Constraints::URL::Validator inherits Athena::Validator::ConstraintValidator Methods #pattern ( constraint : AVD::Constraints::URL ) : :: Regex #validate ( value : _ , constraint : AVD::Constraints::URL ) : Nil :inherit:","title":"Validator"},{"location":"Validator/Constraints/URL/Validator/#Athena::Validator::Constraints::URL::Validator","text":"","title":"Validator"},{"location":"Validator/Constraints/URL/Validator/#methods","text":"","title":"Methods"},{"location":"Validator/Constraints/URL/Validator/#Athena::Validator::Constraints::URL::Validator#pattern(constraint)","text":"","title":"#pattern"},{"location":"Validator/Constraints/URL/Validator/#Athena::Validator::Constraints::URL::Validator#validate(value,constraint)","text":":inherit:","title":"#validate"},{"location":"Validator/Constraints/Unique/","text":"class Athena::Validator::Constraints::Unique inherits Athena::Validator::Constraint Validates that all elements of an Indexable are unique. Configuration Optional Arguments message Type: String Default: This collection should contain only unique elements. The message that will be shown if at least one element is repeated in the collection. Placeholders The following placeholders can be used in this message: {{ value }} - The current (invalid) value. groups Type: Array(String) | String | Nil Default: nil The validation groups this constraint belongs to. AVD::Constraint::DEFAULT_GROUP is assumed if nil . payload Type: Hash(String, String)? Default: nil Any arbitrary domain-specific data that should be stored with this constraint. The payload is not used by Athena::Validator , but its processing is completely up to you. Constants IS_NOT_UNIQUE_ERROR = \"fd1f83d6-94b5-44bc-b39d-b1ff367ebfb8\" Class methods .new ( message : String = \"This collection should contain only unique elements.\" , groups : Array ( String ) | String | Nil = nil , payload : Hash ( String , String )? = nil ) Methods #validated_by : AVD :: ConstraintValidator . class Returns the AVD::ConstraintValidator.class that should handle validating self .","title":"Unique"},{"location":"Validator/Constraints/Unique/#Athena::Validator::Constraints::Unique","text":"Validates that all elements of an Indexable are unique.","title":"Unique"},{"location":"Validator/Constraints/Unique/#Athena::Validator::Constraints::Unique--configuration","text":"","title":"Configuration"},{"location":"Validator/Constraints/Unique/#Athena::Validator::Constraints::Unique--optional-arguments","text":"","title":"Optional Arguments"},{"location":"Validator/Constraints/Unique/#Athena::Validator::Constraints::Unique--message","text":"Type: String Default: This collection should contain only unique elements. The message that will be shown if at least one element is repeated in the collection.","title":"message"},{"location":"Validator/Constraints/Unique/#Athena::Validator::Constraints::Unique--placeholders","text":"The following placeholders can be used in this message: {{ value }} - The current (invalid) value.","title":"Placeholders"},{"location":"Validator/Constraints/Unique/#Athena::Validator::Constraints::Unique--groups","text":"Type: Array(String) | String | Nil Default: nil The validation groups this constraint belongs to. AVD::Constraint::DEFAULT_GROUP is assumed if nil .","title":"groups"},{"location":"Validator/Constraints/Unique/#Athena::Validator::Constraints::Unique--payload","text":"Type: Hash(String, String)? Default: nil Any arbitrary domain-specific data that should be stored with this constraint. The payload is not used by Athena::Validator , but its processing is completely up to you.","title":"payload"},{"location":"Validator/Constraints/Unique/#constants","text":"","title":"Constants"},{"location":"Validator/Constraints/Unique/#Athena::Validator::Constraints::Unique::IS_NOT_UNIQUE_ERROR","text":"","title":"IS_NOT_UNIQUE_ERROR"},{"location":"Validator/Constraints/Unique/#class-methods","text":"","title":"Class methods"},{"location":"Validator/Constraints/Unique/#Athena::Validator::Constraints::Unique.new(message,groups,payload)","text":"","title":".new"},{"location":"Validator/Constraints/Unique/#methods","text":"","title":"Methods"},{"location":"Validator/Constraints/Unique/#Athena::Validator::Constraints::Unique#validated_by()","text":"Returns the AVD::ConstraintValidator.class that should handle validating self .","title":"#validated_by"},{"location":"Validator/Constraints/Unique/Validator/","text":"struct Athena::Validator::Constraints::Unique::Validator inherits Athena::Validator::ConstraintValidator Methods #compare_values ( actual : _ , expected : _ ) : NoReturn :inherit: #validate ( value : Indexable? , constraint : AVD::Constraints::Unique ) : Nil :inherit:","title":"Validator"},{"location":"Validator/Constraints/Unique/Validator/#Athena::Validator::Constraints::Unique::Validator","text":"","title":"Validator"},{"location":"Validator/Constraints/Unique/Validator/#methods","text":"","title":"Methods"},{"location":"Validator/Constraints/Unique/Validator/#Athena::Validator::Constraints::Unique::Validator#compare_values(actual,expected)","text":":inherit:","title":"#compare_values"},{"location":"Validator/Constraints/Unique/Validator/#Athena::Validator::Constraints::Unique::Validator#validate(value,constraint)","text":":inherit:","title":"#validate"},{"location":"Validator/Constraints/Valid/","text":"class Athena::Validator::Constraints::Valid inherits Athena::Validator::Constraint Tells the validator that it should also validate objects embedded as properties on an object being validated. Configuration Optional Arguments NOTE: This constraint does not support a message argument. groups Type: Array(String) | String | Nil Default: nil The validation groups this constraint belongs to. AVD::Constraint::DEFAULT_GROUP is assumed if nil . payload Type: Hash(String, String)? Default: nil Any arbitrary domain-specific data that should be stored with this constraint. The payload is not used by Athena::Validator , but its processing is completely up to you. Usage Without this constraint, objects embedded in another object are not valided. class SubObjectOne include AVD :: Validatable @[ Assert :: NotBlank ] getter string : String = \"\" end class SubObjectTwo include AVD :: Validatable @[ Assert :: NotBlank ] getter string : String = \"\" end class MyObject include AVD :: Validatable # This object is not validated when validating `MyObject`. getter sub_object_one : SubObjectOne = SubObjectOne . new # Have the validator also validate `SubObjectTwo` when validating `MyObject`. @[ Assert :: Valid ] getter sub_object_two : SubObjectTwo = SubObjectTwo . new end Class methods .new ( traverse : Bool = true , groups : Array ( String ) | String | Nil = nil , payload : Hash ( String , String )? = nil ) Methods #traverse? : Bool #validated_by : AVD :: ConstraintValidator . class Returns the AVD::ConstraintValidator.class that should handle validating self .","title":"Valid"},{"location":"Validator/Constraints/Valid/#Athena::Validator::Constraints::Valid","text":"Tells the validator that it should also validate objects embedded as properties on an object being validated.","title":"Valid"},{"location":"Validator/Constraints/Valid/#Athena::Validator::Constraints::Valid--configuration","text":"","title":"Configuration"},{"location":"Validator/Constraints/Valid/#Athena::Validator::Constraints::Valid--optional-arguments","text":"NOTE: This constraint does not support a message argument.","title":"Optional Arguments"},{"location":"Validator/Constraints/Valid/#Athena::Validator::Constraints::Valid--groups","text":"Type: Array(String) | String | Nil Default: nil The validation groups this constraint belongs to. AVD::Constraint::DEFAULT_GROUP is assumed if nil .","title":"groups"},{"location":"Validator/Constraints/Valid/#Athena::Validator::Constraints::Valid--payload","text":"Type: Hash(String, String)? Default: nil Any arbitrary domain-specific data that should be stored with this constraint. The payload is not used by Athena::Validator , but its processing is completely up to you.","title":"payload"},{"location":"Validator/Constraints/Valid/#Athena::Validator::Constraints::Valid--usage","text":"Without this constraint, objects embedded in another object are not valided. class SubObjectOne include AVD :: Validatable @[ Assert :: NotBlank ] getter string : String = \"\" end class SubObjectTwo include AVD :: Validatable @[ Assert :: NotBlank ] getter string : String = \"\" end class MyObject include AVD :: Validatable # This object is not validated when validating `MyObject`. getter sub_object_one : SubObjectOne = SubObjectOne . new # Have the validator also validate `SubObjectTwo` when validating `MyObject`. @[ Assert :: Valid ] getter sub_object_two : SubObjectTwo = SubObjectTwo . new end","title":"Usage"},{"location":"Validator/Constraints/Valid/#class-methods","text":"","title":"Class methods"},{"location":"Validator/Constraints/Valid/#Athena::Validator::Constraints::Valid.new(traverse,groups,payload)","text":"","title":".new"},{"location":"Validator/Constraints/Valid/#methods","text":"","title":"Methods"},{"location":"Validator/Constraints/Valid/#Athena::Validator::Constraints::Valid#traverse?()","text":"","title":"#traverse?"},{"location":"Validator/Constraints/Valid/#Athena::Validator::Constraints::Valid#validated_by()","text":"Returns the AVD::ConstraintValidator.class that should handle validating self .","title":"#validated_by"},{"location":"Validator/Constraints/Valid/Validator/","text":"struct Athena::Validator::Constraints::Valid::Validator inherits Athena::Validator::ConstraintValidator Methods #validate ( value : _ , constraint : AVD::Constraints::Valid ) : Nil :inherit:","title":"Validator"},{"location":"Validator/Constraints/Valid/Validator/#Athena::Validator::Constraints::Valid::Validator","text":"","title":"Validator"},{"location":"Validator/Constraints/Valid/Validator/#methods","text":"","title":"Methods"},{"location":"Validator/Constraints/Valid/Validator/#Athena::Validator::Constraints::Valid::Validator#validate(value,constraint)","text":":inherit:","title":"#validate"},{"location":"Validator/Exceptions/","text":"module Athena::Validator::Exceptions Contains all custom exceptions defined within Athena::Validator .","title":"Exceptions"},{"location":"Validator/Exceptions/#Athena::Validator::Exceptions","text":"Contains all custom exceptions defined within Athena::Validator .","title":"Exceptions"},{"location":"Validator/Exceptions/UnexpectedValueError/","text":"class Athena::Validator::Exceptions::UnexpectedValueError inherits Athena::Validator::Exceptions::ValidatorError Raised when an AVD::ConstraintValidatorInterface is unable to validate a value of an unsupported type. See AVD::ConstraintValidator#raise_invalid_type . Class methods .new ( value : _ , supported_types : String ) Methods #supported_types : String A string representing a union of the supported_type(s).","title":"UnexpectedValueError"},{"location":"Validator/Exceptions/UnexpectedValueError/#Athena::Validator::Exceptions::UnexpectedValueError","text":"Raised when an AVD::ConstraintValidatorInterface is unable to validate a value of an unsupported type. See AVD::ConstraintValidator#raise_invalid_type .","title":"UnexpectedValueError"},{"location":"Validator/Exceptions/UnexpectedValueError/#class-methods","text":"","title":"Class methods"},{"location":"Validator/Exceptions/UnexpectedValueError/#Athena::Validator::Exceptions::UnexpectedValueError.new(value,supported_types)","text":"","title":".new"},{"location":"Validator/Exceptions/UnexpectedValueError/#methods","text":"","title":"Methods"},{"location":"Validator/Exceptions/UnexpectedValueError/#Athena::Validator::Exceptions::UnexpectedValueError#supported_types()","text":"A string representing a union of the supported_type(s).","title":"#supported_types"},{"location":"Validator/Exceptions/ValidationFailed/","text":"class Athena::Validator::Exceptions::ValidationFailed inherits Athena::Routing::Exceptions::UnprocessableEntity Wraps an AVD::Violation::ConstraintViolationListInterface as an ART::Exceptions::UnprocessableEntity ; exposing the violations within the response body. Class methods .new ( violations : AVD::Violation::ConstraintViolationInterface | AVD::Violation::ConstraintViolationListInterface , cause : Exception ? = nil , headers : HTTP :: Headers = HTTP :: Headers . new ) Methods #to_json ( builder : JSON :: Builder ) : Nil Serializes self to JSON in the format of {\"code\":400,\"message\":\"Exception message\"} #violations : Athena::Validator::Violation::ConstraintViolationList","title":"ValidationFailed"},{"location":"Validator/Exceptions/ValidationFailed/#Athena::Validator::Exceptions::ValidationFailed","text":"Wraps an AVD::Violation::ConstraintViolationListInterface as an ART::Exceptions::UnprocessableEntity ; exposing the violations within the response body.","title":"ValidationFailed"},{"location":"Validator/Exceptions/ValidationFailed/#class-methods","text":"","title":"Class methods"},{"location":"Validator/Exceptions/ValidationFailed/#Athena::Validator::Exceptions::ValidationFailed.new(violations,cause,headers)","text":"","title":".new"},{"location":"Validator/Exceptions/ValidationFailed/#methods","text":"","title":"Methods"},{"location":"Validator/Exceptions/ValidationFailed/#Athena::Validator::Exceptions::ValidationFailed#to_json(builder)","text":"Serializes self to JSON in the format of {\"code\":400,\"message\":\"Exception message\"}","title":"#to_json"},{"location":"Validator/Exceptions/ValidationFailed/#Athena::Validator::Exceptions::ValidationFailed#violations()","text":"","title":"#violations"},{"location":"Validator/Exceptions/ValidatorError/","text":"class Athena::Validator::Exceptions::ValidatorError inherits Exception Base type of all Athena::Validator errors. Can be used to rescue any exception originating from Athena::Validator . Direct known subclasses Athena::Validator::Exceptions::UnexpectedValueError","title":"ValidatorError"},{"location":"Validator/Exceptions/ValidatorError/#Athena::Validator::Exceptions::ValidatorError","text":"Base type of all Athena::Validator errors. Can be used to rescue any exception originating from Athena::Validator .","title":"ValidatorError"},{"location":"Validator/Exceptions/ValidatorError/#direct-known-subclasses","text":"Athena::Validator::Exceptions::UnexpectedValueError","title":"Direct known subclasses"},{"location":"Validator/ExecutionContext/","text":"class Athena::Validator::ExecutionContext(Root) inherits Reference Basic implementation of AVD::ExecutionContextInterface . Included modules Athena::Validator::ExecutionContextInterface Class methods .new ( validator : AVD::Validator::ValidatorInterface , root : Root ) Methods #add_violation ( message : String , parameters : Hash ( String , String ) = {} of String => String ) : Nil Adds a violation with the provided message , and optionally parameters based on the node currently being validated. #add_violation ( message : String , code : String ) : Nil Adds a violation with the provided message and code #add_violation ( message : String , code : String , value : _ ) : Nil Adds a violation with the provided message , and code , value parameter. The provided value is added to the violations' parameters as \"{{ value }}\" . #build_violation ( message : String , parameters : Hash ( String , String ) = {} of String => String ) : AVD::Violation::ConstraintViolationBuilderInterface Returns an AVD::Violation::ConstraintViolationBuilderInterface with the provided message . Can be used to add additional information to the AVD::Violation::ConstraintViolationInterface being adding it to self . #build_violation ( message : String , code : String ) : AVD::Violation::ConstraintViolationBuilderInterface Returns an AVD::Violation::ConstraintViolationBuilderInterface with the provided message , and code . #build_violation ( message : String , code : String , value : _ ) : AVD::Violation::ConstraintViolationBuilderInterface Returns an AVD::Violation::ConstraintViolationBuilderInterface with the provided message , and code , and value . The provided value is added to the violations' parameters as \"{{ value }}\" . #class_name Returns the class that is currently being validated. #constraint : AVD::Constraint? Returns the AVD::Constraint that is currently being validated, if any. #group : String ? Returns the group that is currently being validated, if any. #metadata : AVD::Metadata::MetadataInterface? Returns an AVD::Metadata::MetadataInterface object for the value currently being validated. This would be an AVD::Metadata::PropertyMetadataInterface if the current value is an object, an AVD::Metadata::GenericMetadata if the current value is a plain value, and an AVD::Metadata::ClassMetadata if the current value value is an entire class. #object Returns the object that is currently being validated. #object_container : AVD :: Container The object that is currently being validated. #property_name : String ? Returns the property name of the node currently being validated. #property_path ( path : String = \"\" ) : String Returns the path to the property that is currently being validated. For example, given a Person object that has an Address property; the property path would be empty initially. When the address property is being validated the property_path would be address . When the street property of the related Address object is being validated the property_path would be address.street . This also works for collections of objects. If the Person object had multiple addresses, the property path when validating the first street of the first address would be addresses[0].street . #root : Root Returns the object initially passed to AVD::Validator::ValidatorInterface#validate . #validator : AVD::Validator::ValidatorInterface Returns a reference to an AVD::Validator::ValidatorInterface that can be used to validate additional constraints as part of another constraint. #value Returns the value that is currently being validated. #violations : AVD::Violation::ConstraintViolationList Returns the AVD::Violation::ConstraintViolationInterface instances generated by the validator thus far.","title":"ExecutionContext"},{"location":"Validator/ExecutionContext/#Athena::Validator::ExecutionContext","text":"Basic implementation of AVD::ExecutionContextInterface .","title":"ExecutionContext"},{"location":"Validator/ExecutionContext/#included-modules","text":"Athena::Validator::ExecutionContextInterface","title":"Included modules"},{"location":"Validator/ExecutionContext/#class-methods","text":"","title":"Class methods"},{"location":"Validator/ExecutionContext/#Athena::Validator::ExecutionContext.new(validator,root)","text":"","title":".new"},{"location":"Validator/ExecutionContext/#methods","text":"","title":"Methods"},{"location":"Validator/ExecutionContext/#Athena::Validator::ExecutionContext#add_violation(message,parameters)","text":"Adds a violation with the provided message , and optionally parameters based on the node currently being validated.","title":"#add_violation"},{"location":"Validator/ExecutionContext/#Athena::Validator::ExecutionContext#build_violation(message,parameters)","text":"Returns an AVD::Violation::ConstraintViolationBuilderInterface with the provided message . Can be used to add additional information to the AVD::Violation::ConstraintViolationInterface being adding it to self .","title":"#build_violation"},{"location":"Validator/ExecutionContext/#Athena::Validator::ExecutionContext#class_name()","text":"Returns the class that is currently being validated.","title":"#class_name"},{"location":"Validator/ExecutionContext/#Athena::Validator::ExecutionContext#constraint()","text":"Returns the AVD::Constraint that is currently being validated, if any.","title":"#constraint"},{"location":"Validator/ExecutionContext/#Athena::Validator::ExecutionContext#group()","text":"Returns the group that is currently being validated, if any.","title":"#group"},{"location":"Validator/ExecutionContext/#Athena::Validator::ExecutionContext#metadata()","text":"Returns an AVD::Metadata::MetadataInterface object for the value currently being validated. This would be an AVD::Metadata::PropertyMetadataInterface if the current value is an object, an AVD::Metadata::GenericMetadata if the current value is a plain value, and an AVD::Metadata::ClassMetadata if the current value value is an entire class.","title":"#metadata"},{"location":"Validator/ExecutionContext/#Athena::Validator::ExecutionContext#object()","text":"Returns the object that is currently being validated.","title":"#object"},{"location":"Validator/ExecutionContext/#Athena::Validator::ExecutionContext#object_container()","text":"The object that is currently being validated.","title":"#object_container"},{"location":"Validator/ExecutionContext/#Athena::Validator::ExecutionContext#property_name()","text":"Returns the property name of the node currently being validated.","title":"#property_name"},{"location":"Validator/ExecutionContext/#Athena::Validator::ExecutionContext#property_path(path)","text":"Returns the path to the property that is currently being validated. For example, given a Person object that has an Address property; the property path would be empty initially. When the address property is being validated the property_path would be address . When the street property of the related Address object is being validated the property_path would be address.street . This also works for collections of objects. If the Person object had multiple addresses, the property path when validating the first street of the first address would be addresses[0].street .","title":"#property_path"},{"location":"Validator/ExecutionContext/#Athena::Validator::ExecutionContext#root()","text":"Returns the object initially passed to AVD::Validator::ValidatorInterface#validate .","title":"#root"},{"location":"Validator/ExecutionContext/#Athena::Validator::ExecutionContext#validator()","text":"Returns a reference to an AVD::Validator::ValidatorInterface that can be used to validate additional constraints as part of another constraint.","title":"#validator"},{"location":"Validator/ExecutionContext/#Athena::Validator::ExecutionContext#value()","text":"Returns the value that is currently being validated.","title":"#value"},{"location":"Validator/ExecutionContext/#Athena::Validator::ExecutionContext#violations()","text":"Returns the AVD::Violation::ConstraintViolationInterface instances generated by the validator thus far.","title":"#violations"},{"location":"Validator/ExecutionContextInterface/","text":"module Athena::Validator::ExecutionContextInterface Stores contextual data related to the current validation run. This includes the violations generated so far, the current constraint, value being validated, etc. Adding Violations As mentioned in the AVD::ConstraintValidatorInterface documentation, violations are not returned from the AVD::ConstraintValidatorInterface#validate method. Instead they are added to the AVD::ConstraintValidatorInterface#context instance. The simplest way to do so is via the #add_violation method, which accepts the violation message, and any parameters that should be used to render the message. Additional overloads exist to make adding a value with a specific message, and code, or message, code, and {{ value }} placeholder value easier. Building violations In some cases you may wish to add additional data to the AVD::Violation::ConstraintViolationInterface before adding it to self . To do this, you can also use the #build_violation method, which returns an AVD::Violation::ConstraintViolationBuilderInterface that can be used to construct a violation, with an easier API. Direct including types Athena::Validator::ExecutionContext(Root) Methods abstract #add_violation ( message : String , code : String , value : _ ) : Nil Adds a violation with the provided message , and code , value parameter. The provided value is added to the violations' parameters as \"{{ value }}\" . abstract #add_violation ( message : String , parameters : Hash ( String , String ) = {} of String => String ) : Nil Adds a violation with the provided message , and optionally parameters based on the node currently being validated. abstract #add_violation ( message : String , code : String ) : Nil Adds a violation with the provided message and code abstract #build_violation ( message : String , code : String , value : _ ) : AVD::Violation::ConstraintViolationBuilderInterface Returns an AVD::Violation::ConstraintViolationBuilderInterface with the provided message , and code , and value . The provided value is added to the violations' parameters as \"{{ value }}\" . abstract #build_violation ( message : String , parameters : Hash ( String , String ) = {} of String => String ) : AVD::Violation::ConstraintViolationBuilderInterface Returns an AVD::Violation::ConstraintViolationBuilderInterface with the provided message . Can be used to add additional information to the AVD::Violation::ConstraintViolationInterface being adding it to self . abstract #build_violation ( message : String , code : String ) : AVD::Violation::ConstraintViolationBuilderInterface Returns an AVD::Violation::ConstraintViolationBuilderInterface with the provided message , and code . abstract #class_name Returns the class that is currently being validated. abstract #constraint : AVD::Constraint? Returns the AVD::Constraint that is currently being validated, if any. abstract #group : String ? Returns the group that is currently being validated, if any. abstract #metadata : AVD::Metadata::MetadataInterface? Returns an AVD::Metadata::MetadataInterface object for the value currently being validated. This would be an AVD::Metadata::PropertyMetadataInterface if the current value is an object, an AVD::Metadata::GenericMetadata if the current value is a plain value, and an AVD::Metadata::ClassMetadata if the current value value is an entire class. abstract #object Returns the object that is currently being validated. abstract #property_name : String ? Returns the property name of the node currently being validated. abstract #property_path : String Returns the path to the property that is currently being validated. For example, given a Person object that has an Address property; the property path would be empty initially. When the address property is being validated the property_path would be address . When the street property of the related Address object is being validated the property_path would be address.street . This also works for collections of objects. If the Person object had multiple addresses, the property path when validating the first street of the first address would be addresses[0].street . abstract #root Returns the object initially passed to AVD::Validator::ValidatorInterface#validate . abstract #validator : AVD::Validator::ValidatorInterface Returns a reference to an AVD::Validator::ValidatorInterface that can be used to validate additional constraints as part of another constraint. abstract #value Returns the value that is currently being validated. abstract #violations : AVD::Violation::ConstraintViolationListInterface Returns the AVD::Violation::ConstraintViolationInterface instances generated by the validator thus far.","title":"ExecutionContextInterface"},{"location":"Validator/ExecutionContextInterface/#Athena::Validator::ExecutionContextInterface","text":"Stores contextual data related to the current validation run. This includes the violations generated so far, the current constraint, value being validated, etc.","title":"ExecutionContextInterface"},{"location":"Validator/ExecutionContextInterface/#Athena::Validator::ExecutionContextInterface--adding-violations","text":"As mentioned in the AVD::ConstraintValidatorInterface documentation, violations are not returned from the AVD::ConstraintValidatorInterface#validate method. Instead they are added to the AVD::ConstraintValidatorInterface#context instance. The simplest way to do so is via the #add_violation method, which accepts the violation message, and any parameters that should be used to render the message. Additional overloads exist to make adding a value with a specific message, and code, or message, code, and {{ value }} placeholder value easier.","title":"Adding Violations"},{"location":"Validator/ExecutionContextInterface/#Athena::Validator::ExecutionContextInterface--building-violations","text":"In some cases you may wish to add additional data to the AVD::Violation::ConstraintViolationInterface before adding it to self . To do this, you can also use the #build_violation method, which returns an AVD::Violation::ConstraintViolationBuilderInterface that can be used to construct a violation, with an easier API.","title":"Building violations"},{"location":"Validator/ExecutionContextInterface/#direct-including-types","text":"Athena::Validator::ExecutionContext(Root)","title":"Direct including types"},{"location":"Validator/ExecutionContextInterface/#methods","text":"","title":"Methods"},{"location":"Validator/ExecutionContextInterface/#Athena::Validator::ExecutionContextInterface#add_violation(message,code,value)","text":"Adds a violation with the provided message , and code , value parameter. The provided value is added to the violations' parameters as \"{{ value }}\" .","title":"#add_violation"},{"location":"Validator/ExecutionContextInterface/#Athena::Validator::ExecutionContextInterface#build_violation(message,code,value)","text":"Returns an AVD::Violation::ConstraintViolationBuilderInterface with the provided message , and code , and value . The provided value is added to the violations' parameters as \"{{ value }}\" .","title":"#build_violation"},{"location":"Validator/ExecutionContextInterface/#Athena::Validator::ExecutionContextInterface#class_name()","text":"Returns the class that is currently being validated.","title":"#class_name"},{"location":"Validator/ExecutionContextInterface/#Athena::Validator::ExecutionContextInterface#constraint()","text":"Returns the AVD::Constraint that is currently being validated, if any.","title":"#constraint"},{"location":"Validator/ExecutionContextInterface/#Athena::Validator::ExecutionContextInterface#group()","text":"Returns the group that is currently being validated, if any.","title":"#group"},{"location":"Validator/ExecutionContextInterface/#Athena::Validator::ExecutionContextInterface#metadata()","text":"Returns an AVD::Metadata::MetadataInterface object for the value currently being validated. This would be an AVD::Metadata::PropertyMetadataInterface if the current value is an object, an AVD::Metadata::GenericMetadata if the current value is a plain value, and an AVD::Metadata::ClassMetadata if the current value value is an entire class.","title":"#metadata"},{"location":"Validator/ExecutionContextInterface/#Athena::Validator::ExecutionContextInterface#object()","text":"Returns the object that is currently being validated.","title":"#object"},{"location":"Validator/ExecutionContextInterface/#Athena::Validator::ExecutionContextInterface#property_name()","text":"Returns the property name of the node currently being validated.","title":"#property_name"},{"location":"Validator/ExecutionContextInterface/#Athena::Validator::ExecutionContextInterface#property_path()","text":"Returns the path to the property that is currently being validated. For example, given a Person object that has an Address property; the property path would be empty initially. When the address property is being validated the property_path would be address . When the street property of the related Address object is being validated the property_path would be address.street . This also works for collections of objects. If the Person object had multiple addresses, the property path when validating the first street of the first address would be addresses[0].street .","title":"#property_path"},{"location":"Validator/ExecutionContextInterface/#Athena::Validator::ExecutionContextInterface#root()","text":"Returns the object initially passed to AVD::Validator::ValidatorInterface#validate .","title":"#root"},{"location":"Validator/ExecutionContextInterface/#Athena::Validator::ExecutionContextInterface#validator()","text":"Returns a reference to an AVD::Validator::ValidatorInterface that can be used to validate additional constraints as part of another constraint.","title":"#validator"},{"location":"Validator/ExecutionContextInterface/#Athena::Validator::ExecutionContextInterface#value()","text":"Returns the value that is currently being validated.","title":"#value"},{"location":"Validator/ExecutionContextInterface/#Athena::Validator::ExecutionContextInterface#violations()","text":"Returns the AVD::Violation::ConstraintViolationInterface instances generated by the validator thus far.","title":"#violations"},{"location":"Validator/Metadata/","text":"module Athena::Validator::Metadata Contains types used to store metadata associated with a given AVD::Validatable instance. Most likely you won't have to work any of these directly. However if you are adding constraints manually to properties using the self.load_metadata method, you should be familiar with AVD::Metadata::ClassMetadata .","title":"Metadata"},{"location":"Validator/Metadata/#Athena::Validator::Metadata","text":"Contains types used to store metadata associated with a given AVD::Validatable instance. Most likely you won't have to work any of these directly. However if you are adding constraints manually to properties using the self.load_metadata method, you should be familiar with AVD::Metadata::ClassMetadata .","title":"Metadata"},{"location":"Validator/Metadata/CascadingStrategy/","text":"enum Athena::Validator::Metadata::CascadingStrategy Determines whether an object should be cascaded. If cascading is enabled, the validator will also validate embeded objects. Members None = 0 Cascade = 1 Methods #cascade? #none?","title":"CascadingStrategy"},{"location":"Validator/Metadata/CascadingStrategy/#Athena::Validator::Metadata::CascadingStrategy","text":"Determines whether an object should be cascaded. If cascading is enabled, the validator will also validate embeded objects.","title":"CascadingStrategy"},{"location":"Validator/Metadata/CascadingStrategy/#members","text":"","title":"Members"},{"location":"Validator/Metadata/CascadingStrategy/#Athena::Validator::Metadata::CascadingStrategy::None","text":"","title":"None"},{"location":"Validator/Metadata/CascadingStrategy/#Athena::Validator::Metadata::CascadingStrategy::Cascade","text":"","title":"Cascade"},{"location":"Validator/Metadata/CascadingStrategy/#methods","text":"","title":"Methods"},{"location":"Validator/Metadata/CascadingStrategy/#Athena::Validator::Metadata::CascadingStrategy#cascade?()","text":"","title":"#cascade?"},{"location":"Validator/Metadata/CascadingStrategy/#Athena::Validator::Metadata::CascadingStrategy#none?()","text":"","title":"#none?"},{"location":"Validator/Metadata/ClassMetadata/","text":"class Athena::Validator::Metadata::ClassMetadata(T) inherits Reference Represents metadata associated with an AVD::Validatable instance. self is lazily initialized and cached at the class level. Includes metadata about the class; such as its name, constraints, etc. Included modules Athena::Validator::Metadata::GenericMetadata Class methods .build : self Builds self , auto registering any annotation based annotations on T , as well as those registered via T.load_metadata . .new Methods #add_constraint ( constraints : Array ( AVD::Constraint )) : self Adds each of the provided constraints to self . #add_constraint ( constraint : AVD::Constraint ) : self Adds the provided constraint to self 's #constraints array. Sets #cascading_strategy to AVD::Metadata::CascadingStrategy::Cascade if the constraint is AVD::Constraints::Valid . Also adds the #class_name based group via AVD::Constraint#add_implicit_group . #add_getter_constraint ( method_name : String , constraint : AVD::Constraint ) : self Adds the provided constraint to the provided method_name . #add_property_constraint ( property_name : String , constraints : Array ( AVD::Constraint )) : self Adds each of the provided constraints to the provided property_name . #add_property_constraint ( property_name : String , constraint : AVD::Constraint ) : self Adds the provided constraint to the provided property_name . #add_property_constraints ( property_hash : Hash ( String , AVD::Constraint | Array ( AVD::Constraint ))) : self Adds a hash of constraints to self , where the keys represent the property names, and the value is the constraint/array of constraints to add. #class_name : T . class #constrained_properties : Array ( String ) Returns an array of the properties who self has constraints defined for. #default_group : String The #class_name based group for self . #group_sequence : AVD::Constraints::GroupSequence? The AVD::Constraints::GroupSequence used by self , if any. #group_sequence= ( sequence : Array ( String ) | AVD::Constraints::GroupSequence ) : self Sets the AVD::Constraints::GroupSequence that should be used for self . Raises an ArgumentError if self is an AVD::Constraints::GroupSequence::Provider , the sequence contains AVD::Constraint::DEFAULT_GROUP , or the #class_name based group is missing. #group_sequence_provider= ( active : Bool ) : Nil Denotes self as a AVD::Constraints::GroupSequence::Provider . #has_property_metadata? ( property_name : String ) : Bool Returns true if self has property metadata for the provided property_name . #name : String ? #property_metadata ( property_name : String ) : Array ( AVD::Metadata::PropertyMetadataInterface ) Returns an AVD::Metadata::PropertyMetadataInterface instance for the provided property_name , if any.","title":"ClassMetadata"},{"location":"Validator/Metadata/ClassMetadata/#Athena::Validator::Metadata::ClassMetadata","text":"Represents metadata associated with an AVD::Validatable instance. self is lazily initialized and cached at the class level. Includes metadata about the class; such as its name, constraints, etc.","title":"ClassMetadata"},{"location":"Validator/Metadata/ClassMetadata/#included-modules","text":"Athena::Validator::Metadata::GenericMetadata","title":"Included modules"},{"location":"Validator/Metadata/ClassMetadata/#class-methods","text":"","title":"Class methods"},{"location":"Validator/Metadata/ClassMetadata/#Athena::Validator::Metadata::ClassMetadata.build()","text":"Builds self , auto registering any annotation based annotations on T , as well as those registered via T.load_metadata .","title":".build"},{"location":"Validator/Metadata/ClassMetadata/#Athena::Validator::Metadata::ClassMetadata.new()","text":"","title":".new"},{"location":"Validator/Metadata/ClassMetadata/#methods","text":"","title":"Methods"},{"location":"Validator/Metadata/ClassMetadata/#Athena::Validator::Metadata::ClassMetadata#add_constraint(constraints)","text":"Adds each of the provided constraints to self .","title":"#add_constraint"},{"location":"Validator/Metadata/ClassMetadata/#Athena::Validator::Metadata::ClassMetadata#add_getter_constraint(method_name,constraint)","text":"Adds the provided constraint to the provided method_name .","title":"#add_getter_constraint"},{"location":"Validator/Metadata/ClassMetadata/#Athena::Validator::Metadata::ClassMetadata#add_property_constraint(property_name,constraints)","text":"Adds each of the provided constraints to the provided property_name .","title":"#add_property_constraint"},{"location":"Validator/Metadata/ClassMetadata/#Athena::Validator::Metadata::ClassMetadata#add_property_constraints(property_hash)","text":"Adds a hash of constraints to self , where the keys represent the property names, and the value is the constraint/array of constraints to add.","title":"#add_property_constraints"},{"location":"Validator/Metadata/ClassMetadata/#Athena::Validator::Metadata::ClassMetadata#class_name()","text":"","title":"#class_name"},{"location":"Validator/Metadata/ClassMetadata/#Athena::Validator::Metadata::ClassMetadata#constrained_properties()","text":"Returns an array of the properties who self has constraints defined for.","title":"#constrained_properties"},{"location":"Validator/Metadata/ClassMetadata/#Athena::Validator::Metadata::ClassMetadata#default_group()","text":"The #class_name based group for self .","title":"#default_group"},{"location":"Validator/Metadata/ClassMetadata/#Athena::Validator::Metadata::ClassMetadata#group_sequence()","text":"The AVD::Constraints::GroupSequence used by self , if any.","title":"#group_sequence"},{"location":"Validator/Metadata/ClassMetadata/#Athena::Validator::Metadata::ClassMetadata#group_sequence=(sequence)","text":"Sets the AVD::Constraints::GroupSequence that should be used for self . Raises an ArgumentError if self is an AVD::Constraints::GroupSequence::Provider , the sequence contains AVD::Constraint::DEFAULT_GROUP , or the #class_name based group is missing.","title":"#group_sequence="},{"location":"Validator/Metadata/ClassMetadata/#Athena::Validator::Metadata::ClassMetadata#group_sequence_provider=(active)","text":"Denotes self as a AVD::Constraints::GroupSequence::Provider .","title":"#group_sequence_provider="},{"location":"Validator/Metadata/ClassMetadata/#Athena::Validator::Metadata::ClassMetadata#has_property_metadata?(property_name)","text":"Returns true if self has property metadata for the provided property_name .","title":"#has_property_metadata?"},{"location":"Validator/Metadata/ClassMetadata/#Athena::Validator::Metadata::ClassMetadata#name()","text":"","title":"#name"},{"location":"Validator/Metadata/ClassMetadata/#Athena::Validator::Metadata::ClassMetadata#property_metadata(property_name)","text":"Returns an AVD::Metadata::PropertyMetadataInterface instance for the provided property_name , if any.","title":"#property_metadata"},{"location":"Validator/Metadata/GenericMetadata/","text":"module Athena::Validator::Metadata::GenericMetadata Included modules Athena::Validator::Metadata::MetadataInterface Direct including types Athena::Validator::Metadata::ClassMetadata(T) Athena::Validator::Metadata::GetterMetadata(EntityType, MethodIdx) Athena::Validator::Metadata::PropertyMetadata(EntityType, PropertyIdx) Methods #add_constraint ( constraint : AVD::Constraint ) : AVD::Metadata::GenericMetadata Adds the provided constraint to self 's #constraints array. Sets #cascading_strategy to AVD::Metadata::CascadingStrategy::Cascade if the constraint is AVD::Constraints::Valid . #add_constraints ( constraints : Array ( AVD::Constraint )) : AVD::Metadata::GenericMetadata Adds each of the provided constraints to self . #cascading_strategy : AVD::Metadata::CascadingStrategy Returns the AVD::Metadata::CascadingStrategy for self . #constraints : Array ( AVD::Constraint ) #find_constraints ( group : String ) : Array ( AVD::Constraint ) Returns an array of all constraints in the provided group .","title":"GenericMetadata"},{"location":"Validator/Metadata/GenericMetadata/#Athena::Validator::Metadata::GenericMetadata","text":"","title":"GenericMetadata"},{"location":"Validator/Metadata/GenericMetadata/#included-modules","text":"Athena::Validator::Metadata::MetadataInterface","title":"Included modules"},{"location":"Validator/Metadata/GenericMetadata/#direct-including-types","text":"Athena::Validator::Metadata::ClassMetadata(T) Athena::Validator::Metadata::GetterMetadata(EntityType, MethodIdx) Athena::Validator::Metadata::PropertyMetadata(EntityType, PropertyIdx)","title":"Direct including types"},{"location":"Validator/Metadata/GenericMetadata/#methods","text":"","title":"Methods"},{"location":"Validator/Metadata/GenericMetadata/#Athena::Validator::Metadata::GenericMetadata#add_constraint(constraint)","text":"Adds the provided constraint to self 's #constraints array. Sets #cascading_strategy to AVD::Metadata::CascadingStrategy::Cascade if the constraint is AVD::Constraints::Valid .","title":"#add_constraint"},{"location":"Validator/Metadata/GenericMetadata/#Athena::Validator::Metadata::GenericMetadata#add_constraints(constraints)","text":"Adds each of the provided constraints to self .","title":"#add_constraints"},{"location":"Validator/Metadata/GenericMetadata/#Athena::Validator::Metadata::GenericMetadata#cascading_strategy()","text":"Returns the AVD::Metadata::CascadingStrategy for self .","title":"#cascading_strategy"},{"location":"Validator/Metadata/GenericMetadata/#Athena::Validator::Metadata::GenericMetadata#constraints()","text":"","title":"#constraints"},{"location":"Validator/Metadata/GenericMetadata/#Athena::Validator::Metadata::GenericMetadata#find_constraints(group)","text":"Returns an array of all constraints in the provided group .","title":"#find_constraints"},{"location":"Validator/Metadata/GetterMetadata/","text":"class Athena::Validator::Metadata::GetterMetadata(EntityType, MethodIdx) inherits Reference Included modules Athena::Validator::Metadata::GenericMetadata Athena::Validator::Metadata::PropertyMetadataInterface Class methods .new ( name : String ) Methods #class_name : EntityType . class Returns the class the method self represents, belongs to. #name : String Returns the name of the member represented by self .","title":"GetterMetadata"},{"location":"Validator/Metadata/GetterMetadata/#Athena::Validator::Metadata::GetterMetadata","text":"","title":"GetterMetadata"},{"location":"Validator/Metadata/GetterMetadata/#included-modules","text":"Athena::Validator::Metadata::GenericMetadata Athena::Validator::Metadata::PropertyMetadataInterface","title":"Included modules"},{"location":"Validator/Metadata/GetterMetadata/#class-methods","text":"","title":"Class methods"},{"location":"Validator/Metadata/GetterMetadata/#Athena::Validator::Metadata::GetterMetadata.new(name)","text":"","title":".new"},{"location":"Validator/Metadata/GetterMetadata/#methods","text":"","title":"Methods"},{"location":"Validator/Metadata/GetterMetadata/#Athena::Validator::Metadata::GetterMetadata#class_name()","text":"Returns the class the method self represents, belongs to.","title":"#class_name"},{"location":"Validator/Metadata/GetterMetadata/#Athena::Validator::Metadata::GetterMetadata#name()","text":"Returns the name of the member represented by self .","title":"#name"},{"location":"Validator/Metadata/MetadataFactory/","text":"class Athena::Validator::Metadata::MetadataFactory inherits Reference Basic implementation of AVD::Metadata::MetadataFactoryInterface . Included modules Athena::Validator::Metadata::MetadataFactoryInterface Methods #metadata ( object : AVD::Validatable ) : AVD::Metadata::ClassMetadata Returns an AVD::Metadata::ClassMetadata instance for the related AVD::Validatable object .","title":"MetadataFactory"},{"location":"Validator/Metadata/MetadataFactory/#Athena::Validator::Metadata::MetadataFactory","text":"Basic implementation of AVD::Metadata::MetadataFactoryInterface .","title":"MetadataFactory"},{"location":"Validator/Metadata/MetadataFactory/#included-modules","text":"Athena::Validator::Metadata::MetadataFactoryInterface","title":"Included modules"},{"location":"Validator/Metadata/MetadataFactory/#methods","text":"","title":"Methods"},{"location":"Validator/Metadata/MetadataFactory/#Athena::Validator::Metadata::MetadataFactory#metadata(object)","text":"Returns an AVD::Metadata::ClassMetadata instance for the related AVD::Validatable object .","title":"#metadata"},{"location":"Validator/Metadata/MetadataFactoryInterface/","text":"module Athena::Validator::Metadata::MetadataFactoryInterface Direct including types Athena::Validator::Metadata::MetadataFactory Athena::Validator::Spec::MockMetadataFactory(T1, T2, T3, T4, T5) Methods abstract #metadata ( object : AVD::Validatable ) : AVD::Metadata::ClassMetadata Returns an AVD::Metadata::ClassMetadata instance for the related AVD::Validatable object .","title":"MetadataFactoryInterface"},{"location":"Validator/Metadata/MetadataFactoryInterface/#Athena::Validator::Metadata::MetadataFactoryInterface","text":"","title":"MetadataFactoryInterface"},{"location":"Validator/Metadata/MetadataFactoryInterface/#direct-including-types","text":"Athena::Validator::Metadata::MetadataFactory Athena::Validator::Spec::MockMetadataFactory(T1, T2, T3, T4, T5)","title":"Direct including types"},{"location":"Validator/Metadata/MetadataFactoryInterface/#methods","text":"","title":"Methods"},{"location":"Validator/Metadata/MetadataFactoryInterface/#Athena::Validator::Metadata::MetadataFactoryInterface#metadata(object)","text":"Returns an AVD::Metadata::ClassMetadata instance for the related AVD::Validatable object .","title":"#metadata"},{"location":"Validator/Metadata/MetadataInterface/","text":"module Athena::Validator::Metadata::MetadataInterface Direct including types Athena::Validator::Metadata::GenericMetadata Athena::Validator::Metadata::PropertyMetadataInterface Methods abstract #cascading_strategy : AVD::Metadata::CascadingStrategy Returns the AVD::Metadata::CascadingStrategy for self . abstract #constraints : Array ( AVD::Constraint ) abstract #find_constraints ( group : String ) : Array ( AVD::Constraint ) Returns an array of all constraints in the provided group .","title":"MetadataInterface"},{"location":"Validator/Metadata/MetadataInterface/#Athena::Validator::Metadata::MetadataInterface","text":"","title":"MetadataInterface"},{"location":"Validator/Metadata/MetadataInterface/#direct-including-types","text":"Athena::Validator::Metadata::GenericMetadata Athena::Validator::Metadata::PropertyMetadataInterface","title":"Direct including types"},{"location":"Validator/Metadata/MetadataInterface/#methods","text":"","title":"Methods"},{"location":"Validator/Metadata/MetadataInterface/#Athena::Validator::Metadata::MetadataInterface#cascading_strategy()","text":"Returns the AVD::Metadata::CascadingStrategy for self .","title":"#cascading_strategy"},{"location":"Validator/Metadata/MetadataInterface/#Athena::Validator::Metadata::MetadataInterface#constraints()","text":"","title":"#constraints"},{"location":"Validator/Metadata/MetadataInterface/#Athena::Validator::Metadata::MetadataInterface#find_constraints(group)","text":"Returns an array of all constraints in the provided group .","title":"#find_constraints"},{"location":"Validator/Metadata/PropertyMetadata/","text":"class Athena::Validator::Metadata::PropertyMetadata(EntityType, PropertyIdx) inherits Reference Included modules Athena::Validator::Metadata::GenericMetadata Athena::Validator::Metadata::PropertyMetadataInterface Class methods .new ( name : String ) Methods #class_name : EntityType . class Returns the class the property self represents, belongs to. #name : String Returns the name of the member represented by self .","title":"PropertyMetadata"},{"location":"Validator/Metadata/PropertyMetadata/#Athena::Validator::Metadata::PropertyMetadata","text":"","title":"PropertyMetadata"},{"location":"Validator/Metadata/PropertyMetadata/#included-modules","text":"Athena::Validator::Metadata::GenericMetadata Athena::Validator::Metadata::PropertyMetadataInterface","title":"Included modules"},{"location":"Validator/Metadata/PropertyMetadata/#class-methods","text":"","title":"Class methods"},{"location":"Validator/Metadata/PropertyMetadata/#Athena::Validator::Metadata::PropertyMetadata.new(name)","text":"","title":".new"},{"location":"Validator/Metadata/PropertyMetadata/#methods","text":"","title":"Methods"},{"location":"Validator/Metadata/PropertyMetadata/#Athena::Validator::Metadata::PropertyMetadata#class_name()","text":"Returns the class the property self represents, belongs to.","title":"#class_name"},{"location":"Validator/Metadata/PropertyMetadata/#Athena::Validator::Metadata::PropertyMetadata#name()","text":"Returns the name of the member represented by self .","title":"#name"},{"location":"Validator/Metadata/PropertyMetadataInterface/","text":"module Athena::Validator::Metadata::PropertyMetadataInterface Stores metadata associated with a specific property. Included modules Athena::Validator::Metadata::MetadataInterface Direct including types Athena::Validator::Metadata::GetterMetadata(EntityType, MethodIdx) Athena::Validator::Metadata::PropertyMetadata(EntityType, PropertyIdx) Methods abstract #name : String Returns the name of the member represented by self .","title":"PropertyMetadataInterface"},{"location":"Validator/Metadata/PropertyMetadataInterface/#Athena::Validator::Metadata::PropertyMetadataInterface","text":"Stores metadata associated with a specific property.","title":"PropertyMetadataInterface"},{"location":"Validator/Metadata/PropertyMetadataInterface/#included-modules","text":"Athena::Validator::Metadata::MetadataInterface","title":"Included modules"},{"location":"Validator/Metadata/PropertyMetadataInterface/#direct-including-types","text":"Athena::Validator::Metadata::GetterMetadata(EntityType, MethodIdx) Athena::Validator::Metadata::PropertyMetadata(EntityType, PropertyIdx)","title":"Direct including types"},{"location":"Validator/Metadata/PropertyMetadataInterface/#methods","text":"","title":"Methods"},{"location":"Validator/Metadata/PropertyMetadataInterface/#Athena::Validator::Metadata::PropertyMetadataInterface#name()","text":"Returns the name of the member represented by self .","title":"#name"},{"location":"Validator/PropertyPath/","text":"module Athena::Validator::PropertyPath Utility type for working with property paths. Class methods .append ( base_path : String , sub_path : String ) : String Appends the provided sub_path to the provided base_path based on the following rules: If the base path is empty, the sub path is returned as is. If the base path is not empty, and the sub path starts with an [ , the concatenation of the two paths is returned. If the base path is not empty, and the sub path does not start with an [ , the concatenation of the two paths is returned, separated by a . . AVD :: PropertyPath . append \"\" , \"sub_path\" # => \"sub_path\" AVD :: PropertyPath . append \"base_path\" , \"[0]\" # => \"base_path[0]\" AVD :: PropertyPath . append \"base_path\" , \"sub_path\" # => \"base_path.sub_path\"","title":"PropertyPath"},{"location":"Validator/PropertyPath/#Athena::Validator::PropertyPath","text":"Utility type for working with property paths.","title":"PropertyPath"},{"location":"Validator/PropertyPath/#class-methods","text":"","title":"Class methods"},{"location":"Validator/PropertyPath/#Athena::Validator::PropertyPath.append(base_path,sub_path)","text":"Appends the provided sub_path to the provided base_path based on the following rules: If the base path is empty, the sub path is returned as is. If the base path is not empty, and the sub path starts with an [ , the concatenation of the two paths is returned. If the base path is not empty, and the sub path does not start with an [ , the concatenation of the two paths is returned, separated by a . . AVD :: PropertyPath . append \"\" , \"sub_path\" # => \"sub_path\" AVD :: PropertyPath . append \"base_path\" , \"[0]\" # => \"base_path[0]\" AVD :: PropertyPath . append \"base_path\" , \"sub_path\" # => \"base_path.sub_path\"","title":".append"},{"location":"Validator/ServiceConstraintValidator/","text":"abstract struct Athena::Validator::ServiceConstraintValidator inherits Athena::Validator::ConstraintValidator Extension of AVD::ConstraintValidator used to denote a service validator that can be used with Athena Dependency Injection .","title":"ServiceConstraintValidator"},{"location":"Validator/ServiceConstraintValidator/#Athena::Validator::ServiceConstraintValidator","text":"Extension of AVD::ConstraintValidator used to denote a service validator that can be used with Athena Dependency Injection .","title":"ServiceConstraintValidator"},{"location":"Validator/Spec/","text":"module Athena::Validator::Spec A set of testing utilities/types to aid in testing Athena::Validator related types. Getting Started Require this module in your spec_helper.cr file. # This also requires \"spec\" and \"athena-spec\". require \"athena-validator/spec\" Add Athena::Spec as a development dependency, then run a shards install . See the individual types for more information.","title":"Spec"},{"location":"Validator/Spec/#Athena::Validator::Spec","text":"A set of testing utilities/types to aid in testing Athena::Validator related types.","title":"Spec"},{"location":"Validator/Spec/#Athena::Validator::Spec--getting-started","text":"Require this module in your spec_helper.cr file. # This also requires \"spec\" and \"athena-spec\". require \"athena-validator/spec\" Add Athena::Spec as a development dependency, then run a shards install . See the individual types for more information.","title":"Getting Started"},{"location":"Validator/Spec/ComparisonConstraintValidatorTestCase/","text":"abstract struct Athena::Validator::Spec::ComparisonConstraintValidatorTestCase inherits Athena::Validator::Spec::ConstraintValidatorTestCase Extension of AVD::Spec::ConstraintValidatorTestCase used for testing AVD::Constraints::AbstractComparison based constraints. Example Using the spec from AVD::Constraints::EqualTo : # Makes for a bit less typing when needing to reference the constraint. private alias CONSTRAINT = AVD :: Constraints :: EqualTo # Define our test case inheriting from the abstract `ComparisonConstraintValidatorTestCase`. struct EqualToValidatorTest < AVD :: Spec :: ComparisonConstraintValidatorTestCase # Returns a Tuple of Tuples representing valid comparisons. # The first item is the actual value and the second item is the expected value. def valid_comparisons : Tuple { { 3 , 3 }, { 'a' , 'a' }, { \"a\" , \"a\" }, { Time . utc ( 2020 , 4 , 7 ), Time . utc ( 2020 , 4 , 7 )}, { nil , false }, } end # Returns a Tuple of Tuples representing invalid comparisons. # The first item is the actual value and the second item is the expected value. def invalid_comparisons : Tuple { { 1 , 3 }, { 'b' , 'a' }, { \"b\" , \"a\" }, { Time . utc ( 2020 , 4 , 8 ), Time . utc ( 2020 , 4 , 7 )}, } end # The error code related to the current CONSTRAINT. def error_code : String CONSTRAINT :: NOT_EQUAL_ERROR end # Implement some abstract defs to return the validator and constraint class. def create_validator : AVD :: ConstraintValidatorInterface CONSTRAINT :: Validator . new end def constraint_class : AVD :: Constraint . class CONSTRAINT end end Methods abstract #error_code : String The code for the current constraint. abstract #invalid_comparisons : Tuple A Tuple of tuples representing invalid comparisons. #test_invalid_comparisons ( actual , expected : T ) : Nil forall T #test_valid_comparisons ( actual , expected ) : Nil abstract #valid_comparisons : Tuple A Tuple of tuples representing valid comparisons.","title":"ComparisonConstraintValidatorTestCase"},{"location":"Validator/Spec/ComparisonConstraintValidatorTestCase/#Athena::Validator::Spec::ComparisonConstraintValidatorTestCase","text":"Extension of AVD::Spec::ConstraintValidatorTestCase used for testing AVD::Constraints::AbstractComparison based constraints.","title":"ComparisonConstraintValidatorTestCase"},{"location":"Validator/Spec/ComparisonConstraintValidatorTestCase/#Athena::Validator::Spec::ComparisonConstraintValidatorTestCase--example","text":"Using the spec from AVD::Constraints::EqualTo : # Makes for a bit less typing when needing to reference the constraint. private alias CONSTRAINT = AVD :: Constraints :: EqualTo # Define our test case inheriting from the abstract `ComparisonConstraintValidatorTestCase`. struct EqualToValidatorTest < AVD :: Spec :: ComparisonConstraintValidatorTestCase # Returns a Tuple of Tuples representing valid comparisons. # The first item is the actual value and the second item is the expected value. def valid_comparisons : Tuple { { 3 , 3 }, { 'a' , 'a' }, { \"a\" , \"a\" }, { Time . utc ( 2020 , 4 , 7 ), Time . utc ( 2020 , 4 , 7 )}, { nil , false }, } end # Returns a Tuple of Tuples representing invalid comparisons. # The first item is the actual value and the second item is the expected value. def invalid_comparisons : Tuple { { 1 , 3 }, { 'b' , 'a' }, { \"b\" , \"a\" }, { Time . utc ( 2020 , 4 , 8 ), Time . utc ( 2020 , 4 , 7 )}, } end # The error code related to the current CONSTRAINT. def error_code : String CONSTRAINT :: NOT_EQUAL_ERROR end # Implement some abstract defs to return the validator and constraint class. def create_validator : AVD :: ConstraintValidatorInterface CONSTRAINT :: Validator . new end def constraint_class : AVD :: Constraint . class CONSTRAINT end end","title":"Example"},{"location":"Validator/Spec/ComparisonConstraintValidatorTestCase/#methods","text":"","title":"Methods"},{"location":"Validator/Spec/ComparisonConstraintValidatorTestCase/#Athena::Validator::Spec::ComparisonConstraintValidatorTestCase#error_code()","text":"The code for the current constraint.","title":"#error_code"},{"location":"Validator/Spec/ComparisonConstraintValidatorTestCase/#Athena::Validator::Spec::ComparisonConstraintValidatorTestCase#invalid_comparisons()","text":"A Tuple of tuples representing invalid comparisons.","title":"#invalid_comparisons"},{"location":"Validator/Spec/ComparisonConstraintValidatorTestCase/#Athena::Validator::Spec::ComparisonConstraintValidatorTestCase#test_invalid_comparisons(actual,expected)","text":"","title":"#test_invalid_comparisons"},{"location":"Validator/Spec/ComparisonConstraintValidatorTestCase/#Athena::Validator::Spec::ComparisonConstraintValidatorTestCase#test_valid_comparisons(actual,expected)","text":"","title":"#test_valid_comparisons"},{"location":"Validator/Spec/ComparisonConstraintValidatorTestCase/#Athena::Validator::Spec::ComparisonConstraintValidatorTestCase#valid_comparisons()","text":"A Tuple of tuples representing valid comparisons.","title":"#valid_comparisons"},{"location":"Validator/Spec/ConstraintValidatorTestCase/","text":"abstract struct Athena::Validator::Spec::ConstraintValidatorTestCase inherits Athena::Spec::TestCase Test case designed to make testing AVD::ConstraintValidatorInterface easier. Example Using the spec from AVD::Constraints::NotNil : # Makes for a bit less typing when needing to reference the constraint. private alias CONSTRAINT = AVD :: Constraints :: NotNil # Define our test case inheriting from the abstract ConstraintValidatorTestCase. struct NotNilValidatorTest < AVD :: Spec :: ConstraintValidatorTestCase @[ DataProvider ( \"valid_values\" ) ] def test_valid_values ( value : _ ) : Nil # Validate the value against a new instance of the constraint. self . validator . validate value , self . new_constraint # Assert no violations were added to the context. self . assert_no_violation end # Use data providers to reduce duplication. def valid_values : NamedTuple { string : { \"\" }, bool_false : { false }, bool_true : { true }, zero : { 0 }, null_pointer : { Pointer ( Void ) . null }, } end def test_nil_is_invalid # Validate an invalid value against a new instance of the constraint with a custom message. self . validator . validate nil , self . new_constraint message : \"my_message\" # Asssert a violation with the expected message, code, and value parameter is added to the context. self . build_violation ( \"my_message\" , CONSTRAINT :: IS_NULL_ERROR , nil ) . assert_violation end # Implement some abstract defs to return the validator and constraint class. private def create_validator : AVD :: ConstraintValidatorInterface CONSTRAINT :: Validator . new end private def constraint_class : AVD :: Constraint . class CONSTRAINT end end This type is an extension of ASPEC::TestCase , see that type for more information on this testing approach. This approach also allows using ASPEC::TestCase::DataProvider s for reducing duplication withing your test. Direct known subclasses Athena::Validator::Spec::ComparisonConstraintValidatorTestCase Class methods .new Methods #assert_no_violation ( * , file : String = __FILE__ , line : Int32 = __LINE__ ) : Nil Asserts that no violations were added to the context. #assert_violation ( message : String , code : String , value : _ ) : Nil Asserts a violation with the provided message , code , and value parameter was added to the context. #assert_violation ( message : String , code : String ) : Nil Asserts a violation with the provided provided message , and code was added to the context. #assert_violation ( message : String ) : Nil Asserts a violation with the provided message was added to the context. #build_violation ( message : String , code : String , value : _ ) : AVD::Spec::ConstraintValidatorTestCase::Assertion Returns an AVD::Spec::ConstraintValidatorTestCase::Assertion with the provided message , code , and value parameter preset. #build_violation ( message : String , code : String ) : AVD::Spec::ConstraintValidatorTestCase::Assertion Returns an AVD::Spec::ConstraintValidatorTestCase::Assertion with the provided message , and code preset. #build_violation ( message : String ) : AVD::Spec::ConstraintValidatorTestCase::Assertion Returns an AVD::Spec::ConstraintValidatorTestCase::Assertion with the provided message preset. abstract #constraint_class : AVD :: Constraint . class Returns the class of the constraint being tested. #context : AVD::ExecutionContext ( String ) Returns a reference to the context used for the current test. abstract #create_validator : AVD::ConstraintValidatorInterface Returns a new validator instance for the constraint being tested. #new_constraint ( ** args ) : AVD::Constraint Returns a new constraint instance based on #constraint_class and the provided args . #validator : AVD::ConstraintValidatorInterface Returns the validator instance returned via #create_validator . #value= ( value ) : Nil Overrides the value/node currently being validated.","title":"ConstraintValidatorTestCase"},{"location":"Validator/Spec/ConstraintValidatorTestCase/#Athena::Validator::Spec::ConstraintValidatorTestCase","text":"Test case designed to make testing AVD::ConstraintValidatorInterface easier.","title":"ConstraintValidatorTestCase"},{"location":"Validator/Spec/ConstraintValidatorTestCase/#Athena::Validator::Spec::ConstraintValidatorTestCase--example","text":"Using the spec from AVD::Constraints::NotNil : # Makes for a bit less typing when needing to reference the constraint. private alias CONSTRAINT = AVD :: Constraints :: NotNil # Define our test case inheriting from the abstract ConstraintValidatorTestCase. struct NotNilValidatorTest < AVD :: Spec :: ConstraintValidatorTestCase @[ DataProvider ( \"valid_values\" ) ] def test_valid_values ( value : _ ) : Nil # Validate the value against a new instance of the constraint. self . validator . validate value , self . new_constraint # Assert no violations were added to the context. self . assert_no_violation end # Use data providers to reduce duplication. def valid_values : NamedTuple { string : { \"\" }, bool_false : { false }, bool_true : { true }, zero : { 0 }, null_pointer : { Pointer ( Void ) . null }, } end def test_nil_is_invalid # Validate an invalid value against a new instance of the constraint with a custom message. self . validator . validate nil , self . new_constraint message : \"my_message\" # Asssert a violation with the expected message, code, and value parameter is added to the context. self . build_violation ( \"my_message\" , CONSTRAINT :: IS_NULL_ERROR , nil ) . assert_violation end # Implement some abstract defs to return the validator and constraint class. private def create_validator : AVD :: ConstraintValidatorInterface CONSTRAINT :: Validator . new end private def constraint_class : AVD :: Constraint . class CONSTRAINT end end This type is an extension of ASPEC::TestCase , see that type for more information on this testing approach. This approach also allows using ASPEC::TestCase::DataProvider s for reducing duplication withing your test.","title":"Example"},{"location":"Validator/Spec/ConstraintValidatorTestCase/#direct-known-subclasses","text":"Athena::Validator::Spec::ComparisonConstraintValidatorTestCase","title":"Direct known subclasses"},{"location":"Validator/Spec/ConstraintValidatorTestCase/#class-methods","text":"","title":"Class methods"},{"location":"Validator/Spec/ConstraintValidatorTestCase/#Athena::Validator::Spec::ConstraintValidatorTestCase.new()","text":"","title":".new"},{"location":"Validator/Spec/ConstraintValidatorTestCase/#methods","text":"","title":"Methods"},{"location":"Validator/Spec/ConstraintValidatorTestCase/#Athena::Validator::Spec::ConstraintValidatorTestCase#assert_no_violation(*,file,line)","text":"Asserts that no violations were added to the context.","title":"#assert_no_violation"},{"location":"Validator/Spec/ConstraintValidatorTestCase/#Athena::Validator::Spec::ConstraintValidatorTestCase#assert_violation(message,code,value)","text":"Asserts a violation with the provided message , code , and value parameter was added to the context.","title":"#assert_violation"},{"location":"Validator/Spec/ConstraintValidatorTestCase/#Athena::Validator::Spec::ConstraintValidatorTestCase#build_violation(message,code,value)","text":"Returns an AVD::Spec::ConstraintValidatorTestCase::Assertion with the provided message , code , and value parameter preset.","title":"#build_violation"},{"location":"Validator/Spec/ConstraintValidatorTestCase/#Athena::Validator::Spec::ConstraintValidatorTestCase#constraint_class()","text":"Returns the class of the constraint being tested.","title":"#constraint_class"},{"location":"Validator/Spec/ConstraintValidatorTestCase/#Athena::Validator::Spec::ConstraintValidatorTestCase#context()","text":"Returns a reference to the context used for the current test.","title":"#context"},{"location":"Validator/Spec/ConstraintValidatorTestCase/#Athena::Validator::Spec::ConstraintValidatorTestCase#create_validator()","text":"Returns a new validator instance for the constraint being tested.","title":"#create_validator"},{"location":"Validator/Spec/ConstraintValidatorTestCase/#Athena::Validator::Spec::ConstraintValidatorTestCase#new_constraint(**args)","text":"Returns a new constraint instance based on #constraint_class and the provided args .","title":"#new_constraint"},{"location":"Validator/Spec/ConstraintValidatorTestCase/#Athena::Validator::Spec::ConstraintValidatorTestCase#validator()","text":"Returns the validator instance returned via #create_validator .","title":"#validator"},{"location":"Validator/Spec/ConstraintValidatorTestCase/#Athena::Validator::Spec::ConstraintValidatorTestCase#value=(value)","text":"Overrides the value/node currently being validated.","title":"#value="},{"location":"Validator/Spec/ConstraintValidatorTestCase/Assertion/","text":"struct Athena::Validator::Spec::ConstraintValidatorTestCase::Assertion inherits Struct Used to assert that a violation added via the AVD::ConstraintValidatorInterface was built as expected. NOTE: This type should not be instantiated directly, use AVD::Spec::ConstraintValidatorTestCase#build_violation instead. Class methods .new ( context : AVD::ExecutionContextInterface , message : String , constraint : AVD::Constraint ) Methods #add_parameter ( key : String , value : _ ) : self Adds the provided key value pair to the expected violations' AVD::Violation::ConstraintViolationInterface#parameters . Returns self for chaining. #assert_violation ( * , file : String = __FILE__ , line : Int32 = __LINE__ ) : Nil Asserts that the violation added to the context equals the violation built via self . #at_path ( property_path : String ) : self Sets the AVD::Violation::ConstraintViolationInterface#property_path on the expected violation. Returns self for chaining. #cause ( cause : String ?) : self Sets the AVD::Violation::ConstraintViolationInterface#cause on the expected violation. Returns self for chaining. #clone #code ( code : String ?) : self Sets the AVD::Violation::ConstraintViolationInterface#code on the expected violation. Returns self for chaining. #constraint : AVD::Constraint #context : AVD::ExecutionContextInterface #copy_with ( context _context = @context , message _message = @message , constraint _constraint = @constraint ) #invalid_value ( value : _ ) : self Sets the AVD::Violation::ConstraintViolationInterface#invalid_value on the expected violation. Returns self for chaining. #message : String #plural ( plural : Int32 ) : self Sets the AVD::Violation::ConstraintViolationInterface#plural on the expected violation. Returns self for chaining.","title":"Assertion"},{"location":"Validator/Spec/ConstraintValidatorTestCase/Assertion/#Athena::Validator::Spec::ConstraintValidatorTestCase::Assertion","text":"Used to assert that a violation added via the AVD::ConstraintValidatorInterface was built as expected. NOTE: This type should not be instantiated directly, use AVD::Spec::ConstraintValidatorTestCase#build_violation instead.","title":"Assertion"},{"location":"Validator/Spec/ConstraintValidatorTestCase/Assertion/#class-methods","text":"","title":"Class methods"},{"location":"Validator/Spec/ConstraintValidatorTestCase/Assertion/#Athena::Validator::Spec::ConstraintValidatorTestCase::Assertion.new(context,message,constraint)","text":"","title":".new"},{"location":"Validator/Spec/ConstraintValidatorTestCase/Assertion/#methods","text":"","title":"Methods"},{"location":"Validator/Spec/ConstraintValidatorTestCase/Assertion/#Athena::Validator::Spec::ConstraintValidatorTestCase::Assertion#add_parameter(key,value)","text":"Adds the provided key value pair to the expected violations' AVD::Violation::ConstraintViolationInterface#parameters . Returns self for chaining.","title":"#add_parameter"},{"location":"Validator/Spec/ConstraintValidatorTestCase/Assertion/#Athena::Validator::Spec::ConstraintValidatorTestCase::Assertion#assert_violation(*,file,line)","text":"Asserts that the violation added to the context equals the violation built via self .","title":"#assert_violation"},{"location":"Validator/Spec/ConstraintValidatorTestCase/Assertion/#Athena::Validator::Spec::ConstraintValidatorTestCase::Assertion#at_path(property_path)","text":"Sets the AVD::Violation::ConstraintViolationInterface#property_path on the expected violation. Returns self for chaining.","title":"#at_path"},{"location":"Validator/Spec/ConstraintValidatorTestCase/Assertion/#Athena::Validator::Spec::ConstraintValidatorTestCase::Assertion#cause(cause)","text":"Sets the AVD::Violation::ConstraintViolationInterface#cause on the expected violation. Returns self for chaining.","title":"#cause"},{"location":"Validator/Spec/ConstraintValidatorTestCase/Assertion/#Athena::Validator::Spec::ConstraintValidatorTestCase::Assertion#clone()","text":"","title":"#clone"},{"location":"Validator/Spec/ConstraintValidatorTestCase/Assertion/#Athena::Validator::Spec::ConstraintValidatorTestCase::Assertion#code(code)","text":"Sets the AVD::Violation::ConstraintViolationInterface#code on the expected violation. Returns self for chaining.","title":"#code"},{"location":"Validator/Spec/ConstraintValidatorTestCase/Assertion/#Athena::Validator::Spec::ConstraintValidatorTestCase::Assertion#constraint()","text":"","title":"#constraint"},{"location":"Validator/Spec/ConstraintValidatorTestCase/Assertion/#Athena::Validator::Spec::ConstraintValidatorTestCase::Assertion#context()","text":"","title":"#context"},{"location":"Validator/Spec/ConstraintValidatorTestCase/Assertion/#Athena::Validator::Spec::ConstraintValidatorTestCase::Assertion#copy_with(context,message,constraint)","text":"","title":"#copy_with"},{"location":"Validator/Spec/ConstraintValidatorTestCase/Assertion/#Athena::Validator::Spec::ConstraintValidatorTestCase::Assertion#invalid_value(value)","text":"Sets the AVD::Violation::ConstraintViolationInterface#invalid_value on the expected violation. Returns self for chaining.","title":"#invalid_value"},{"location":"Validator/Spec/ConstraintValidatorTestCase/Assertion/#Athena::Validator::Spec::ConstraintValidatorTestCase::Assertion#message()","text":"","title":"#message"},{"location":"Validator/Spec/ConstraintValidatorTestCase/Assertion/#Athena::Validator::Spec::ConstraintValidatorTestCase::Assertion#plural(plural)","text":"Sets the AVD::Violation::ConstraintViolationInterface#plural on the expected violation. Returns self for chaining.","title":"#plural"},{"location":"Validator/Spec/EntityGroupSequenceProvider/","text":"struct Athena::Validator::Spec::EntityGroupSequenceProvider inherits Struct An AVD::Validatable entity using an AVD::Constraints::GroupSequence based group sequence. Included modules Athena::Validator::Constraints::GroupSequence::Provider Athena::Validator::Validatable Extended modules Athena::Validator::Validatable::Class Class methods .validation_class_metadata .new ( sequence : AVD::Constraints::GroupSequence ) Methods #clone #copy_with ( sequence _sequence = @sequence ) #group_sequence : Array ( String | Array ( String )) | AVD::Constraints::GroupSequence #sequence : AVD::Constraints::GroupSequence","title":"EntityGroupSequenceProvider"},{"location":"Validator/Spec/EntityGroupSequenceProvider/#Athena::Validator::Spec::EntityGroupSequenceProvider","text":"An AVD::Validatable entity using an AVD::Constraints::GroupSequence based group sequence.","title":"EntityGroupSequenceProvider"},{"location":"Validator/Spec/EntityGroupSequenceProvider/#included-modules","text":"Athena::Validator::Constraints::GroupSequence::Provider Athena::Validator::Validatable","title":"Included modules"},{"location":"Validator/Spec/EntityGroupSequenceProvider/#extended-modules","text":"Athena::Validator::Validatable::Class","title":"Extended modules"},{"location":"Validator/Spec/EntityGroupSequenceProvider/#class-methods","text":"","title":"Class methods"},{"location":"Validator/Spec/EntityGroupSequenceProvider/#Athena::Validator::Spec::EntityGroupSequenceProvider.validation_class_metadata()","text":"","title":".validation_class_metadata"},{"location":"Validator/Spec/EntityGroupSequenceProvider/#Athena::Validator::Spec::EntityGroupSequenceProvider.new(sequence)","text":"","title":".new"},{"location":"Validator/Spec/EntityGroupSequenceProvider/#methods","text":"","title":"Methods"},{"location":"Validator/Spec/EntityGroupSequenceProvider/#Athena::Validator::Spec::EntityGroupSequenceProvider#clone()","text":"","title":"#clone"},{"location":"Validator/Spec/EntityGroupSequenceProvider/#Athena::Validator::Spec::EntityGroupSequenceProvider#copy_with(sequence)","text":"","title":"#copy_with"},{"location":"Validator/Spec/EntityGroupSequenceProvider/#Athena::Validator::Spec::EntityGroupSequenceProvider#group_sequence()","text":"","title":"#group_sequence"},{"location":"Validator/Spec/EntityGroupSequenceProvider/#Athena::Validator::Spec::EntityGroupSequenceProvider#sequence()","text":"","title":"#sequence"},{"location":"Validator/Spec/EntitySequenceProvider/","text":"struct Athena::Validator::Spec::EntitySequenceProvider inherits Struct An AVD::Validatable entity using an Array based group sequence. Included modules Athena::Validator::Constraints::GroupSequence::Provider Athena::Validator::Validatable Extended modules Athena::Validator::Validatable::Class Class methods .validation_class_metadata .new ( sequence : Array ( String | Array ( String ))) Methods #clone #copy_with ( sequence _sequence = @sequence ) #group_sequence : Array ( String | Array ( String )) | AVD::Constraints::GroupSequence #sequence : Array ( String | Array ( String ))","title":"EntitySequenceProvider"},{"location":"Validator/Spec/EntitySequenceProvider/#Athena::Validator::Spec::EntitySequenceProvider","text":"An AVD::Validatable entity using an Array based group sequence.","title":"EntitySequenceProvider"},{"location":"Validator/Spec/EntitySequenceProvider/#included-modules","text":"Athena::Validator::Constraints::GroupSequence::Provider Athena::Validator::Validatable","title":"Included modules"},{"location":"Validator/Spec/EntitySequenceProvider/#extended-modules","text":"Athena::Validator::Validatable::Class","title":"Extended modules"},{"location":"Validator/Spec/EntitySequenceProvider/#class-methods","text":"","title":"Class methods"},{"location":"Validator/Spec/EntitySequenceProvider/#Athena::Validator::Spec::EntitySequenceProvider.validation_class_metadata()","text":"","title":".validation_class_metadata"},{"location":"Validator/Spec/EntitySequenceProvider/#Athena::Validator::Spec::EntitySequenceProvider.new(sequence)","text":"","title":".new"},{"location":"Validator/Spec/EntitySequenceProvider/#methods","text":"","title":"Methods"},{"location":"Validator/Spec/EntitySequenceProvider/#Athena::Validator::Spec::EntitySequenceProvider#clone()","text":"","title":"#clone"},{"location":"Validator/Spec/EntitySequenceProvider/#Athena::Validator::Spec::EntitySequenceProvider#copy_with(sequence)","text":"","title":"#copy_with"},{"location":"Validator/Spec/EntitySequenceProvider/#Athena::Validator::Spec::EntitySequenceProvider#group_sequence()","text":"","title":"#group_sequence"},{"location":"Validator/Spec/EntitySequenceProvider/#Athena::Validator::Spec::EntitySequenceProvider#sequence()","text":"","title":"#sequence"},{"location":"Validator/Spec/FailingConstraint/","text":"class Athena::Validator::Spec::FailingConstraint inherits Athena::Validator::Constraint A constraint that always adds a violation. Class methods .new ( message : String = \"Failed\" , groups : Array ( String ) | String | Nil = nil , payload : Hash ( String , String )? = nil ) Methods #validated_by : AVD :: ConstraintValidator . class Returns the AVD::ConstraintValidator.class that should handle validating self .","title":"FailingConstraint"},{"location":"Validator/Spec/FailingConstraint/#Athena::Validator::Spec::FailingConstraint","text":"A constraint that always adds a violation.","title":"FailingConstraint"},{"location":"Validator/Spec/FailingConstraint/#class-methods","text":"","title":"Class methods"},{"location":"Validator/Spec/FailingConstraint/#Athena::Validator::Spec::FailingConstraint.new(message,groups,payload)","text":"","title":".new"},{"location":"Validator/Spec/FailingConstraint/#methods","text":"","title":"Methods"},{"location":"Validator/Spec/FailingConstraint/#Athena::Validator::Spec::FailingConstraint#validated_by()","text":"Returns the AVD::ConstraintValidator.class that should handle validating self .","title":"#validated_by"},{"location":"Validator/Spec/FailingConstraint/Validator/","text":"struct Athena::Validator::Spec::FailingConstraint::Validator inherits Athena::Validator::ConstraintValidator Methods #validate ( value : _ , constraint : FailingConstraint ) : Nil :inherit:","title":"Validator"},{"location":"Validator/Spec/FailingConstraint/Validator/#Athena::Validator::Spec::FailingConstraint::Validator","text":"","title":"Validator"},{"location":"Validator/Spec/FailingConstraint/Validator/#methods","text":"","title":"Methods"},{"location":"Validator/Spec/FailingConstraint/Validator/#Athena::Validator::Spec::FailingConstraint::Validator#validate(value,constraint)","text":":inherit:","title":"#validate"},{"location":"Validator/Spec/MockContextualValidator/","text":"class Athena::Validator::Spec::MockContextualValidator inherits Reference A spec implementation of AVD::Validator::ContextualValidatorInterface . Allows settings the violations that should be returned. Defaults to no violations. Included modules Athena::Validator::Validator::ContextualValidatorInterface Class methods .new ( violations : AVD::Violation::ConstraintViolationListInterface = AVD :: Violation :: ConstraintViolationList . new ) Methods #at_path ( path : String ) : AVD::Validator::ContextualValidatorInterface Appends the provided path to the current AVD::ExecutionContextInterface#property_path . #validate ( value : _ , constraints : Array ( AVD::Constraint ) | AVD::Constraint | Nil = nil , groups : Array ( String ) | String | AVD::Constraints::GroupSequence | Nil = nil ) : AVD::Validator::ContextualValidatorInterface Validates the provided value , optionally against the provided constraints , optionally using the provided groups . AVD::Constraint::DEFAULT_GROUP is assumed if no groups are provided. #validate_property ( object : AVD::Validatable , property_name : String , groups : Array ( String ) | String | AVD::Constraints::GroupSequence | Nil = nil ) : AVD::Validator::ContextualValidatorInterface Validates a property of the provided object against the constraints defined for that property, optionally using the provided groups . AVD::Constraint::DEFAULT_GROUP is assumed if no groups are provided. #validate_property_value ( object : AVD::Validatable , property_name : String , value : _ , groups : Array ( String ) | String | AVD::Constraints::GroupSequence | Nil = nil ) : AVD::Validator::ContextualValidatorInterface Validates a value against the constraints defined on the property of the provided object . AVD::Constraint::DEFAULT_GROUP is assumed if no groups are provided. #violations : AVD::Violation::ConstraintViolationListInterface Returns any violations that have been generated so far in the context of self . #violations= ( violations : AVD::Violation::ConstraintViolationListInterface )","title":"MockContextualValidator"},{"location":"Validator/Spec/MockContextualValidator/#Athena::Validator::Spec::MockContextualValidator","text":"A spec implementation of AVD::Validator::ContextualValidatorInterface . Allows settings the violations that should be returned. Defaults to no violations.","title":"MockContextualValidator"},{"location":"Validator/Spec/MockContextualValidator/#included-modules","text":"Athena::Validator::Validator::ContextualValidatorInterface","title":"Included modules"},{"location":"Validator/Spec/MockContextualValidator/#class-methods","text":"","title":"Class methods"},{"location":"Validator/Spec/MockContextualValidator/#Athena::Validator::Spec::MockContextualValidator.new(violations)","text":"","title":".new"},{"location":"Validator/Spec/MockContextualValidator/#methods","text":"","title":"Methods"},{"location":"Validator/Spec/MockContextualValidator/#Athena::Validator::Spec::MockContextualValidator#at_path(path)","text":"Appends the provided path to the current AVD::ExecutionContextInterface#property_path .","title":"#at_path"},{"location":"Validator/Spec/MockContextualValidator/#Athena::Validator::Spec::MockContextualValidator#validate(value,constraints,groups)","text":"Validates the provided value , optionally against the provided constraints , optionally using the provided groups . AVD::Constraint::DEFAULT_GROUP is assumed if no groups are provided.","title":"#validate"},{"location":"Validator/Spec/MockContextualValidator/#Athena::Validator::Spec::MockContextualValidator#validate_property(object,property_name,groups)","text":"Validates a property of the provided object against the constraints defined for that property, optionally using the provided groups . AVD::Constraint::DEFAULT_GROUP is assumed if no groups are provided.","title":"#validate_property"},{"location":"Validator/Spec/MockContextualValidator/#Athena::Validator::Spec::MockContextualValidator#validate_property_value(object,property_name,value,groups)","text":"Validates a value against the constraints defined on the property of the provided object . AVD::Constraint::DEFAULT_GROUP is assumed if no groups are provided.","title":"#validate_property_value"},{"location":"Validator/Spec/MockContextualValidator/#Athena::Validator::Spec::MockContextualValidator#violations()","text":"Returns any violations that have been generated so far in the context of self .","title":"#violations"},{"location":"Validator/Spec/MockContextualValidator/#Athena::Validator::Spec::MockContextualValidator#violations=(violations)","text":"","title":"#violations="},{"location":"Validator/Spec/MockMetadataFactory/","text":"struct Athena::Validator::Spec::MockMetadataFactory(T1, T2, T3, T4, T5) inherits Struct A spec implementation of AVD::Metadata::MetadataFactoryInterface , supporting a fixed number of additional metadatas Included modules Athena::Validator::Metadata::MetadataFactoryInterface Class methods .new Methods #add_metadata ( klass : AVD :: Validatable :: Class , metadata : AVD::Metadata::ClassMetadata ) : Nil #metadata ( object : AVD::Validatable ) : AVD::Metadata::ClassMetadata Returns an AVD::Metadata::ClassMetadata instance for the related AVD::Validatable object .","title":"MockMetadataFactory"},{"location":"Validator/Spec/MockMetadataFactory/#Athena::Validator::Spec::MockMetadataFactory","text":"A spec implementation of AVD::Metadata::MetadataFactoryInterface , supporting a fixed number of additional metadatas","title":"MockMetadataFactory"},{"location":"Validator/Spec/MockMetadataFactory/#included-modules","text":"Athena::Validator::Metadata::MetadataFactoryInterface","title":"Included modules"},{"location":"Validator/Spec/MockMetadataFactory/#class-methods","text":"","title":"Class methods"},{"location":"Validator/Spec/MockMetadataFactory/#Athena::Validator::Spec::MockMetadataFactory.new()","text":"","title":".new"},{"location":"Validator/Spec/MockMetadataFactory/#methods","text":"","title":"Methods"},{"location":"Validator/Spec/MockMetadataFactory/#Athena::Validator::Spec::MockMetadataFactory#add_metadata(klass,metadata)","text":"","title":"#add_metadata"},{"location":"Validator/Spec/MockMetadataFactory/#Athena::Validator::Spec::MockMetadataFactory#metadata(object)","text":"Returns an AVD::Metadata::ClassMetadata instance for the related AVD::Validatable object .","title":"#metadata"},{"location":"Validator/Spec/MockValidator/","text":"class Athena::Validator::Spec::MockValidator inherits Reference A spec implementation of AVD::Validator::ValidatorInterface . Allows settings the violations that should be returned. Defaults to no violations. Included modules Athena::Validator::Validator::ValidatorInterface Class methods .new ( violations : AVD::Violation::ConstraintViolationListInterface = AVD :: Violation :: ConstraintViolationList . new ) Methods #in_context ( context : AVD::ExecutionContextInterface ) : AVD::Validator::ContextualValidatorInterface Returns a validator in the provided context . Violations generated by the returned validator are added to the provided context . #start_context ( root = nil ) : AVD::Validator::ContextualValidatorInterface Creates a new AVD::ExecutionContextInterface and returns a new validator for that context. Violations generated by the returned validator can be accessed via AVD::Validator::ContextualValidatorInterface#violations . #validate ( value : _ , constraints : Array ( AVD::Constraint ) | AVD::Constraint | Nil = nil , groups : Array ( String ) | String | AVD::Constraints::GroupSequence | Nil = nil ) : AVD::Violation::ConstraintViolationListInterface Validates the provided value , optionally against the provided constraints , optionally using the provided groups . AVD::Constraint::DEFAULT_GROUP is assumed if no groups are provided. #validate_property ( object : AVD::Validatable , property_name : String , groups : Array ( String ) | String | AVD::Constraints::GroupSequence | Nil = nil ) : AVD::Violation::ConstraintViolationListInterface Validates a property of the provided object against the constraints defined for that property, optionally using the provided groups . AVD::Constraint::DEFAULT_GROUP is assumed if no groups are provided. #validate_property_value ( object : AVD::Validatable , property_name : String , value : _ , groups : Array ( String ) | String | AVD::Constraints::GroupSequence | Nil = nil ) : AVD::Violation::ConstraintViolationListInterface Validates a value against the constraints defined on the property of the provided object . AVD::Constraint::DEFAULT_GROUP is assumed if no groups are provided. #violations= ( violations : AVD::Violation::ConstraintViolationListInterface )","title":"MockValidator"},{"location":"Validator/Spec/MockValidator/#Athena::Validator::Spec::MockValidator","text":"A spec implementation of AVD::Validator::ValidatorInterface . Allows settings the violations that should be returned. Defaults to no violations.","title":"MockValidator"},{"location":"Validator/Spec/MockValidator/#included-modules","text":"Athena::Validator::Validator::ValidatorInterface","title":"Included modules"},{"location":"Validator/Spec/MockValidator/#class-methods","text":"","title":"Class methods"},{"location":"Validator/Spec/MockValidator/#Athena::Validator::Spec::MockValidator.new(violations)","text":"","title":".new"},{"location":"Validator/Spec/MockValidator/#methods","text":"","title":"Methods"},{"location":"Validator/Spec/MockValidator/#Athena::Validator::Spec::MockValidator#in_context(context)","text":"Returns a validator in the provided context . Violations generated by the returned validator are added to the provided context .","title":"#in_context"},{"location":"Validator/Spec/MockValidator/#Athena::Validator::Spec::MockValidator#start_context(root)","text":"Creates a new AVD::ExecutionContextInterface and returns a new validator for that context. Violations generated by the returned validator can be accessed via AVD::Validator::ContextualValidatorInterface#violations .","title":"#start_context"},{"location":"Validator/Spec/MockValidator/#Athena::Validator::Spec::MockValidator#validate(value,constraints,groups)","text":"Validates the provided value , optionally against the provided constraints , optionally using the provided groups . AVD::Constraint::DEFAULT_GROUP is assumed if no groups are provided.","title":"#validate"},{"location":"Validator/Spec/MockValidator/#Athena::Validator::Spec::MockValidator#validate_property(object,property_name,groups)","text":"Validates a property of the provided object against the constraints defined for that property, optionally using the provided groups . AVD::Constraint::DEFAULT_GROUP is assumed if no groups are provided.","title":"#validate_property"},{"location":"Validator/Spec/MockValidator/#Athena::Validator::Spec::MockValidator#validate_property_value(object,property_name,value,groups)","text":"Validates a value against the constraints defined on the property of the provided object . AVD::Constraint::DEFAULT_GROUP is assumed if no groups are provided.","title":"#validate_property_value"},{"location":"Validator/Spec/MockValidator/#Athena::Validator::Spec::MockValidator#violations=(violations)","text":"","title":"#violations="},{"location":"Validator/Validatable/","text":"module Athena::Validator::Validatable When included, denotes that a type (class or struct) can be validated via Athena::Validator . Example class Example include AVD :: Validatable def initialize ( @name : String ); end @[ Assert :: NotBlank ] property name : String end AVD . validator . validate Example . new ( \"Jim\" ) Direct including types Athena::Validator::Spec::EntityGroupSequenceProvider Athena::Validator::Spec::EntitySequenceProvider","title":"Validatable"},{"location":"Validator/Validatable/#Athena::Validator::Validatable","text":"When included, denotes that a type (class or struct) can be validated via Athena::Validator .","title":"Validatable"},{"location":"Validator/Validatable/#Athena::Validator::Validatable--example","text":"class Example include AVD :: Validatable def initialize ( @name : String ); end @[ Assert :: NotBlank ] property name : String end AVD . validator . validate Example . new ( \"Jim\" )","title":"Example"},{"location":"Validator/Validatable/#direct-including-types","text":"Athena::Validator::Spec::EntityGroupSequenceProvider Athena::Validator::Spec::EntitySequenceProvider","title":"Direct including types"},{"location":"Validator/Validator/","text":"module Athena::Validator::Validator Contains types related to the validator itself.","title":"Validator"},{"location":"Validator/Validator/#Athena::Validator::Validator","text":"Contains types related to the validator itself.","title":"Validator"},{"location":"Validator/Validator/ContextualValidatorInterface/","text":"module Athena::Validator::Validator::ContextualValidatorInterface A validator that validates in a specific AVD::ExecutionContextInterface instance. Direct including types Athena::Validator::Spec::MockContextualValidator Athena::Validator::Validator::RecursiveContextualValidator Methods abstract #at_path ( path : String ) : AVD::Validator::ContextualValidatorInterface Appends the provided path to the current AVD::ExecutionContextInterface#property_path . abstract #validate ( value : _ , constraints : Array ( AVD::Constraint ) | AVD::Constraint | Nil = nil , groups : Array ( String ) | String | AVD::Constraints::GroupSequence | Nil = nil ) : AVD::Validator::ContextualValidatorInterface Validates the provided value , optionally against the provided constraints , optionally using the provided groups . AVD::Constraint::DEFAULT_GROUP is assumed if no groups are provided. abstract #validate_property ( object : AVD::Validatable , property_name : String , groups : Array ( String ) | String | AVD::Constraints::GroupSequence | Nil = nil ) : AVD::Validator::ContextualValidatorInterface Validates a property of the provided object against the constraints defined for that property, optionally using the provided groups . AVD::Constraint::DEFAULT_GROUP is assumed if no groups are provided. abstract #validate_property_value ( object : AVD::Validatable , property_name : String , value : _ , groups : Array ( String ) | String | AVD::Constraints::GroupSequence | Nil = nil ) : AVD::Validator::ContextualValidatorInterface Validates a value against the constraints defined on the property of the provided object . AVD::Constraint::DEFAULT_GROUP is assumed if no groups are provided. abstract #violations : AVD::Violation::ConstraintViolationListInterface Returns any violations that have been generated so far in the context of self .","title":"ContextualValidatorInterface"},{"location":"Validator/Validator/ContextualValidatorInterface/#Athena::Validator::Validator::ContextualValidatorInterface","text":"A validator that validates in a specific AVD::ExecutionContextInterface instance.","title":"ContextualValidatorInterface"},{"location":"Validator/Validator/ContextualValidatorInterface/#direct-including-types","text":"Athena::Validator::Spec::MockContextualValidator Athena::Validator::Validator::RecursiveContextualValidator","title":"Direct including types"},{"location":"Validator/Validator/ContextualValidatorInterface/#methods","text":"","title":"Methods"},{"location":"Validator/Validator/ContextualValidatorInterface/#Athena::Validator::Validator::ContextualValidatorInterface#at_path(path)","text":"Appends the provided path to the current AVD::ExecutionContextInterface#property_path .","title":"#at_path"},{"location":"Validator/Validator/ContextualValidatorInterface/#Athena::Validator::Validator::ContextualValidatorInterface#validate(value,constraints,groups)","text":"Validates the provided value , optionally against the provided constraints , optionally using the provided groups . AVD::Constraint::DEFAULT_GROUP is assumed if no groups are provided.","title":"#validate"},{"location":"Validator/Validator/ContextualValidatorInterface/#Athena::Validator::Validator::ContextualValidatorInterface#validate_property(object,property_name,groups)","text":"Validates a property of the provided object against the constraints defined for that property, optionally using the provided groups . AVD::Constraint::DEFAULT_GROUP is assumed if no groups are provided.","title":"#validate_property"},{"location":"Validator/Validator/ContextualValidatorInterface/#Athena::Validator::Validator::ContextualValidatorInterface#validate_property_value(object,property_name,value,groups)","text":"Validates a value against the constraints defined on the property of the provided object . AVD::Constraint::DEFAULT_GROUP is assumed if no groups are provided.","title":"#validate_property_value"},{"location":"Validator/Validator/ContextualValidatorInterface/#Athena::Validator::Validator::ContextualValidatorInterface#violations()","text":"Returns any violations that have been generated so far in the context of self .","title":"#violations"},{"location":"Validator/Validator/RecursiveContextualValidator/","text":"class Athena::Validator::Validator::RecursiveContextualValidator inherits Reference A recursive implementation of AVD::Validator::ContextualValidatorInterface . See Athena::Validator.validator . Included modules Athena::Validator::Validator::ContextualValidatorInterface Class methods .new ( context : AVD::ExecutionContextInterface , constraint_validator_factory : AVD::ConstraintValidatorFactoryInterface , metadata_factory : AVD::Metadata::MetadataFactoryInterface ) Methods #at_path ( path : String ) : AVD::Validator::ContextualValidatorInterface Appends the provided path to the current AVD::ExecutionContextInterface#property_path . #validate ( value : _ , constraints : Array ( AVD::Constraint ) | AVD::Constraint | Nil = nil , groups : Array ( String ) | String | AVD::Constraints::GroupSequence | Nil = nil ) : AVD::Validator::ContextualValidatorInterface Validates the provided value , optionally against the provided constraints , optionally using the provided groups . AVD::Constraint::DEFAULT_GROUP is assumed if no groups are provided. #validate_property ( object : AVD::Validatable , property_name : String , groups : Array ( String ) | String | AVD::Constraints::GroupSequence | Nil = nil ) : AVD::Validator::ContextualValidatorInterface Validates a property of the provided object against the constraints defined for that property, optionally using the provided groups . AVD::Constraint::DEFAULT_GROUP is assumed if no groups are provided. #validate_property_value ( object : AVD::Validatable , property_name : String , value : _ , groups : Array ( String ) | String | AVD::Constraints::GroupSequence | Nil = nil ) : AVD::Validator::ContextualValidatorInterface Validates a value against the constraints defined on the property of the provided object . AVD::Constraint::DEFAULT_GROUP is assumed if no groups are provided. #violations : AVD::Violation::ConstraintViolationListInterface Returns any violations that have been generated so far in the context of self .","title":"RecursiveContextualValidator"},{"location":"Validator/Validator/RecursiveContextualValidator/#Athena::Validator::Validator::RecursiveContextualValidator","text":"A recursive implementation of AVD::Validator::ContextualValidatorInterface . See Athena::Validator.validator .","title":"RecursiveContextualValidator"},{"location":"Validator/Validator/RecursiveContextualValidator/#included-modules","text":"Athena::Validator::Validator::ContextualValidatorInterface","title":"Included modules"},{"location":"Validator/Validator/RecursiveContextualValidator/#class-methods","text":"","title":"Class methods"},{"location":"Validator/Validator/RecursiveContextualValidator/#Athena::Validator::Validator::RecursiveContextualValidator.new(context,constraint_validator_factory,metadata_factory)","text":"","title":".new"},{"location":"Validator/Validator/RecursiveContextualValidator/#methods","text":"","title":"Methods"},{"location":"Validator/Validator/RecursiveContextualValidator/#Athena::Validator::Validator::RecursiveContextualValidator#at_path(path)","text":"Appends the provided path to the current AVD::ExecutionContextInterface#property_path .","title":"#at_path"},{"location":"Validator/Validator/RecursiveContextualValidator/#Athena::Validator::Validator::RecursiveContextualValidator#validate(value,constraints,groups)","text":"Validates the provided value , optionally against the provided constraints , optionally using the provided groups . AVD::Constraint::DEFAULT_GROUP is assumed if no groups are provided.","title":"#validate"},{"location":"Validator/Validator/RecursiveContextualValidator/#Athena::Validator::Validator::RecursiveContextualValidator#validate_property(object,property_name,groups)","text":"Validates a property of the provided object against the constraints defined for that property, optionally using the provided groups . AVD::Constraint::DEFAULT_GROUP is assumed if no groups are provided.","title":"#validate_property"},{"location":"Validator/Validator/RecursiveContextualValidator/#Athena::Validator::Validator::RecursiveContextualValidator#validate_property_value(object,property_name,value,groups)","text":"Validates a value against the constraints defined on the property of the provided object . AVD::Constraint::DEFAULT_GROUP is assumed if no groups are provided.","title":"#validate_property_value"},{"location":"Validator/Validator/RecursiveContextualValidator/#Athena::Validator::Validator::RecursiveContextualValidator#violations()","text":"Returns any violations that have been generated so far in the context of self .","title":"#violations"},{"location":"Validator/Validator/RecursiveValidator/","text":"class Athena::Validator::Validator::RecursiveValidator inherits Reference A recursive implementation of AVD::Validator::ValidatorInterface . See Athena::Validator.validator . Included modules Athena::Validator::Validator::ValidatorInterface Class methods .new ( validator_factory : AVD::ConstraintValidatorFactoryInterface? = nil , metadata_factory : AVD::Metadata::MetadataFactoryInterface? = nil ) Methods #in_context ( context : AVD::ExecutionContextInterface ) : AVD::Validator::ContextualValidatorInterface Returns a validator in the provided context . Violations generated by the returned validator are added to the provided context . #start_context ( root = nil ) : AVD::Validator::ContextualValidatorInterface Creates a new AVD::ExecutionContextInterface and returns a new validator for that context. Violations generated by the returned validator can be accessed via AVD::Validator::ContextualValidatorInterface#violations . #validate ( value : _ , constraints : Array ( AVD::Constraint ) | AVD::Constraint | Nil = nil , groups : Array ( String ) | String | AVD::Constraints::GroupSequence | Nil = nil ) : AVD::Violation::ConstraintViolationListInterface Validates the provided value , optionally against the provided constraints , optionally using the provided groups . AVD::Constraint::DEFAULT_GROUP is assumed if no groups are provided. #validate_property ( object : AVD::Validatable , property_name : String , groups : Array ( String ) | String | AVD::Constraints::GroupSequence | Nil = nil ) : AVD::Violation::ConstraintViolationListInterface Validates a property of the provided object against the constraints defined for that property, optionally using the provided groups . AVD::Constraint::DEFAULT_GROUP is assumed if no groups are provided. #validate_property_value ( object : AVD::Validatable , property_name : String , value : _ , groups : Array ( String ) | String | AVD::Constraints::GroupSequence | Nil = nil ) : AVD::Violation::ConstraintViolationListInterface Validates a value against the constraints defined on the property of the provided object . AVD::Constraint::DEFAULT_GROUP is assumed if no groups are provided.","title":"RecursiveValidator"},{"location":"Validator/Validator/RecursiveValidator/#Athena::Validator::Validator::RecursiveValidator","text":"A recursive implementation of AVD::Validator::ValidatorInterface . See Athena::Validator.validator .","title":"RecursiveValidator"},{"location":"Validator/Validator/RecursiveValidator/#included-modules","text":"Athena::Validator::Validator::ValidatorInterface","title":"Included modules"},{"location":"Validator/Validator/RecursiveValidator/#class-methods","text":"","title":"Class methods"},{"location":"Validator/Validator/RecursiveValidator/#Athena::Validator::Validator::RecursiveValidator.new(validator_factory,metadata_factory)","text":"","title":".new"},{"location":"Validator/Validator/RecursiveValidator/#methods","text":"","title":"Methods"},{"location":"Validator/Validator/RecursiveValidator/#Athena::Validator::Validator::RecursiveValidator#in_context(context)","text":"Returns a validator in the provided context . Violations generated by the returned validator are added to the provided context .","title":"#in_context"},{"location":"Validator/Validator/RecursiveValidator/#Athena::Validator::Validator::RecursiveValidator#start_context(root)","text":"Creates a new AVD::ExecutionContextInterface and returns a new validator for that context. Violations generated by the returned validator can be accessed via AVD::Validator::ContextualValidatorInterface#violations .","title":"#start_context"},{"location":"Validator/Validator/RecursiveValidator/#Athena::Validator::Validator::RecursiveValidator#validate(value,constraints,groups)","text":"Validates the provided value , optionally against the provided constraints , optionally using the provided groups . AVD::Constraint::DEFAULT_GROUP is assumed if no groups are provided.","title":"#validate"},{"location":"Validator/Validator/RecursiveValidator/#Athena::Validator::Validator::RecursiveValidator#validate_property(object,property_name,groups)","text":"Validates a property of the provided object against the constraints defined for that property, optionally using the provided groups . AVD::Constraint::DEFAULT_GROUP is assumed if no groups are provided.","title":"#validate_property"},{"location":"Validator/Validator/RecursiveValidator/#Athena::Validator::Validator::RecursiveValidator#validate_property_value(object,property_name,value,groups)","text":"Validates a value against the constraints defined on the property of the provided object . AVD::Constraint::DEFAULT_GROUP is assumed if no groups are provided.","title":"#validate_property_value"},{"location":"Validator/Validator/ValidatorInterface/","text":"module Athena::Validator::Validator::ValidatorInterface Direct including types Athena::Validator::Spec::MockValidator Athena::Validator::Validator::RecursiveValidator Methods abstract #in_context ( context : AVD::ExecutionContextInterface ) : AVD::Validator::ContextualValidatorInterface Returns a validator in the provided context . Violations generated by the returned validator are added to the provided context . abstract #start_context : AVD::Validator::ContextualValidatorInterface Creates a new AVD::ExecutionContextInterface and returns a new validator for that context. Violations generated by the returned validator can be accessed via AVD::Validator::ContextualValidatorInterface#violations . abstract #validate ( value : _ , constraints : Array ( AVD::Constraint ) | AVD::Constraint | Nil = nil , groups : Array ( String ) | String | AVD::Constraints::GroupSequence | Nil = nil ) : AVD::Violation::ConstraintViolationListInterface Validates the provided value , optionally against the provided constraints , optionally using the provided groups . AVD::Constraint::DEFAULT_GROUP is assumed if no groups are provided. abstract #validate_property ( object : AVD::Validatable , property_name : String , groups : Array ( String ) | String | AVD::Constraints::GroupSequence | Nil = nil ) : AVD::Violation::ConstraintViolationListInterface Validates a property of the provided object against the constraints defined for that property, optionally using the provided groups . AVD::Constraint::DEFAULT_GROUP is assumed if no groups are provided. abstract #validate_property_value ( object : AVD::Validatable , property_name : String , value : _ , groups : Array ( String ) | String | AVD::Constraints::GroupSequence | Nil = nil ) : AVD::Violation::ConstraintViolationListInterface Validates a value against the constraints defined on the property of the provided object . AVD::Constraint::DEFAULT_GROUP is assumed if no groups are provided.","title":"ValidatorInterface"},{"location":"Validator/Validator/ValidatorInterface/#Athena::Validator::Validator::ValidatorInterface","text":"","title":"ValidatorInterface"},{"location":"Validator/Validator/ValidatorInterface/#direct-including-types","text":"Athena::Validator::Spec::MockValidator Athena::Validator::Validator::RecursiveValidator","title":"Direct including types"},{"location":"Validator/Validator/ValidatorInterface/#methods","text":"","title":"Methods"},{"location":"Validator/Validator/ValidatorInterface/#Athena::Validator::Validator::ValidatorInterface#in_context(context)","text":"Returns a validator in the provided context . Violations generated by the returned validator are added to the provided context .","title":"#in_context"},{"location":"Validator/Validator/ValidatorInterface/#Athena::Validator::Validator::ValidatorInterface#start_context()","text":"Creates a new AVD::ExecutionContextInterface and returns a new validator for that context. Violations generated by the returned validator can be accessed via AVD::Validator::ContextualValidatorInterface#violations .","title":"#start_context"},{"location":"Validator/Validator/ValidatorInterface/#Athena::Validator::Validator::ValidatorInterface#validate(value,constraints,groups)","text":"Validates the provided value , optionally against the provided constraints , optionally using the provided groups . AVD::Constraint::DEFAULT_GROUP is assumed if no groups are provided.","title":"#validate"},{"location":"Validator/Validator/ValidatorInterface/#Athena::Validator::Validator::ValidatorInterface#validate_property(object,property_name,groups)","text":"Validates a property of the provided object against the constraints defined for that property, optionally using the provided groups . AVD::Constraint::DEFAULT_GROUP is assumed if no groups are provided.","title":"#validate_property"},{"location":"Validator/Validator/ValidatorInterface/#Athena::Validator::Validator::ValidatorInterface#validate_property_value(object,property_name,value,groups)","text":"Validates a value against the constraints defined on the property of the provided object . AVD::Constraint::DEFAULT_GROUP is assumed if no groups are provided.","title":"#validate_property_value"},{"location":"Validator/Violation/","text":"module Athena::Validator::Violation Contains types related to constraint violations.","title":"Violation"},{"location":"Validator/Violation/#Athena::Validator::Violation","text":"Contains types related to constraint violations.","title":"Violation"},{"location":"Validator/Violation/ConstraintViolation/","text":"struct Athena::Validator::Violation::ConstraintViolation(Root) inherits Struct Basic implementation of AVD::Violation::ConstraintViolationInterface . Included modules Athena::Validator::Violation::ConstraintViolationInterface Class methods .new ( message : String , message_template : String ?, parameters : Hash ( String , String ), root : Root , property_path : String , invalid_value_container : AVD :: Container , plural : Int32 ? = nil , code : String ? = nil , constraint : AVD::Constraint? = nil , cause : String ? = nil ) Methods #== ( other : self ) : Bool Returns true if other is the same as self , otherwise false . #cause : String ? Returns the cause of the violation. #code : String ? Returns a unique machine readable error code representing self. All constraints of a specific \"type\" should have the same code. #constraint : AVD::Constraint Returns the AVD::Constraint whose validation caused the violation, if any. #constraint? : AVD::Constraint? :inherit: #invalid_value Returns the value that caused the violation. #message : String Returns the violation message. #message_template : String ? Returns the raw violation message. The message template contains placeholders for the parameters returned via #parameters . #parameters : Hash ( String , String ) Returns the parameters used to render the #message_template . #plural : Int32 ? Returns a number used to pluralize the violation message. The returned value is used to determine the right plurlaization form. #property_path : String Returns the path from the root element to the violation. #root : Root Returns the element originally passed to the validator. #to_json ( builder : JSON :: Builder ) : Nil Returns a JSON representation of self . #to_s ( io : IO ) : Nil Returns a string representation of self .","title":"ConstraintViolation"},{"location":"Validator/Violation/ConstraintViolation/#Athena::Validator::Violation::ConstraintViolation","text":"Basic implementation of AVD::Violation::ConstraintViolationInterface .","title":"ConstraintViolation"},{"location":"Validator/Violation/ConstraintViolation/#included-modules","text":"Athena::Validator::Violation::ConstraintViolationInterface","title":"Included modules"},{"location":"Validator/Violation/ConstraintViolation/#class-methods","text":"","title":"Class methods"},{"location":"Validator/Violation/ConstraintViolation/#Athena::Validator::Violation::ConstraintViolation.new(message,message_template,parameters,root,property_path,invalid_value_container,plural,code,constraint,cause)","text":"","title":".new"},{"location":"Validator/Violation/ConstraintViolation/#methods","text":"","title":"Methods"},{"location":"Validator/Violation/ConstraintViolation/#Athena::Validator::Violation::ConstraintViolation#==(other)","text":"Returns true if other is the same as self , otherwise false .","title":"#=="},{"location":"Validator/Violation/ConstraintViolation/#Athena::Validator::Violation::ConstraintViolation#cause()","text":"Returns the cause of the violation.","title":"#cause"},{"location":"Validator/Violation/ConstraintViolation/#Athena::Validator::Violation::ConstraintViolation#code()","text":"Returns a unique machine readable error code representing self. All constraints of a specific \"type\" should have the same code.","title":"#code"},{"location":"Validator/Violation/ConstraintViolation/#Athena::Validator::Violation::ConstraintViolation#constraint()","text":"Returns the AVD::Constraint whose validation caused the violation, if any.","title":"#constraint"},{"location":"Validator/Violation/ConstraintViolation/#Athena::Validator::Violation::ConstraintViolation#constraint?()","text":":inherit:","title":"#constraint?"},{"location":"Validator/Violation/ConstraintViolation/#Athena::Validator::Violation::ConstraintViolation#invalid_value()","text":"Returns the value that caused the violation.","title":"#invalid_value"},{"location":"Validator/Violation/ConstraintViolation/#Athena::Validator::Violation::ConstraintViolation#message()","text":"Returns the violation message.","title":"#message"},{"location":"Validator/Violation/ConstraintViolation/#Athena::Validator::Violation::ConstraintViolation#message_template()","text":"Returns the raw violation message. The message template contains placeholders for the parameters returned via #parameters .","title":"#message_template"},{"location":"Validator/Violation/ConstraintViolation/#Athena::Validator::Violation::ConstraintViolation#parameters()","text":"Returns the parameters used to render the #message_template .","title":"#parameters"},{"location":"Validator/Violation/ConstraintViolation/#Athena::Validator::Violation::ConstraintViolation#plural()","text":"Returns a number used to pluralize the violation message. The returned value is used to determine the right plurlaization form.","title":"#plural"},{"location":"Validator/Violation/ConstraintViolation/#Athena::Validator::Violation::ConstraintViolation#property_path()","text":"Returns the path from the root element to the violation.","title":"#property_path"},{"location":"Validator/Violation/ConstraintViolation/#Athena::Validator::Violation::ConstraintViolation#root()","text":"Returns the element originally passed to the validator.","title":"#root"},{"location":"Validator/Violation/ConstraintViolation/#Athena::Validator::Violation::ConstraintViolation#to_json(builder)","text":"Returns a JSON representation of self .","title":"#to_json"},{"location":"Validator/Violation/ConstraintViolation/#Athena::Validator::Violation::ConstraintViolation#to_s(io)","text":"Returns a string representation of self .","title":"#to_s"},{"location":"Validator/Violation/ConstraintViolationBuilder/","text":"class Athena::Validator::Violation::ConstraintViolationBuilder(Root) inherits Reference Basic implementation of AVD::Violation::ConstraintViolationBuilderInterface . Included modules Athena::Validator::Violation::ConstraintViolationBuilderInterface Class methods .new ( violations : AVD::Violation::ConstraintViolationListInterface , constraint : AVD::Constraint? , message : String , parameters : Hash ( String , String ), root : Root , property_path : String , invalid_value : AVD :: Container ) Methods #add : Nil Adds the violation to the current AVD::ExecutionContextInterface . #add_parameter ( key : String , value : _ ) : AVD::Violation::ConstraintViolationBuilderInterface Adds a parameter with the provided key and value to the violations' AVD::Violation::ConstraintViolationInterface#parameters . The provided value is stringified via #to_s before being added to the parameters. Returns self for chaining. #at_path ( path : String ) : AVD::Violation::ConstraintViolationBuilderInterface Sets the AVD::Violation::ConstraintViolationInterface#property_path . Returns self for chaining. #cause ( cause : String ?) : AVD::Violation::ConstraintViolationBuilderInterface Sets the AVD::Violation::ConstraintViolationInterface#cause Returns self for chaining. #code ( code : String ?) : AVD::Violation::ConstraintViolationBuilderInterface Sets the AVD::Violation::ConstraintViolationInterface#code Returns self for chaining. #constraint ( constraint : AVD::Constraint? ) : AVD::Violation::ConstraintViolationBuilderInterface Sets the AVD::Violation::ConstraintViolationInterface#constraint Returns self for chaining. #invalid_value ( value : _ ) : AVD::Violation::ConstraintViolationBuilderInterface Sets the AVD::Violation::ConstraintViolationInterface#invalid_value Returns self for chaining. #plural ( plural : Int32 ) : AVD::Violation::ConstraintViolationBuilderInterface Sets AVD::Violation::ConstraintViolationInterface#plural Returns self for chaining. #set_parameters ( parameters : Hash ( String , String )) : AVD::Violation::ConstraintViolationBuilderInterface Overrides the entire AVD::Violation::ConstraintViolationInterface#parameters hash with the provided parameters . Returns self for chaining.","title":"ConstraintViolationBuilder"},{"location":"Validator/Violation/ConstraintViolationBuilder/#Athena::Validator::Violation::ConstraintViolationBuilder","text":"Basic implementation of AVD::Violation::ConstraintViolationBuilderInterface .","title":"ConstraintViolationBuilder"},{"location":"Validator/Violation/ConstraintViolationBuilder/#included-modules","text":"Athena::Validator::Violation::ConstraintViolationBuilderInterface","title":"Included modules"},{"location":"Validator/Violation/ConstraintViolationBuilder/#class-methods","text":"","title":"Class methods"},{"location":"Validator/Violation/ConstraintViolationBuilder/#Athena::Validator::Violation::ConstraintViolationBuilder.new(violations,constraint,message,parameters,root,property_path,invalid_value)","text":"","title":".new"},{"location":"Validator/Violation/ConstraintViolationBuilder/#methods","text":"","title":"Methods"},{"location":"Validator/Violation/ConstraintViolationBuilder/#Athena::Validator::Violation::ConstraintViolationBuilder#add()","text":"Adds the violation to the current AVD::ExecutionContextInterface .","title":"#add"},{"location":"Validator/Violation/ConstraintViolationBuilder/#Athena::Validator::Violation::ConstraintViolationBuilder#add_parameter(key,value)","text":"Adds a parameter with the provided key and value to the violations' AVD::Violation::ConstraintViolationInterface#parameters . The provided value is stringified via #to_s before being added to the parameters. Returns self for chaining.","title":"#add_parameter"},{"location":"Validator/Violation/ConstraintViolationBuilder/#Athena::Validator::Violation::ConstraintViolationBuilder#at_path(path)","text":"Sets the AVD::Violation::ConstraintViolationInterface#property_path . Returns self for chaining.","title":"#at_path"},{"location":"Validator/Violation/ConstraintViolationBuilder/#Athena::Validator::Violation::ConstraintViolationBuilder#cause(cause)","text":"Sets the AVD::Violation::ConstraintViolationInterface#cause Returns self for chaining.","title":"#cause"},{"location":"Validator/Violation/ConstraintViolationBuilder/#Athena::Validator::Violation::ConstraintViolationBuilder#code(code)","text":"Sets the AVD::Violation::ConstraintViolationInterface#code Returns self for chaining.","title":"#code"},{"location":"Validator/Violation/ConstraintViolationBuilder/#Athena::Validator::Violation::ConstraintViolationBuilder#constraint(constraint)","text":"Sets the AVD::Violation::ConstraintViolationInterface#constraint Returns self for chaining.","title":"#constraint"},{"location":"Validator/Violation/ConstraintViolationBuilder/#Athena::Validator::Violation::ConstraintViolationBuilder#invalid_value(value)","text":"Sets the AVD::Violation::ConstraintViolationInterface#invalid_value Returns self for chaining.","title":"#invalid_value"},{"location":"Validator/Violation/ConstraintViolationBuilder/#Athena::Validator::Violation::ConstraintViolationBuilder#plural(plural)","text":"Sets AVD::Violation::ConstraintViolationInterface#plural Returns self for chaining.","title":"#plural"},{"location":"Validator/Violation/ConstraintViolationBuilder/#Athena::Validator::Violation::ConstraintViolationBuilder#set_parameters(parameters)","text":"Overrides the entire AVD::Violation::ConstraintViolationInterface#parameters hash with the provided parameters . Returns self for chaining.","title":"#set_parameters"},{"location":"Validator/Violation/ConstraintViolationBuilderInterface/","text":"module Athena::Validator::Violation::ConstraintViolationBuilderInterface A Builder Pattern type for building AVD::Violation::ConstraintViolationInterface s. Allows using the methods defined on self to construct the desired violation before adding it to the context. Direct including types Athena::Validator::Violation::ConstraintViolationBuilder(Root) Methods abstract #add : Nil Adds the violation to the current AVD::ExecutionContextInterface . abstract #add_parameter ( key : String , value : _ ) : AVD::Violation::ConstraintViolationBuilderInterface Adds a parameter with the provided key and value to the violations' AVD::Violation::ConstraintViolationInterface#parameters . The provided value is stringified via #to_s before being added to the parameters. Returns self for chaining. abstract #at_path ( path : String ) : AVD::Violation::ConstraintViolationBuilderInterface Sets the AVD::Violation::ConstraintViolationInterface#property_path . Returns self for chaining. abstract #cause ( cause : String ?) : AVD::Violation::ConstraintViolationBuilderInterface Sets the AVD::Violation::ConstraintViolationInterface#cause Returns self for chaining. abstract #code ( code : String ?) : AVD::Violation::ConstraintViolationBuilderInterface Sets the AVD::Violation::ConstraintViolationInterface#code Returns self for chaining. abstract #constraint ( constraint : AVD::Constraint? ) : AVD::Violation::ConstraintViolationBuilderInterface Sets the AVD::Violation::ConstraintViolationInterface#constraint Returns self for chaining. abstract #invalid_value ( value : _ ) : AVD::Violation::ConstraintViolationBuilderInterface Sets the AVD::Violation::ConstraintViolationInterface#invalid_value Returns self for chaining. abstract #plural ( number : Int32 ) : AVD::Violation::ConstraintViolationBuilderInterface Sets AVD::Violation::ConstraintViolationInterface#plural Returns self for chaining. abstract #set_parameters ( parameters : Hash ( String , String )) : AVD::Violation::ConstraintViolationBuilderInterface Overrides the entire AVD::Violation::ConstraintViolationInterface#parameters hash with the provided parameters . Returns self for chaining.","title":"ConstraintViolationBuilderInterface"},{"location":"Validator/Violation/ConstraintViolationBuilderInterface/#Athena::Validator::Violation::ConstraintViolationBuilderInterface","text":"A Builder Pattern type for building AVD::Violation::ConstraintViolationInterface s. Allows using the methods defined on self to construct the desired violation before adding it to the context.","title":"ConstraintViolationBuilderInterface"},{"location":"Validator/Violation/ConstraintViolationBuilderInterface/#direct-including-types","text":"Athena::Validator::Violation::ConstraintViolationBuilder(Root)","title":"Direct including types"},{"location":"Validator/Violation/ConstraintViolationBuilderInterface/#methods","text":"","title":"Methods"},{"location":"Validator/Violation/ConstraintViolationBuilderInterface/#Athena::Validator::Violation::ConstraintViolationBuilderInterface#add()","text":"Adds the violation to the current AVD::ExecutionContextInterface .","title":"#add"},{"location":"Validator/Violation/ConstraintViolationBuilderInterface/#Athena::Validator::Violation::ConstraintViolationBuilderInterface#add_parameter(key,value)","text":"Adds a parameter with the provided key and value to the violations' AVD::Violation::ConstraintViolationInterface#parameters . The provided value is stringified via #to_s before being added to the parameters. Returns self for chaining.","title":"#add_parameter"},{"location":"Validator/Violation/ConstraintViolationBuilderInterface/#Athena::Validator::Violation::ConstraintViolationBuilderInterface#at_path(path)","text":"Sets the AVD::Violation::ConstraintViolationInterface#property_path . Returns self for chaining.","title":"#at_path"},{"location":"Validator/Violation/ConstraintViolationBuilderInterface/#Athena::Validator::Violation::ConstraintViolationBuilderInterface#cause(cause)","text":"Sets the AVD::Violation::ConstraintViolationInterface#cause Returns self for chaining.","title":"#cause"},{"location":"Validator/Violation/ConstraintViolationBuilderInterface/#Athena::Validator::Violation::ConstraintViolationBuilderInterface#code(code)","text":"Sets the AVD::Violation::ConstraintViolationInterface#code Returns self for chaining.","title":"#code"},{"location":"Validator/Violation/ConstraintViolationBuilderInterface/#Athena::Validator::Violation::ConstraintViolationBuilderInterface#constraint(constraint)","text":"Sets the AVD::Violation::ConstraintViolationInterface#constraint Returns self for chaining.","title":"#constraint"},{"location":"Validator/Violation/ConstraintViolationBuilderInterface/#Athena::Validator::Violation::ConstraintViolationBuilderInterface#invalid_value(value)","text":"Sets the AVD::Violation::ConstraintViolationInterface#invalid_value Returns self for chaining.","title":"#invalid_value"},{"location":"Validator/Violation/ConstraintViolationBuilderInterface/#Athena::Validator::Violation::ConstraintViolationBuilderInterface#plural(number)","text":"Sets AVD::Violation::ConstraintViolationInterface#plural Returns self for chaining.","title":"#plural"},{"location":"Validator/Violation/ConstraintViolationBuilderInterface/#Athena::Validator::Violation::ConstraintViolationBuilderInterface#set_parameters(parameters)","text":"Overrides the entire AVD::Violation::ConstraintViolationInterface#parameters hash with the provided parameters . Returns self for chaining.","title":"#set_parameters"},{"location":"Validator/Violation/ConstraintViolationInterface/","text":"module Athena::Validator::Violation::ConstraintViolationInterface Represents a violation of a constraint during validation. Each failed constraint that fails during validation; one or more violations are created. The violations store the violation message, the path to the failing element, and the root element originally passed to the validator. Direct including types Athena::Validator::Violation::ConstraintViolation(Root) Methods abstract #cause : String ? Returns the cause of the violation. abstract #code : String ? Returns a unique machine readable error code representing self. All constraints of a specific \"type\" should have the same code. abstract #constraint : AVD::Constraint? Returns the AVD::Constraint whose validation caused the violation, if any. abstract #invalid_value Returns the value that caused the violation. abstract #message : String Returns the violation message. abstract #message_template : String ? Returns the raw violation message. The message template contains placeholders for the parameters returned via #parameters . abstract #parameters : Hash ( String , String ) Returns the parameters used to render the #message_template . abstract #plural : Int32 ? Returns a number used to pluralize the violation message. The returned value is used to determine the right plurlaization form. abstract #property_path : String Returns the path from the root element to the violation. abstract #root Returns the element originally passed to the validator. abstract #to_json ( builder : JSON :: Builder ) : Nil Returns a JSON representation of self . abstract #to_s ( io : IO ) : Nil Returns a string representation of self .","title":"ConstraintViolationInterface"},{"location":"Validator/Violation/ConstraintViolationInterface/#Athena::Validator::Violation::ConstraintViolationInterface","text":"Represents a violation of a constraint during validation. Each failed constraint that fails during validation; one or more violations are created. The violations store the violation message, the path to the failing element, and the root element originally passed to the validator.","title":"ConstraintViolationInterface"},{"location":"Validator/Violation/ConstraintViolationInterface/#direct-including-types","text":"Athena::Validator::Violation::ConstraintViolation(Root)","title":"Direct including types"},{"location":"Validator/Violation/ConstraintViolationInterface/#methods","text":"","title":"Methods"},{"location":"Validator/Violation/ConstraintViolationInterface/#Athena::Validator::Violation::ConstraintViolationInterface#cause()","text":"Returns the cause of the violation.","title":"#cause"},{"location":"Validator/Violation/ConstraintViolationInterface/#Athena::Validator::Violation::ConstraintViolationInterface#code()","text":"Returns a unique machine readable error code representing self. All constraints of a specific \"type\" should have the same code.","title":"#code"},{"location":"Validator/Violation/ConstraintViolationInterface/#Athena::Validator::Violation::ConstraintViolationInterface#constraint()","text":"Returns the AVD::Constraint whose validation caused the violation, if any.","title":"#constraint"},{"location":"Validator/Violation/ConstraintViolationInterface/#Athena::Validator::Violation::ConstraintViolationInterface#invalid_value()","text":"Returns the value that caused the violation.","title":"#invalid_value"},{"location":"Validator/Violation/ConstraintViolationInterface/#Athena::Validator::Violation::ConstraintViolationInterface#message()","text":"Returns the violation message.","title":"#message"},{"location":"Validator/Violation/ConstraintViolationInterface/#Athena::Validator::Violation::ConstraintViolationInterface#message_template()","text":"Returns the raw violation message. The message template contains placeholders for the parameters returned via #parameters .","title":"#message_template"},{"location":"Validator/Violation/ConstraintViolationInterface/#Athena::Validator::Violation::ConstraintViolationInterface#parameters()","text":"Returns the parameters used to render the #message_template .","title":"#parameters"},{"location":"Validator/Violation/ConstraintViolationInterface/#Athena::Validator::Violation::ConstraintViolationInterface#plural()","text":"Returns a number used to pluralize the violation message. The returned value is used to determine the right plurlaization form.","title":"#plural"},{"location":"Validator/Violation/ConstraintViolationInterface/#Athena::Validator::Violation::ConstraintViolationInterface#property_path()","text":"Returns the path from the root element to the violation.","title":"#property_path"},{"location":"Validator/Violation/ConstraintViolationInterface/#Athena::Validator::Violation::ConstraintViolationInterface#root()","text":"Returns the element originally passed to the validator.","title":"#root"},{"location":"Validator/Violation/ConstraintViolationInterface/#Athena::Validator::Violation::ConstraintViolationInterface#to_json(builder)","text":"Returns a JSON representation of self .","title":"#to_json"},{"location":"Validator/Violation/ConstraintViolationInterface/#Athena::Validator::Violation::ConstraintViolationInterface#to_s(io)","text":"Returns a string representation of self .","title":"#to_s"},{"location":"Validator/Violation/ConstraintViolationList/","text":"struct Athena::Validator::Violation::ConstraintViolationList inherits Struct Basic implementation of AVD::Violation::ConstraintViolationListInterface . Included modules Athena::Validator::Violation::ConstraintViolationListInterface Indexable Class methods .new ( violations : Array ( AVD::Violation::ConstraintViolationInterface ) = [] of AVD :: Violation :: ConstraintViolationInterface ) Methods #add ( violation : AVD::Violation::ConstraintViolationInterface ) : Nil Adds the provided violation to self . #add ( violations : AVD::Violation::ConstraintViolationListInterface ) : Nil Adds each of the provided violations to self . #find_by_code ( error_code : String ) : AVD::Violation::ConstraintViolationListInterface Returns a new AVD::Violation::ConstraintViolationInterface that conists only of violations with the provided error_code . #has? ( index : Int ) : Bool Returns true if a violation exists at the provided index , otherwise false . #remove ( index : Int ) : Nil Returns the violation at the provided index . #set ( index : Int , violation : AVD::Violation::ConstraintViolationInterface ) : Nil Sets the provided violation at the provided index . #size : Int Returns the number of elements in this container. #to_json ( builder : JSON :: Builder ) : Nil Returns a JSON representation of self . #to_s ( io : IO ) : Nil Returns a string representation of self .","title":"ConstraintViolationList"},{"location":"Validator/Violation/ConstraintViolationList/#Athena::Validator::Violation::ConstraintViolationList","text":"Basic implementation of AVD::Violation::ConstraintViolationListInterface .","title":"ConstraintViolationList"},{"location":"Validator/Violation/ConstraintViolationList/#included-modules","text":"Athena::Validator::Violation::ConstraintViolationListInterface Indexable","title":"Included modules"},{"location":"Validator/Violation/ConstraintViolationList/#class-methods","text":"","title":"Class methods"},{"location":"Validator/Violation/ConstraintViolationList/#Athena::Validator::Violation::ConstraintViolationList.new(violations)","text":"","title":".new"},{"location":"Validator/Violation/ConstraintViolationList/#methods","text":"","title":"Methods"},{"location":"Validator/Violation/ConstraintViolationList/#Athena::Validator::Violation::ConstraintViolationList#add(violation)","text":"Adds the provided violation to self .","title":"#add"},{"location":"Validator/Violation/ConstraintViolationList/#Athena::Validator::Violation::ConstraintViolationList#find_by_code(error_code)","text":"Returns a new AVD::Violation::ConstraintViolationInterface that conists only of violations with the provided error_code .","title":"#find_by_code"},{"location":"Validator/Violation/ConstraintViolationList/#Athena::Validator::Violation::ConstraintViolationList#has?(index)","text":"Returns true if a violation exists at the provided index , otherwise false .","title":"#has?"},{"location":"Validator/Violation/ConstraintViolationList/#Athena::Validator::Violation::ConstraintViolationList#remove(index)","text":"Returns the violation at the provided index .","title":"#remove"},{"location":"Validator/Violation/ConstraintViolationList/#Athena::Validator::Violation::ConstraintViolationList#set(index,violation)","text":"Sets the provided violation at the provided index .","title":"#set"},{"location":"Validator/Violation/ConstraintViolationList/#Athena::Validator::Violation::ConstraintViolationList#size()","text":"Returns the number of elements in this container.","title":"#size"},{"location":"Validator/Violation/ConstraintViolationList/#Athena::Validator::Violation::ConstraintViolationList#to_json(builder)","text":"Returns a JSON representation of self .","title":"#to_json"},{"location":"Validator/Violation/ConstraintViolationList/#Athena::Validator::Violation::ConstraintViolationList#to_s(io)","text":"Returns a string representation of self .","title":"#to_s"},{"location":"Validator/Violation/ConstraintViolationListInterface/","text":"module Athena::Validator::Violation::ConstraintViolationListInterface A wrapper type around an Array(AVD::ConstraintViolationInterface) . Direct including types Athena::Validator::Violation::ConstraintViolationList Methods abstract #add ( violation : AVD::Violation::ConstraintViolationInterface ) : Nil Adds the provided violation to self . abstract #add ( violations : AVD::Violation::ConstraintViolationListInterface ) : Nil Adds each of the provided violations to self . abstract #has? ( index : Int ) : Bool Returns true if a violation exists at the provided index , otherwise false . abstract #remove ( index : Int ) : Nil Returns the violation at the provided index . abstract #set ( index : Int , violation : AVD::Violation::ConstraintViolationInterface ) : Nil Sets the provided violation at the provided index . abstract #size : Int Returns the number of violations in self . abstract #to_json ( builder : JSON :: Builder ) : Nil Returns a JSON representation of self . abstract #to_s ( io : IO ) : Nil Returns a string representation of self .","title":"ConstraintViolationListInterface"},{"location":"Validator/Violation/ConstraintViolationListInterface/#Athena::Validator::Violation::ConstraintViolationListInterface","text":"A wrapper type around an Array(AVD::ConstraintViolationInterface) .","title":"ConstraintViolationListInterface"},{"location":"Validator/Violation/ConstraintViolationListInterface/#direct-including-types","text":"Athena::Validator::Violation::ConstraintViolationList","title":"Direct including types"},{"location":"Validator/Violation/ConstraintViolationListInterface/#methods","text":"","title":"Methods"},{"location":"Validator/Violation/ConstraintViolationListInterface/#Athena::Validator::Violation::ConstraintViolationListInterface#add(violation)","text":"Adds the provided violation to self .","title":"#add"},{"location":"Validator/Violation/ConstraintViolationListInterface/#Athena::Validator::Violation::ConstraintViolationListInterface#has?(index)","text":"Returns true if a violation exists at the provided index , otherwise false .","title":"#has?"},{"location":"Validator/Violation/ConstraintViolationListInterface/#Athena::Validator::Violation::ConstraintViolationListInterface#remove(index)","text":"Returns the violation at the provided index .","title":"#remove"},{"location":"Validator/Violation/ConstraintViolationListInterface/#Athena::Validator::Violation::ConstraintViolationListInterface#set(index,violation)","text":"Sets the provided violation at the provided index .","title":"#set"},{"location":"Validator/Violation/ConstraintViolationListInterface/#Athena::Validator::Violation::ConstraintViolationListInterface#size()","text":"Returns the number of violations in self .","title":"#size"},{"location":"Validator/Violation/ConstraintViolationListInterface/#Athena::Validator::Violation::ConstraintViolationListInterface#to_json(builder)","text":"Returns a JSON representation of self .","title":"#to_json"},{"location":"Validator/Violation/ConstraintViolationListInterface/#Athena::Validator::Violation::ConstraintViolationListInterface#to_s(io)","text":"Returns a string representation of self .","title":"#to_s"},{"location":"components/","text":"This section will focus on how each component is integrated into Athena, as well an overview of the overall design of Athena. At a high level Athena's job is to interpret a request and create the appropriate response based on your application logic . Conceptually this could be broken down into three steps: Consume the request Apply application logic to determine what the response should be Return the response Steps 1 and 3 are handled via Crystal's HTTP::Server , while step 2 is where Athena fits in. Powered By Events Athena is an event based framework, meaning it emits various events via the Event Dispatcher component during the life-cycle of a request. These events are listened on internally in order to handle each request; custom listeners on these events can also be registered. The flow of a request, and the related events that are dispatched, is depicted below in a visual format: 1. Request Event The very first event that is dispatched is the ART::Events::Request event and can have a variety of listeners. The primary purpose of this event is to create an ART::Response directly, or to add information to the requests' attributes; a simple key/value store tied to request instance accessible via HTTP::Request#attributes . In some cases the listener may have enough information to return an ART::Response immediately. An example of this would be the ART::Listeners::CORS listener. If enabled it is able to return a CORS preflight response even before routing is invoked. Warning If an ART::Response is returned at this stage, the flow of the request skips directly to the response event. Future Request event listeners will not be invoked either. Another use case for this event is populating additional data into the request's attributes; such as the locale or format of the request. Request event in Athena This is the event that ART::Listeners::Routing listens on to determine which ART::Controller / ART::Action pair should handle the request. See ART::Controller for more details on routing. 2. Action Event The next event to be dispatched is the ART::Events::Action event, assuming a response was not already returned within the request event. This event is dispatched after the related controller/action pair is determined, but before it is executed. This event is intended to be used when a listener requires information from the related ART::Action ; such as reading custom annotations off of it via the Config component. Action event in Athena This is the event that ART::Listeners::ParamConverter and ART::Listeners::ParamFetcher listen on to apply custom conversion logic via an ART::ParamConverterInterface , or resolve request parameters such as ART::QueryParam s. 3. Invoke the Controller Action This next step is not an event, but a important concept within Athena nonetheless; executing the controller action related to the current request. Argument Resolution Before Athena can call the controller action, it first needs to determine what arguments, if any, should be passed to it. This is achieved via an ART::Arguments::ArgumentResolverInterface that facilitates gathering all the arguments. One or more ART::Arguments::Resolvers::ArgumentValueResolverInterface will then be used to resolve each specific argument's value. The default algorithm is as follows: Check the request's attributes for a key that matches the name of the argument Such as as a path param or something set via a listener (either built-in or custom) Check if the type of the argument is HTTP::Request , if so use the current request object Check if the argument has a default value, or use nil if it is nilable Raise an exception if an argument's value could be not resolved Custom ArgumentValueResolverInterface s may be created & registered to extend this functionality. Todo An additional event could possibly be added after the arguments have been resolved, but before invoking the controller action. Execute the Controller Action The job of a controller action is to apply business/application logic to build a response for the related request; such as an HTML page, a JSON string, or anything else. How/what exactly this should be is up to the developer creating the application. Handle the Response The type of the value returned from the controller action determines what happens next. If the value is an ART::Response , then it is used as is, skipping directly to the response event. However, if the value is NOT an ART::Response , then the view is dispatched (since Athena needs an ART::Response in order to have something to send back to the client). 4. View Event The ART::Events::View event is only dispatched when the controller action does NOT return an ART::Response . The purpose of this event is to turn the controller action's return value into an ART::Response . This event is intended to be used as a \"View\" layer; allowing scalar values/objects to be returned while listeners convert that value to the expected format (e.g. JSON, HTML, etc.). View event in Athena By default Athena will JSON serialize any non ART::Response values. 5. Response Event The end goal of Athena is to return an ART::Response back to the client; which might be created within the request event, returned from the related controller action, or set within the view event. Regardless of how the response was created, the ART::Events::Response event is dispatched directly after. The intended use case for this event is to allow for modifying the response object in some manner. Common examples include: add/edit headers, add cookies, change/compress the response body. 6. Return the Response The raw HTTP::Server::Response object is never directly exposed. The reasoning for this is to allow listeners to mutate the response before it is returned as mentioned in the response event section. If the raw response object was exposed, whenever any data is written to it it'll immediately be sent to the client and the status/headers will be locked; as mentioned in the Crystal API docs: The response #status and #headers must be configured before writing the response body. Once response output is written, changing the #status and #headers properties has no effect. Each ART::Response has a ART::Response::Writer instance that determines how the response should be written to the raw response's IO. By default it is written directly, but can be customized via the response , such as for compression. 7. Terminate Event The final event to be dispatched is the ART::Events::Terminate event. This is event is dispatched after the response has been sent to the user. The intended use case for this event is to perform some \"heavy\" action after the user has received the response; as to not affect the response time of the request. E.x. queuing up emails or logs to be sent/written after a successful request. 8. Exception Handling If an exception is raised at anytime while a request is being handled, the ART::Events::Exception is dispatched. The purpose of this event is to convert the exception into an ART::Response . This is globally handled via an ART::ErrorRendererInterface , with the default being to JSON serialize the exception. It is also possible to handle specific error states differently by registering multiple exception listeners to handle each case. An example of this could be to invoke some special logic only if the exception is of a specific type. See the error handling section in the getting started docs for more details on how error handling works in Athena. Orchestrated via Dependency Injection All of the components have been designed with Dependency Injection (DI) in mind; even if it's not a requirement when using a component on its own. Athena itself makes heavy use of DI as the means to orchestrate all the dependencies that do/may exist in an application. DI is used to allow for easier testing , allowing for better reusability, and sharing state between types. See the Dependency Injection component for more details on how to use it within Athena.","title":"Components"},{"location":"components/#powered-by-events","text":"Athena is an event based framework, meaning it emits various events via the Event Dispatcher component during the life-cycle of a request. These events are listened on internally in order to handle each request; custom listeners on these events can also be registered. The flow of a request, and the related events that are dispatched, is depicted below in a visual format:","title":"Powered By Events"},{"location":"components/#1-request-event","text":"The very first event that is dispatched is the ART::Events::Request event and can have a variety of listeners. The primary purpose of this event is to create an ART::Response directly, or to add information to the requests' attributes; a simple key/value store tied to request instance accessible via HTTP::Request#attributes . In some cases the listener may have enough information to return an ART::Response immediately. An example of this would be the ART::Listeners::CORS listener. If enabled it is able to return a CORS preflight response even before routing is invoked. Warning If an ART::Response is returned at this stage, the flow of the request skips directly to the response event. Future Request event listeners will not be invoked either. Another use case for this event is populating additional data into the request's attributes; such as the locale or format of the request. Request event in Athena This is the event that ART::Listeners::Routing listens on to determine which ART::Controller / ART::Action pair should handle the request. See ART::Controller for more details on routing.","title":"1. Request Event"},{"location":"components/#2-action-event","text":"The next event to be dispatched is the ART::Events::Action event, assuming a response was not already returned within the request event. This event is dispatched after the related controller/action pair is determined, but before it is executed. This event is intended to be used when a listener requires information from the related ART::Action ; such as reading custom annotations off of it via the Config component. Action event in Athena This is the event that ART::Listeners::ParamConverter and ART::Listeners::ParamFetcher listen on to apply custom conversion logic via an ART::ParamConverterInterface , or resolve request parameters such as ART::QueryParam s.","title":"2. Action Event"},{"location":"components/#3-invoke-the-controller-action","text":"This next step is not an event, but a important concept within Athena nonetheless; executing the controller action related to the current request.","title":"3. Invoke the Controller Action"},{"location":"components/#argument-resolution","text":"Before Athena can call the controller action, it first needs to determine what arguments, if any, should be passed to it. This is achieved via an ART::Arguments::ArgumentResolverInterface that facilitates gathering all the arguments. One or more ART::Arguments::Resolvers::ArgumentValueResolverInterface will then be used to resolve each specific argument's value. The default algorithm is as follows: Check the request's attributes for a key that matches the name of the argument Such as as a path param or something set via a listener (either built-in or custom) Check if the type of the argument is HTTP::Request , if so use the current request object Check if the argument has a default value, or use nil if it is nilable Raise an exception if an argument's value could be not resolved Custom ArgumentValueResolverInterface s may be created & registered to extend this functionality. Todo An additional event could possibly be added after the arguments have been resolved, but before invoking the controller action.","title":"Argument Resolution"},{"location":"components/#execute-the-controller-action","text":"The job of a controller action is to apply business/application logic to build a response for the related request; such as an HTML page, a JSON string, or anything else. How/what exactly this should be is up to the developer creating the application.","title":"Execute the Controller Action"},{"location":"components/#handle-the-response","text":"The type of the value returned from the controller action determines what happens next. If the value is an ART::Response , then it is used as is, skipping directly to the response event. However, if the value is NOT an ART::Response , then the view is dispatched (since Athena needs an ART::Response in order to have something to send back to the client).","title":"Handle the Response"},{"location":"components/#4-view-event","text":"The ART::Events::View event is only dispatched when the controller action does NOT return an ART::Response . The purpose of this event is to turn the controller action's return value into an ART::Response . This event is intended to be used as a \"View\" layer; allowing scalar values/objects to be returned while listeners convert that value to the expected format (e.g. JSON, HTML, etc.). View event in Athena By default Athena will JSON serialize any non ART::Response values.","title":"4. View Event"},{"location":"components/#5-response-event","text":"The end goal of Athena is to return an ART::Response back to the client; which might be created within the request event, returned from the related controller action, or set within the view event. Regardless of how the response was created, the ART::Events::Response event is dispatched directly after. The intended use case for this event is to allow for modifying the response object in some manner. Common examples include: add/edit headers, add cookies, change/compress the response body.","title":"5. Response Event"},{"location":"components/#6-return-the-response","text":"The raw HTTP::Server::Response object is never directly exposed. The reasoning for this is to allow listeners to mutate the response before it is returned as mentioned in the response event section. If the raw response object was exposed, whenever any data is written to it it'll immediately be sent to the client and the status/headers will be locked; as mentioned in the Crystal API docs: The response #status and #headers must be configured before writing the response body. Once response output is written, changing the #status and #headers properties has no effect. Each ART::Response has a ART::Response::Writer instance that determines how the response should be written to the raw response's IO. By default it is written directly, but can be customized via the response , such as for compression.","title":"6. Return the Response"},{"location":"components/#7-terminate-event","text":"The final event to be dispatched is the ART::Events::Terminate event. This is event is dispatched after the response has been sent to the user. The intended use case for this event is to perform some \"heavy\" action after the user has received the response; as to not affect the response time of the request. E.x. queuing up emails or logs to be sent/written after a successful request.","title":"7. Terminate Event"},{"location":"components/#8-exception-handling","text":"If an exception is raised at anytime while a request is being handled, the ART::Events::Exception is dispatched. The purpose of this event is to convert the exception into an ART::Response . This is globally handled via an ART::ErrorRendererInterface , with the default being to JSON serialize the exception. It is also possible to handle specific error states differently by registering multiple exception listeners to handle each case. An example of this could be to invoke some special logic only if the exception is of a specific type. See the error handling section in the getting started docs for more details on how error handling works in Athena.","title":"8. Exception Handling"},{"location":"components/#orchestrated-via-dependency-injection","text":"All of the components have been designed with Dependency Injection (DI) in mind; even if it's not a requirement when using a component on its own. Athena itself makes heavy use of DI as the means to orchestrate all the dependencies that do/may exist in an application. DI is used to allow for easier testing , allowing for better reusability, and sharing state between types. See the Dependency Injection component for more details on how to use it within Athena.","title":"Orchestrated via Dependency Injection"},{"location":"cookbook/","text":"This section includes a set of common types that many projects may find useful, but are not generic enough to be included within Athena itself. For example, a param converter that looks up an object from a DB based on an id path parameter and sets the object within the requests' attributes. This is a useful converter, but the exact implementation would depend on which ORM you are using.","title":"Cookbook"},{"location":"getting_started/","text":"Athena does not have any other dependencies outside of Crystal and Shards . It is designed in such a way to be non-intrusive, and not require a strict organizational convention in regards to how a project is setup; this allows it to use a minimal amount of setup boilerplate while not preventing it for more complex projects. Installation Add the dependency to your shard.yml : dependencies : athena : github : athena-framework/athena version : ~> 0.12.0 Run shards install . This will install Athena and its required dependencies. Usage Athena has a goal of being easy to start using for simple use cases, while still allowing flexibility/customizability for larger more complex use cases. Routing Athena is a MVC based framework, as such, the logic to handle a given route is defined in an ART::Controller class. require \"athena\" # Define a controller class ExampleController < ART :: Controller # Define an action to handle the related route @[ ART :: Get ( \"/\" ) ] def index : String \"Hello World\" end # The macro DSL can also be used get \"/\" do \"Hello World\" end end # Run the server ART . run # GET / # => Hello World Annotations applied to the methods are used to define the HTTP method this method handles, such as ART::Get or ART::Post . A macro DSL also exists to make them a bit less verbose; ART::Controller.get or ART::Controller.post . The ART::Route annotation can also be used to define custom HTTP methods. Controllers are simply classes and routes are simply methods. Controllers and actions can be documented/tested as you would any Crystal class/method. Route Parameters Arguments are converted to their expected types if possible, otherwise an error response is automatically returned. The values are provided directly as method arguments, thus preventing the need for env.params.url[\"name\"] and any boilerplate related to it. Just like normal method arguments, default values can be defined. The method's return type adds some type safety to ensure the expected value is being returned. require \"athena\" class ExampleController < ART :: Controller @[ ART :: Get ( \"/add/:value1/:value2\" ) ] def add ( value1 : Int32 , value2 : Int32 , negative : Bool = false ) : Int32 sum = value1 + value2 negative ? - sum : sum end end ART . run # GET /add/2/3 # => 5 # GET /add/5/5?negative=true # => -10 # GET /add/foo/12 # => {\"code\":400,\"message\":\"Required parameter 'value1' with value 'foo' could not be converted into a valid 'Int32'\"} ART::QueryParam and ART::RequestParam s are defined via annotations and map directly to the method's arguments. See the related annotation docs for more information. require \"athena\" class ExampleController < ART :: Controller @[ ART :: Get ( \"/\" ) ] @[ ART :: QueryParam ( \"page\" , requirements : /\\d{2}/ ) ] def index ( page : Int32 ) : Int32 page end end ART . run # GET / # => {\"code\":422,\"message\":\"Parameter 'page' of value '' violated a constraint: 'This value should not be null.'\\n\"} # GET /?page=10 # => 10 # GET /?page=bar # => {\"code\":400,\"message\":\"Required parameter 'page' with value 'bar' could not be converted into a valid 'Int32'.\"} # GET /?page=5 # => {\"code\":422,\"message\":\"Parameter 'page' of value '5' violated a constraint: 'Parameter 'page' value does not match requirements: (?-imsx:^(?-imsx:\\\\d{2})$)'\\n\"} Restricting an action argument to HTTP::Request will provide the raw request object. This approach is fine for simple or one-off endpoints, however for more complex/common request data processing, it is suggested to create a Param Converter . require \"athena\" class ExampleController < ART :: Controller @[ ART :: Post ( \"/data\" ) ] def data ( request : HTTP :: Request ) : String ? request . body . try &. gets_to_end end end ART . run # POST /data body: \"foo--bar\" # => \"foo--bar\" Returning Raw Data An ART::Response can be used to fully customize the response; such as returning a specific status code, adding some one-off headers. require \"athena\" require \"mime\" class ExampleController < ART :: Controller # A GET endpoint returning an `ART::Response`. # Can be used to return raw data, such as HTML or CSS etc, in a one-off manner. @[ ART :: Get ( \"/index\" ) ] def index : ART :: Response ART :: Response . new \"<h1>Welcome to my website!</h1>\" , headers : HTTP :: Headers { \"content-type\" => MIME . from_extension ( \".html\" )} end end ART . run # GET /index # => \"<h1>Welcome to my website!</h1>\" An ART::Events::View is emitted if the returned value is NOT an ART::Response . By default, non ART::Response s are JSON serialized. However, this event can be listened on to customize how the value is serialized. Streaming Response By default ART::Response content is written all at once to the response's IO . However in some cases the content may be too large to fit into memory. In this case an ART::StreamedResponse may be used to stream the content back to the client. require \"athena\" require \"mime\" class ExampleController < ART :: Controller @[ ART :: Get ( path : \"/users\" ) ] def users : ART :: Response ART :: StreamedResponse . new headers : HTTP :: Headers { \"content-type\" => \"application/json; charset=UTF-8\" } do | io | User . all . to_json io end end end ART . run # GET /athena/users\" # => [{\"id\":1,...},...] URL Generation A common use case, especially when rendering HTML , is generating links to other routes based on a set of provided parameters. Parameters that do not map to a controller action argument are added as query params. require \"athena\" class ExampleController < ART :: Controller # Define a route to redirect to, explicitly naming this route `add`. # The default route name is controller + method down snake-cased; e.x. `example_controller_add`. @[ ART :: Get ( \"/add/:value1/:value2\" , name : \"add\" ) ] def add ( value1 : Int32 , value2 : Int32 , negative : Bool = false ) : Int32 sum = value1 + value2 negative ? - sum : sum end # Define a route that redirects to the `add` route with fixed parameters. @[ ART :: Get ( \"/\" ) ] def redirect : ART :: RedirectResponse # Generate a link to the other route. url = self . generate_url \"add\" , value1 : 8 , value2 : 2 url # => /add/8/2 # Redirect to the user to the generated url. self . redirect url # Or could have used a method that does both self . redirect_to_route \"add\" , value1 : 8 , value2 : 2 end end ART . run # GET / # => 10 See ART::URLGeneratorInterface in the API Docs for more details. Error Handling Exception handling in Athena is similar to exception handling in any Crystal program, with the addition of a new unique exception type, ART::Exceptions::HTTPException . Custom HTTP errors can also be defined by inheriting from ART::Exceptions::HTTPException or a child type. A use case for this could be allowing additional data/context to be included within the exception. Non ART::Exceptions::HTTPException exceptions are represented as a 500 Internal Server Error . When an exception is raised, Athena emits the ART::Events::Exception event to allow an opportunity for it to be handled. By default these exceptions will return a JSON serialized version of the exception, via ART::ErrorRenderer , that includes the message and code; with the proper response status set. If the exception goes unhandled, i.e. no listener sets an ART::Response . By default, non ART::Response on the event, then the request is finished and the exception is re-raised. require \"athena\" class ExampleController < ART :: Controller get \"divide/:num1/:num2\" , num1 : Int32 , num2 : Int32 , return_type : Int32 do num1 // num2 end get \"divide_rescued/:num1/:num2\" , num1 : Int32 , num2 : Int32 , return_type : Int32 do num1 // num2 # Rescue a non `ART::Exceptions::HTTPException` rescue ex : DivisionByZeroError # in order to raise an `ART::Exceptions::HTTPException` to provide a better error message to the client. raise ART :: Exceptions :: BadRequest . new \"Invalid num2: Cannot divide by zero\" end end ART . run # GET /divide/10/0 # => {\"code\":500,\"message\":\"Internal Server Error\"} # GET /divide_rescued/10/0 # => {\"code\":400,\"message\":\"Invalid num2: Cannot divide by zero\"} # GET /divide_rescued/10/10 # => 1 Logging Logging is handled via Crystal's Log module. Athena logs when a request matches a controller action, as well as any exception. This of course can be augmented with additional application specific messages. 2020 -12-06T17:20:12.334700Z INFO - Server has started and is listening at http://0.0.0.0:3000 2020 -12-06T17:20:17.163953Z INFO - athena.routing: Matched route /divide/10/0 -- uri: \"/divide/10/0\" , method: \"GET\" , path_params: { \"num2\" = > \"0\" , \"num1\" = > \"10\" } , query_params: {} 2020 -12-06T17:20:17.280199Z ERROR - athena.routing: Uncaught exception #<DivisionByZeroError:Division by 0> at ../../../../../../usr/lib/crystal/int.cr:138:7 in 'check_div_argument' Division by 0 ( DivisionByZeroError ) from ../../../../../../usr/lib/crystal/int.cr:138:7 in 'check_div_argument' from ../../../../../../usr/lib/crystal/int.cr:102:5 in '//' from src/athena.cr:151:5 in 'get_divide__num1__num2' from ../../../../../../usr/lib/crystal/primitives.cr:255:3 in 'execute' from src/route_handler.cr:80:5 in 'handle_raw' from src/route_handler.cr:14:21 in 'handle' from src/athena.cr:127:9 in '->' from ../../../../../../usr/lib/crystal/primitives.cr:255:3 in 'process' from ../../../../../../usr/lib/crystal/http/server.cr:513:5 in 'handle_client' from ../../../../../../usr/lib/crystal/http/server.cr:468:13 in '->' from ../../../../../../usr/lib/crystal/primitives.cr:255:3 in 'run' from ../../../../../../usr/lib/crystal/fiber.cr:92:34 in '->' from ??? 2020 -12-06T17:20:18.979050Z INFO - athena.routing: Matched route /divide_rescued/10/0 -- uri: \"/divide_rescued/10/0\" , method: \"GET\" , path_params: { \"num2\" = > \"0\" , \"num1\" = > \"10\" } , query_params: {} 2020 -12-06T17:20:18.980397Z WARN - athena.routing: Uncaught exception #<Athena::Routing::Exceptions::BadRequest:Invalid num2: Cannot divide by zero> at src/athena.cr:159:5 in 'get_divide_rescued__num1__num2' Invalid num2: Cannot divide by zero ( Athena::Routing::Exceptions::BadRequest ) from src/athena.cr:159:5 in 'get_divide_rescued__num1__num2' from ../../../../../../usr/lib/crystal/primitives.cr:255:3 in 'execute' from src/route_handler.cr:80:5 in 'handle_raw' from src/route_handler.cr:14:21 in 'handle' from src/athena.cr:127:9 in '->' from ../../../../../../usr/lib/crystal/primitives.cr:255:3 in 'process' from ../../../../../../usr/lib/crystal/http/server.cr:513:5 in 'handle_client' from ../../../../../../usr/lib/crystal/http/server.cr:468:13 in '->' from ../../../../../../usr/lib/crystal/primitives.cr:255:3 in 'run' from ../../../../../../usr/lib/crystal/fiber.cr:92:34 in '->' from ??? 2020 -12-06T17:20:21.993811Z INFO - athena.routing: Matched route /divide_rescued/10/10 -- uri: \"/divide_rescued/10/10\" , method: \"GET\" , path_params: { \"num2\" = > \"10\" , \"num1\" = > \"10\" } , query_params: {} Customization By default Athena utilizes the default Log::Formatter and Log::Backend s Crystal defines. This of course can be customized via interacting with Crystal's Log module. It is also possible to control what exceptions, and with what severity, exceptions will be logged by redefining the log_exception method within ART::Listeners::Error .","title":"Getting Started"},{"location":"getting_started/#installation","text":"Add the dependency to your shard.yml : dependencies : athena : github : athena-framework/athena version : ~> 0.12.0 Run shards install . This will install Athena and its required dependencies.","title":"Installation"},{"location":"getting_started/#usage","text":"Athena has a goal of being easy to start using for simple use cases, while still allowing flexibility/customizability for larger more complex use cases.","title":"Usage"},{"location":"getting_started/#routing","text":"Athena is a MVC based framework, as such, the logic to handle a given route is defined in an ART::Controller class. require \"athena\" # Define a controller class ExampleController < ART :: Controller # Define an action to handle the related route @[ ART :: Get ( \"/\" ) ] def index : String \"Hello World\" end # The macro DSL can also be used get \"/\" do \"Hello World\" end end # Run the server ART . run # GET / # => Hello World Annotations applied to the methods are used to define the HTTP method this method handles, such as ART::Get or ART::Post . A macro DSL also exists to make them a bit less verbose; ART::Controller.get or ART::Controller.post . The ART::Route annotation can also be used to define custom HTTP methods. Controllers are simply classes and routes are simply methods. Controllers and actions can be documented/tested as you would any Crystal class/method.","title":"Routing"},{"location":"getting_started/#route-parameters","text":"Arguments are converted to their expected types if possible, otherwise an error response is automatically returned. The values are provided directly as method arguments, thus preventing the need for env.params.url[\"name\"] and any boilerplate related to it. Just like normal method arguments, default values can be defined. The method's return type adds some type safety to ensure the expected value is being returned. require \"athena\" class ExampleController < ART :: Controller @[ ART :: Get ( \"/add/:value1/:value2\" ) ] def add ( value1 : Int32 , value2 : Int32 , negative : Bool = false ) : Int32 sum = value1 + value2 negative ? - sum : sum end end ART . run # GET /add/2/3 # => 5 # GET /add/5/5?negative=true # => -10 # GET /add/foo/12 # => {\"code\":400,\"message\":\"Required parameter 'value1' with value 'foo' could not be converted into a valid 'Int32'\"} ART::QueryParam and ART::RequestParam s are defined via annotations and map directly to the method's arguments. See the related annotation docs for more information. require \"athena\" class ExampleController < ART :: Controller @[ ART :: Get ( \"/\" ) ] @[ ART :: QueryParam ( \"page\" , requirements : /\\d{2}/ ) ] def index ( page : Int32 ) : Int32 page end end ART . run # GET / # => {\"code\":422,\"message\":\"Parameter 'page' of value '' violated a constraint: 'This value should not be null.'\\n\"} # GET /?page=10 # => 10 # GET /?page=bar # => {\"code\":400,\"message\":\"Required parameter 'page' with value 'bar' could not be converted into a valid 'Int32'.\"} # GET /?page=5 # => {\"code\":422,\"message\":\"Parameter 'page' of value '5' violated a constraint: 'Parameter 'page' value does not match requirements: (?-imsx:^(?-imsx:\\\\d{2})$)'\\n\"} Restricting an action argument to HTTP::Request will provide the raw request object. This approach is fine for simple or one-off endpoints, however for more complex/common request data processing, it is suggested to create a Param Converter . require \"athena\" class ExampleController < ART :: Controller @[ ART :: Post ( \"/data\" ) ] def data ( request : HTTP :: Request ) : String ? request . body . try &. gets_to_end end end ART . run # POST /data body: \"foo--bar\" # => \"foo--bar\"","title":"Route Parameters"},{"location":"getting_started/#returning-raw-data","text":"An ART::Response can be used to fully customize the response; such as returning a specific status code, adding some one-off headers. require \"athena\" require \"mime\" class ExampleController < ART :: Controller # A GET endpoint returning an `ART::Response`. # Can be used to return raw data, such as HTML or CSS etc, in a one-off manner. @[ ART :: Get ( \"/index\" ) ] def index : ART :: Response ART :: Response . new \"<h1>Welcome to my website!</h1>\" , headers : HTTP :: Headers { \"content-type\" => MIME . from_extension ( \".html\" )} end end ART . run # GET /index # => \"<h1>Welcome to my website!</h1>\" An ART::Events::View is emitted if the returned value is NOT an ART::Response . By default, non ART::Response s are JSON serialized. However, this event can be listened on to customize how the value is serialized.","title":"Returning Raw Data"},{"location":"getting_started/#streaming-response","text":"By default ART::Response content is written all at once to the response's IO . However in some cases the content may be too large to fit into memory. In this case an ART::StreamedResponse may be used to stream the content back to the client. require \"athena\" require \"mime\" class ExampleController < ART :: Controller @[ ART :: Get ( path : \"/users\" ) ] def users : ART :: Response ART :: StreamedResponse . new headers : HTTP :: Headers { \"content-type\" => \"application/json; charset=UTF-8\" } do | io | User . all . to_json io end end end ART . run # GET /athena/users\" # => [{\"id\":1,...},...]","title":"Streaming Response"},{"location":"getting_started/#url-generation","text":"A common use case, especially when rendering HTML , is generating links to other routes based on a set of provided parameters. Parameters that do not map to a controller action argument are added as query params. require \"athena\" class ExampleController < ART :: Controller # Define a route to redirect to, explicitly naming this route `add`. # The default route name is controller + method down snake-cased; e.x. `example_controller_add`. @[ ART :: Get ( \"/add/:value1/:value2\" , name : \"add\" ) ] def add ( value1 : Int32 , value2 : Int32 , negative : Bool = false ) : Int32 sum = value1 + value2 negative ? - sum : sum end # Define a route that redirects to the `add` route with fixed parameters. @[ ART :: Get ( \"/\" ) ] def redirect : ART :: RedirectResponse # Generate a link to the other route. url = self . generate_url \"add\" , value1 : 8 , value2 : 2 url # => /add/8/2 # Redirect to the user to the generated url. self . redirect url # Or could have used a method that does both self . redirect_to_route \"add\" , value1 : 8 , value2 : 2 end end ART . run # GET / # => 10 See ART::URLGeneratorInterface in the API Docs for more details.","title":"URL Generation"},{"location":"getting_started/#error-handling","text":"Exception handling in Athena is similar to exception handling in any Crystal program, with the addition of a new unique exception type, ART::Exceptions::HTTPException . Custom HTTP errors can also be defined by inheriting from ART::Exceptions::HTTPException or a child type. A use case for this could be allowing additional data/context to be included within the exception. Non ART::Exceptions::HTTPException exceptions are represented as a 500 Internal Server Error . When an exception is raised, Athena emits the ART::Events::Exception event to allow an opportunity for it to be handled. By default these exceptions will return a JSON serialized version of the exception, via ART::ErrorRenderer , that includes the message and code; with the proper response status set. If the exception goes unhandled, i.e. no listener sets an ART::Response . By default, non ART::Response on the event, then the request is finished and the exception is re-raised. require \"athena\" class ExampleController < ART :: Controller get \"divide/:num1/:num2\" , num1 : Int32 , num2 : Int32 , return_type : Int32 do num1 // num2 end get \"divide_rescued/:num1/:num2\" , num1 : Int32 , num2 : Int32 , return_type : Int32 do num1 // num2 # Rescue a non `ART::Exceptions::HTTPException` rescue ex : DivisionByZeroError # in order to raise an `ART::Exceptions::HTTPException` to provide a better error message to the client. raise ART :: Exceptions :: BadRequest . new \"Invalid num2: Cannot divide by zero\" end end ART . run # GET /divide/10/0 # => {\"code\":500,\"message\":\"Internal Server Error\"} # GET /divide_rescued/10/0 # => {\"code\":400,\"message\":\"Invalid num2: Cannot divide by zero\"} # GET /divide_rescued/10/10 # => 1","title":"Error Handling"},{"location":"getting_started/#logging","text":"Logging is handled via Crystal's Log module. Athena logs when a request matches a controller action, as well as any exception. This of course can be augmented with additional application specific messages. 2020 -12-06T17:20:12.334700Z INFO - Server has started and is listening at http://0.0.0.0:3000 2020 -12-06T17:20:17.163953Z INFO - athena.routing: Matched route /divide/10/0 -- uri: \"/divide/10/0\" , method: \"GET\" , path_params: { \"num2\" = > \"0\" , \"num1\" = > \"10\" } , query_params: {} 2020 -12-06T17:20:17.280199Z ERROR - athena.routing: Uncaught exception #<DivisionByZeroError:Division by 0> at ../../../../../../usr/lib/crystal/int.cr:138:7 in 'check_div_argument' Division by 0 ( DivisionByZeroError ) from ../../../../../../usr/lib/crystal/int.cr:138:7 in 'check_div_argument' from ../../../../../../usr/lib/crystal/int.cr:102:5 in '//' from src/athena.cr:151:5 in 'get_divide__num1__num2' from ../../../../../../usr/lib/crystal/primitives.cr:255:3 in 'execute' from src/route_handler.cr:80:5 in 'handle_raw' from src/route_handler.cr:14:21 in 'handle' from src/athena.cr:127:9 in '->' from ../../../../../../usr/lib/crystal/primitives.cr:255:3 in 'process' from ../../../../../../usr/lib/crystal/http/server.cr:513:5 in 'handle_client' from ../../../../../../usr/lib/crystal/http/server.cr:468:13 in '->' from ../../../../../../usr/lib/crystal/primitives.cr:255:3 in 'run' from ../../../../../../usr/lib/crystal/fiber.cr:92:34 in '->' from ??? 2020 -12-06T17:20:18.979050Z INFO - athena.routing: Matched route /divide_rescued/10/0 -- uri: \"/divide_rescued/10/0\" , method: \"GET\" , path_params: { \"num2\" = > \"0\" , \"num1\" = > \"10\" } , query_params: {} 2020 -12-06T17:20:18.980397Z WARN - athena.routing: Uncaught exception #<Athena::Routing::Exceptions::BadRequest:Invalid num2: Cannot divide by zero> at src/athena.cr:159:5 in 'get_divide_rescued__num1__num2' Invalid num2: Cannot divide by zero ( Athena::Routing::Exceptions::BadRequest ) from src/athena.cr:159:5 in 'get_divide_rescued__num1__num2' from ../../../../../../usr/lib/crystal/primitives.cr:255:3 in 'execute' from src/route_handler.cr:80:5 in 'handle_raw' from src/route_handler.cr:14:21 in 'handle' from src/athena.cr:127:9 in '->' from ../../../../../../usr/lib/crystal/primitives.cr:255:3 in 'process' from ../../../../../../usr/lib/crystal/http/server.cr:513:5 in 'handle_client' from ../../../../../../usr/lib/crystal/http/server.cr:468:13 in '->' from ../../../../../../usr/lib/crystal/primitives.cr:255:3 in 'run' from ../../../../../../usr/lib/crystal/fiber.cr:92:34 in '->' from ??? 2020 -12-06T17:20:21.993811Z INFO - athena.routing: Matched route /divide_rescued/10/10 -- uri: \"/divide_rescued/10/10\" , method: \"GET\" , path_params: { \"num2\" = > \"10\" , \"num1\" = > \"10\" } , query_params: {}","title":"Logging"},{"location":"getting_started/#customization","text":"By default Athena utilizes the default Log::Formatter and Log::Backend s Crystal defines. This of course can be customized via interacting with Crystal's Log module. It is also possible to control what exceptions, and with what severity, exceptions will be logged by redefining the log_exception method within ART::Listeners::Error .","title":"Customization"},{"location":"components/config/","text":"Athena includes the Athena::Config component as a means to configure an Athena application. Configuration A core part of the config component is defining a YAML based way to configure an application in the form of athena.yml . Other components and/or developers may add configuration options to ACF::Base . This utilizes YAML::Serializable , with the Strict module in order to provide type safe configuration for an application. CORS Currently the only configurable piece of Athena is ART::Config::CORS to support configuring the ART::Listeners::CORS listener. --- routing : cors : allow_credentials : true allow_origin : - https://api.myblog.com allow_methods : - GET - POST - PUT - DELETE Custom Annotations Athena integrates the Config component's ability to define custom annotation configurations. This feature allows developers to define custom annotations, and the data that should be read off of them, then apply/access the annotations on ART::Controller and/or ART::Action s. This is a powerful feature that allows for almost limitless flexibility/customization. Some ideas include: storing some value in the request attributes, raise an exception, invoke some external service; all based on the presence/absence of it, a value read off of it, or either/both of those in-conjunction with an external service. require \"athena\" # Define our configuration annotation with an optional `name` argument. # A default value can also be provided, or made not nilable to be considered required. ACF . configuration_annotation MyAnnotation , name : String ? = nil # Define and register our listener that will do something based on our annotation. @[ ADI :: Register ] class MyAnnotationListener include AED :: EventListenerInterface def self . subscribed_events : AED :: SubscribedEvents AED :: SubscribedEvents { ART :: Events :: View => 0 } end def call ( event : ART :: Events :: View , dispatcher : AED :: EventDispatcherInterface ) : Nil # Represents all custom annotations applied to the current ART::Action. ann_configs = event . request . action . annotation_configurations # Check if this action has the annotation unless ann_configs . has? MyAnnotation # Do something based on presence/absence of it. # Would be executed for `ExampleController#one` since it does not have the annotation applied. end my_ann = ann_configs [ MyAnnotation ] # Access data off the annotation. if my_ann . name == \"Fred\" # Do something if the provided name is/is not some value. # Would be executed for `ExampleController#two` since it has the annotation applied, and name value equal to \"Fred\". end end end class ExampleController < ART :: Controller @[ ART :: Get ( \"one\" ) ] def one : Int32 1 end @[ ART :: Get ( \"two\" ) ] @[ MyAnnotation ( name : \"Fred\" ) ] def two : Int32 2 end end ART . run The Cookbook includes an example of how this can be used for pagination.","title":"Config"},{"location":"components/config/#configuration","text":"A core part of the config component is defining a YAML based way to configure an application in the form of athena.yml . Other components and/or developers may add configuration options to ACF::Base . This utilizes YAML::Serializable , with the Strict module in order to provide type safe configuration for an application.","title":"Configuration"},{"location":"components/config/#cors","text":"Currently the only configurable piece of Athena is ART::Config::CORS to support configuring the ART::Listeners::CORS listener. --- routing : cors : allow_credentials : true allow_origin : - https://api.myblog.com allow_methods : - GET - POST - PUT - DELETE","title":"CORS"},{"location":"components/config/#custom-annotations","text":"Athena integrates the Config component's ability to define custom annotation configurations. This feature allows developers to define custom annotations, and the data that should be read off of them, then apply/access the annotations on ART::Controller and/or ART::Action s. This is a powerful feature that allows for almost limitless flexibility/customization. Some ideas include: storing some value in the request attributes, raise an exception, invoke some external service; all based on the presence/absence of it, a value read off of it, or either/both of those in-conjunction with an external service. require \"athena\" # Define our configuration annotation with an optional `name` argument. # A default value can also be provided, or made not nilable to be considered required. ACF . configuration_annotation MyAnnotation , name : String ? = nil # Define and register our listener that will do something based on our annotation. @[ ADI :: Register ] class MyAnnotationListener include AED :: EventListenerInterface def self . subscribed_events : AED :: SubscribedEvents AED :: SubscribedEvents { ART :: Events :: View => 0 } end def call ( event : ART :: Events :: View , dispatcher : AED :: EventDispatcherInterface ) : Nil # Represents all custom annotations applied to the current ART::Action. ann_configs = event . request . action . annotation_configurations # Check if this action has the annotation unless ann_configs . has? MyAnnotation # Do something based on presence/absence of it. # Would be executed for `ExampleController#one` since it does not have the annotation applied. end my_ann = ann_configs [ MyAnnotation ] # Access data off the annotation. if my_ann . name == \"Fred\" # Do something if the provided name is/is not some value. # Would be executed for `ExampleController#two` since it has the annotation applied, and name value equal to \"Fred\". end end end class ExampleController < ART :: Controller @[ ART :: Get ( \"one\" ) ] def one : Int32 1 end @[ ART :: Get ( \"two\" ) ] @[ MyAnnotation ( name : \"Fred\" ) ] def two : Int32 2 end end ART . run The Cookbook includes an example of how this can be used for pagination.","title":"Custom Annotations"},{"location":"components/dependency_injection/","text":"Athena utilizes the Dependency Injection (DI) component in order to provide a service container layer. DI allows controllers/other services to be decoupled from specific implementations. This also makes testing easier as test implementations of the dependencies can be used. In Athena, most everything is a service that belongs to the container, which is unique to each request. The major benefit of this is it allows various types to be shared amongst the application without having them bleed state between requests. This section is NOT an in-depth guide on what DI is, or all the features the DI component has. It is instead going to focus on high level usage and implementation specifics on how it is used within Athena itself; such how to register services and use them within other types. See the API Docs for more details. Basic Usage A type (class or struct) can be registered as a service by applying the ADI::Register annotation to it. Services can depend upon other services by creating an initializer method type to the other service. require \"athena\" # Register an example service that provides a name string. @[ ADI :: Register ] class NameProvider def name : String \"World\" end end # Register another service that depends on the previous service and provides a value. @[ ADI :: Register ] class ValueProvider def initialize ( @name_provider : NameProvider ); end def value : String \"Hello \" + @name_provider . name end end # Register a service controller that depends upon the ValueProvider. @[ ADI :: Register ( public : true ) ] class ExampleController < ART :: Controller def initialize ( @value_provider : ValueProvider ); end @[ ART :: Get ( \"/\" ) ] def get_value : String @value_provider . value end end ART . run # GET / # => \"Hello World\" Warning The \"type\" of the listener has an effect on its behavior! When a struct service is retrieved or injected into a type, it will be a copy of the one in the SC (passed by value). This means that changes made to it in one type, will NOT be reflected in other types. A class service on the other hand will be a reference to the one in the SC. This allows it to share state between services.","title":"Dependency Injection"},{"location":"components/dependency_injection/#basic-usage","text":"A type (class or struct) can be registered as a service by applying the ADI::Register annotation to it. Services can depend upon other services by creating an initializer method type to the other service. require \"athena\" # Register an example service that provides a name string. @[ ADI :: Register ] class NameProvider def name : String \"World\" end end # Register another service that depends on the previous service and provides a value. @[ ADI :: Register ] class ValueProvider def initialize ( @name_provider : NameProvider ); end def value : String \"Hello \" + @name_provider . name end end # Register a service controller that depends upon the ValueProvider. @[ ADI :: Register ( public : true ) ] class ExampleController < ART :: Controller def initialize ( @value_provider : ValueProvider ); end @[ ART :: Get ( \"/\" ) ] def get_value : String @value_provider . value end end ART . run # GET / # => \"Hello World\" Warning The \"type\" of the listener has an effect on its behavior! When a struct service is retrieved or injected into a type, it will be a copy of the one in the SC (passed by value). This means that changes made to it in one type, will NOT be reflected in other types. A class service on the other hand will be a reference to the one in the SC. This allows it to share state between services.","title":"Basic Usage"},{"location":"components/event_dispatcher/","text":"As mentiond in the architecture section, Athena is an event based framework utilizing the Event Dispatcher component. Basic Usage An event listener is defined by registering a service that includes AED::EventListenerInterface . The type should also define a self.subscribed_events method that represents what events it should be listening on. require \"athena\" @[ ADI :: Register ] class CustomListener include AED :: EventListenerInterface # Specify that we want to listen on the `Response` event. # The value of the hash represents this listener's priority; # the higher the value the sooner it gets executed. def self . subscribed_events : AED :: SubscribedEvents AED :: SubscribedEvents { ART :: Events :: Response => 25 } end def call ( event : ART :: Events :: Response , dispatcher : AED :: EventDispatcherInterface ) : Nil event . response . headers [ \"FOO\" ] = \"BAR\" end end class ExampleController < ART :: Controller get \"/\" do \"Hello World\" end end ART . run # GET / # => Hello World (with `FOO => BAR` header) Tip A single event listener may listen on multiple events. Instance variables can be used to share state between the events. Custom Events Custom events can also be defined and dispatched; either within a listener, or in another service by injecting AED::EventDispatcherInterface and calling #dispatch . require \"athena\" # Define a custom event class MyEvent < AED :: Event property value : Int32 def initialize ( @value : Int32 ); end end # Define a listener that listens our the custom event. @[ ADI :: Register ] class CustomEventListener include AED :: EventListenerInterface def self . subscribed_events : AED :: SubscribedEvents AED :: SubscribedEvents { MyEvent => 0 } end def call ( event : MyEvent , dispatcher : AED :: EventDispatcherInterface ) : Nil event . value *= 10 end end # Register a controller as a service, # injecting the event dispatcher to handle processing our value. @[ ADI :: Register ( public : true ) ] class ExampleController < ART :: Controller def initialize ( @event_dispatcher : AED :: EventDispatcherInterface ); end @[ ART :: Get ( \"/:value\" ) ] def get_value ( value : Int32 ) : Int32 event = MyEvent . new value @event_dispatcher . dispatch event event . value end end ART . run # GET /10 # => 100","title":"Event Dispatcher"},{"location":"components/event_dispatcher/#basic-usage","text":"An event listener is defined by registering a service that includes AED::EventListenerInterface . The type should also define a self.subscribed_events method that represents what events it should be listening on. require \"athena\" @[ ADI :: Register ] class CustomListener include AED :: EventListenerInterface # Specify that we want to listen on the `Response` event. # The value of the hash represents this listener's priority; # the higher the value the sooner it gets executed. def self . subscribed_events : AED :: SubscribedEvents AED :: SubscribedEvents { ART :: Events :: Response => 25 } end def call ( event : ART :: Events :: Response , dispatcher : AED :: EventDispatcherInterface ) : Nil event . response . headers [ \"FOO\" ] = \"BAR\" end end class ExampleController < ART :: Controller get \"/\" do \"Hello World\" end end ART . run # GET / # => Hello World (with `FOO => BAR` header) Tip A single event listener may listen on multiple events. Instance variables can be used to share state between the events.","title":"Basic Usage"},{"location":"components/event_dispatcher/#custom-events","text":"Custom events can also be defined and dispatched; either within a listener, or in another service by injecting AED::EventDispatcherInterface and calling #dispatch . require \"athena\" # Define a custom event class MyEvent < AED :: Event property value : Int32 def initialize ( @value : Int32 ); end end # Define a listener that listens our the custom event. @[ ADI :: Register ] class CustomEventListener include AED :: EventListenerInterface def self . subscribed_events : AED :: SubscribedEvents AED :: SubscribedEvents { MyEvent => 0 } end def call ( event : MyEvent , dispatcher : AED :: EventDispatcherInterface ) : Nil event . value *= 10 end end # Register a controller as a service, # injecting the event dispatcher to handle processing our value. @[ ADI :: Register ( public : true ) ] class ExampleController < ART :: Controller def initialize ( @event_dispatcher : AED :: EventDispatcherInterface ); end @[ ART :: Get ( \"/:value\" ) ] def get_value ( value : Int32 ) : Int32 event = MyEvent . new value @event_dispatcher . dispatch event event . value end end ART . run # GET /10 # => 100","title":"Custom Events"},{"location":"components/serializer/","text":"The Serializer component adds enhanced (de)serialization features. This component is mostly optional, but is integrated into the default view layer of Athena. When an ASR::Serializable is returned from a controller action, that object will be serialized via the serializer component, as opposed to Crystal's standard libraries' #to_json method. Info If an object implements both ASR::Serializable and JSON::Serializable , the serializer component takes priority. The ART::View annotation can be used to configure serialization related options on a per route basis. require \"athena\" class Article include ASR :: Serializable # Assume this is defined via an ORM def self . find ( id : Int32 ) new id , \"Crystal Lang 101\" end # These properties are exposed since they are either implicitly or expliticly a part of the `default` group. getter id : Int32 getter name : String @[ ASR :: Groups ( \"default\" ) ] property ? published : Bool = false # This property is not exposed since it is not part of the `default` group. @[ ASR :: Groups ( \"detailed\" ) ] getter body : String = \"BODY\" def initialize ( @id : Int32 , @name : String ); end end class ArticleController < ART :: Controller @[ ART :: Post ( path : \"/publish/:id\" ) ] @[ ART :: View ( status : :accepted , serialization_groups : [ \"default\" ] ) ] def publish ( id : Int32 ) : Article article = Article . find id article . published = true article end end ART . run # POST /publish/10 # => {\"id\":10,\"name\":\"Crystal Lang 101\",\"published\":true} - 202 See the API Docs for more detailed information, or this forum post for a quick overview.","title":"Serializer"},{"location":"components/spec/","text":"Athena strongly suggests following the SOLID design principles; especially the Dependency inversion principle in order to create types that are easy to test. See the Dependency Injection component for a more detailed look. If these principles are followed then any controller/service can easily be unit tested on their own as you would any Crystal type, possibly utilizing ASPEC::TestCase to provide helpful abstractions around common testing/helper logic for sets of common types. However, Athena also comes bundled with ART::Spec::APITestCase to allow for easily creating integration tests for ART::Controller s; which is the more ideal way to test a controller. require \"athena\" require \"athena/spec\" class ExampleController < ART :: Controller @[ ART :: QueryParam ( \"negative\" ) ] @[ ART :: Get ( \"/add/:value1/:value2\" ) ] def add ( value1 : Int32 , value2 : Int32 , negative : Bool = false ) : Int32 sum = value1 + value2 negative ? - sum : sum end end struct ExampleControllerTest < ART :: Spec :: APITestCase def test_add_positive : Nil self . request ( \"GET\" , \"/add/5/3\" ) . body . should eq \"8\" end def test_add_negative : Nil self . request ( \"GET\" , \"/add/5/3?negative=true\" ) . body . should eq \"-8\" end end # Run all test case tests. ASPEC . run_all Integration tests allow testing the full system, including event listeners, param converters, etc at once. These tests do not utilize an HTTP::Server which results in more performant specs.","title":"Spec"},{"location":"components/validator/","text":"The Validator component adds a robust/flexible validation framework. This component is also mostly optional, but can be super helpful as part of a param converter to ensure only valid data make it into the system. The Cookbook has an example of how this could be implemented. This component can also be used to define validation requirements for ART::Params::ParamInterface s. Custom Constraints In addition to the general information for defining Custom Constraints , the validator component defines a specific type for defining service based constraint validators: AVD::ServiceConstraintValidator . This type should be inherited from instead of AVD::ConstraintValidator IF the validator for your custom constraint needs to be a service, E.x. class Athena::Validator::Constraints:: CustomConstraint < AVD :: Constraint # ... @[ ADI :: Register ] struct Validator < AVD :: ServiceConstraintValidator def initialize ( ... ); end # :inherit: def validate ( value : _ , constraint : AVD :: Constraints :: CustomConstraint ) : Nil # ... end end end See the API Docs documentation for more detailed information, or this forum post for a quick overview.","title":"Validator"},{"location":"components/validator/#custom-constraints","text":"In addition to the general information for defining Custom Constraints , the validator component defines a specific type for defining service based constraint validators: AVD::ServiceConstraintValidator . This type should be inherited from instead of AVD::ConstraintValidator IF the validator for your custom constraint needs to be a service, E.x. class Athena::Validator::Constraints:: CustomConstraint < AVD :: Constraint # ... @[ ADI :: Register ] struct Validator < AVD :: ServiceConstraintValidator def initialize ( ... ); end # :inherit: def validate ( value : _ , constraint : AVD :: Constraints :: CustomConstraint ) : Nil # ... end end end See the API Docs documentation for more detailed information, or this forum post for a quick overview.","title":"Custom Constraints"},{"location":"cookbook/exclusion_strategies/","text":"Exclusion Strategies allow defining custom runtime logic that controls which properties should be (de)serialized. Request Method In a web framework, being able to exclude a property based on the request method can be a handy tool. I.e. imagine having IgnoreOnUpdate , IgnoreOnCreate , and IgnoreOnRead annotations to specify how a specific property should behave as part of a PUT , POST , and GET request respectively. For example, allow a property to be set when an object is created, a POST request, but prevent it from being altered when it is updated, a PUT request. # Define and register our exclusion strategy @[ ADI :: Register ] struct IgnoreOnMethodExclusionStrategy include Athena :: Serializer :: ExclusionStrategies :: ExclusionStrategyInterface # Inject the `ART::RequestStore` in order to have access # to the current request, and its method. def initialize ( @request_store : ART :: RequestStore ); end # :inherit: def skip_property? ( metadata : ASR :: PropertyMetadataBase , context : ASR :: Context ) : Bool # Don't skip if there isn't a request, such as a non web request context. return false unless requst_method = @request_store . request? . try &. method # Determine the annotation that should be read off the property. annotation_class = case requst_method when \"POST\" then IgnoreOnCreate when \"PUT\" then IgnoreOnUpdate when \"GET\" then IgnoreOnRead else return false end # Skip the property if it has the corresponding annotation. metadata . annotation_configurations . has? annotation_class end end # Define a custom serializer that is aliased to the `SerializerInterface`. # This tells DI to inject this type when the interface is encountered. # # This step is mainly to globally enable our exclusion strategy. # An alternate solution would be to have some global context factory # method that would return a new `ART::Context` object with or without # the exclusion strategy applied to it that could be provided to the default serializer. # # This implementation was also chosen to demonstrate how default services can be extended by wrapping # them in customer logic. In the future the Decorator pattern could also be added to the DI component. @[ ADI :: Register ( alias : Athena :: Serializer :: SerializerInterface ) ] struct CustomSerializer include ASR :: SerializerInterface # Inject the default serializer and our custom exclusion strategy. def initialize ( @serializer : Athena :: Serializer :: Serializer , @ignore_on_method_exclusion_strategy : IgnoreOnMethodExclusionStrategy ); end # :inherit: # # For each method a part of the `SerializerInterface`, add our strategy to the context, # then call the default serializer with the modified context. def deserialize ( type : _ , input_data : String | IO , format : ASR :: Format | String , context : ASR :: DeserializationContext = ASR :: DeserializationContext . new ) context . add_exclusion_strategy @ignore_on_method_exclusion_strategy @serializer . deserialize type , input_data , format , context end # :inherit: def serialize ( data : _ , format : ASR :: Format | String , context : ASR :: SerializationContext = ASR :: SerializationContext . new , ** named_args ) : String context . add_exclusion_strategy @ignore_on_method_exclusion_strategy @serializer . serialize data , format , context end # :inherit: def serialize ( data : _ , format : ASR :: Format | String , io : IO , context : ASR :: SerializationContext = ASR :: SerializationContext . new , ** named_args ) : Nil context . add_exclusion_strategy @ignore_on_method_exclusion_strategy @serializer . serialize data , format , io , context end end # Register our `IgnoreOn*` annotations as configuration annotations. ACF . configuration_annotation IgnoreOnCreate ACF . configuration_annotation IgnoreOnUpdate ACF . configuration_annotation IgnoreOnRead # Define a type to test with. record Article , id : Int32 , author_id : Int32 = 100 do include ASR :: Serializable @[ IgnoreOnCreate ] @author_id : Int32 end # Register our controller as a service, # be sure to define it as public. @[ ADI :: Register ( public : true ) ] class ExampleController < ART :: Controller # Inject the serializer into the controller to test with. # # I'm using a controller because it's simpler, but this would # most likely be a part of an `ART::ParamConverterInterface`. def initialize ( @serializer : ASR :: SerializerInterface ); end @[ ART :: Post ( \"/article\" ) ] def new_article ( request : HTTP :: Request ) : Article @serializer . deserialize Article , request . body . not_nil! , :json end @[ ART :: Put ( \"/article\" ) ] def update_article ( request : HTTP :: Request ) : Article @serializer . deserialize Article , request . body . not_nil! , :json end end # Run the server ART . run # POST /article body: {\"id\":1,\"author_id\":2} # => {\"id\":1,\"author_id\":100} # PUT /article body: {\"id\":1,\"author_id\":2} # => {\"id\":1,\"author_id\":2} Since we marked author_id as IgnoreOnCreate , the default value is used during the POST /article request, while the user provided value is used for the PUT /article request. A similar concept could also be applied to allow for ACL based exclusions. I.e. exclude properties if the current user doesn't have the required roles/permissions to view it.","title":"Exclusion Strategies"},{"location":"cookbook/exclusion_strategies/#request-method","text":"In a web framework, being able to exclude a property based on the request method can be a handy tool. I.e. imagine having IgnoreOnUpdate , IgnoreOnCreate , and IgnoreOnRead annotations to specify how a specific property should behave as part of a PUT , POST , and GET request respectively. For example, allow a property to be set when an object is created, a POST request, but prevent it from being altered when it is updated, a PUT request. # Define and register our exclusion strategy @[ ADI :: Register ] struct IgnoreOnMethodExclusionStrategy include Athena :: Serializer :: ExclusionStrategies :: ExclusionStrategyInterface # Inject the `ART::RequestStore` in order to have access # to the current request, and its method. def initialize ( @request_store : ART :: RequestStore ); end # :inherit: def skip_property? ( metadata : ASR :: PropertyMetadataBase , context : ASR :: Context ) : Bool # Don't skip if there isn't a request, such as a non web request context. return false unless requst_method = @request_store . request? . try &. method # Determine the annotation that should be read off the property. annotation_class = case requst_method when \"POST\" then IgnoreOnCreate when \"PUT\" then IgnoreOnUpdate when \"GET\" then IgnoreOnRead else return false end # Skip the property if it has the corresponding annotation. metadata . annotation_configurations . has? annotation_class end end # Define a custom serializer that is aliased to the `SerializerInterface`. # This tells DI to inject this type when the interface is encountered. # # This step is mainly to globally enable our exclusion strategy. # An alternate solution would be to have some global context factory # method that would return a new `ART::Context` object with or without # the exclusion strategy applied to it that could be provided to the default serializer. # # This implementation was also chosen to demonstrate how default services can be extended by wrapping # them in customer logic. In the future the Decorator pattern could also be added to the DI component. @[ ADI :: Register ( alias : Athena :: Serializer :: SerializerInterface ) ] struct CustomSerializer include ASR :: SerializerInterface # Inject the default serializer and our custom exclusion strategy. def initialize ( @serializer : Athena :: Serializer :: Serializer , @ignore_on_method_exclusion_strategy : IgnoreOnMethodExclusionStrategy ); end # :inherit: # # For each method a part of the `SerializerInterface`, add our strategy to the context, # then call the default serializer with the modified context. def deserialize ( type : _ , input_data : String | IO , format : ASR :: Format | String , context : ASR :: DeserializationContext = ASR :: DeserializationContext . new ) context . add_exclusion_strategy @ignore_on_method_exclusion_strategy @serializer . deserialize type , input_data , format , context end # :inherit: def serialize ( data : _ , format : ASR :: Format | String , context : ASR :: SerializationContext = ASR :: SerializationContext . new , ** named_args ) : String context . add_exclusion_strategy @ignore_on_method_exclusion_strategy @serializer . serialize data , format , context end # :inherit: def serialize ( data : _ , format : ASR :: Format | String , io : IO , context : ASR :: SerializationContext = ASR :: SerializationContext . new , ** named_args ) : Nil context . add_exclusion_strategy @ignore_on_method_exclusion_strategy @serializer . serialize data , format , io , context end end # Register our `IgnoreOn*` annotations as configuration annotations. ACF . configuration_annotation IgnoreOnCreate ACF . configuration_annotation IgnoreOnUpdate ACF . configuration_annotation IgnoreOnRead # Define a type to test with. record Article , id : Int32 , author_id : Int32 = 100 do include ASR :: Serializable @[ IgnoreOnCreate ] @author_id : Int32 end # Register our controller as a service, # be sure to define it as public. @[ ADI :: Register ( public : true ) ] class ExampleController < ART :: Controller # Inject the serializer into the controller to test with. # # I'm using a controller because it's simpler, but this would # most likely be a part of an `ART::ParamConverterInterface`. def initialize ( @serializer : ASR :: SerializerInterface ); end @[ ART :: Post ( \"/article\" ) ] def new_article ( request : HTTP :: Request ) : Article @serializer . deserialize Article , request . body . not_nil! , :json end @[ ART :: Put ( \"/article\" ) ] def update_article ( request : HTTP :: Request ) : Article @serializer . deserialize Article , request . body . not_nil! , :json end end # Run the server ART . run # POST /article body: {\"id\":1,\"author_id\":2} # => {\"id\":1,\"author_id\":100} # PUT /article body: {\"id\":1,\"author_id\":2} # => {\"id\":1,\"author_id\":2} Since we marked author_id as IgnoreOnCreate , the default value is used during the POST /article request, while the user provided value is used for the PUT /article request. A similar concept could also be applied to allow for ACL based exclusions. I.e. exclude properties if the current user doesn't have the required roles/permissions to view it.","title":"Request Method"},{"location":"cookbook/listeners/","text":"Event Listeners are a core part of Athena's architecture that allows tapping into specific events within the life-cycle of each request. Custom events can also be defined, dispatched, and listened upon. See the related EventDispatcher component for more information. JWT Security Currently Athena does not have any built in abstractions related to authentication or authorization. This feature is planned and will be implemented at some point in the future. Until then however, we can define a security listener that implements our authentication logic via listening on the action event which includes a reference to the original HTTP::Request object. # Define and register a listener to handle authenticating requests. @[ ADI :: Register ] struct SecurityListener include AED :: EventListenerInterface def self . subscribed_events : AED :: SubscribedEvents AED :: SubscribedEvents { # Specify that we want to listen on the request event # with slightly higher priority just because ART :: Events :: Request => 10 , } end # Define a `#call` method scoped to the `Request` event. def call ( event : ART :: Events :: Request , _dispatcher : AED :: EventDispatcherInterface ) : Nil # Don't execute the listener logic for endpoints that we consider to be public. # Again this'll eventually be handled by the security related abstractions. if event . request . method == \"POST\" && { \"/user\" , \"/login\" } . includes? event . request . path return end # Return a 401 error if the token is missing or malformed raise ART :: Exceptions :: Unauthorized . new \"Missing bearer token\" , \"Bearer realm= \\\" My App \\\" \" unless ( auth_header = event . request . headers . get? ( \"authorization\" ) . try &. first ) && auth_header . starts_with? \"Bearer \" # Get the JWT token from the Bearer header token = auth_header . lchop \"Bearer \" begin # Validate the token using the `crystal-community/jwt` shard. body = JWT . decode token , ENV [ \"SECRET\" ] , :hs512 rescue decode_error : JWT :: DecodeError # Throw a 401 error if the JWT token is invalid raise ART :: Exceptions :: Unauthorized . new \"Invalid token\" , \"Bearer realm= \\\" My App \\\" \" end end end At this point any request that is not \"public\" will invoke our listener that ensures the request has a valid JWT Bearer token. From here we can go a step further and define a service that can be used to hold a reference to the current user, such that it could be accessed within other controllers, listeners, or services. @[ ADI :: Register ] class UserStorage # Use a `!` to define both nilable and not nilable getters. # Assume that you have a `User` object that represents a user within your application. property ! user : User end We can then inject this service into our security listener to set the current user. @[ ADI :: Register ] struct SecurityListener ... # Define our initializer for DI to inject the user storage. def initialize ( @user_storage : UserStorage ); end # Define a `#call` method scoped to the `Request` event. def call ( event : ART :: Events :: Request , _dispatcher : AED :: EventDispatcherInterface ) : Nil ... # Set the user in user storage, looking it up from the DB # based on a `user_id` claim within the JWT token. @user_storage . user = User . find body [ 0 ][ \"user_id\" ] end end From here, it would be up to the developer to implement a way to authorize the user now that they have been authenticated and are accessible within the application. One option could be to utilize the Custom Annotations as a means to \"tag\" controller actions with specific \"levels\" of security; then add another #call method to the security listener to listen on the action event which exposes the ART::Action related to the current request from which the annotations could be read off of. Page This example is a modified version of the one used as part of the JSON API Blog Tutorial blog post. Pagination Generic pagination can be implemented via listening on the view event which exposes the value returned via the related controller action. We can then define a Paginated Custom Annotation that can be applied to controller actions to have them be paginated via the listener. # Define our configuration annotation with the default pagination values. # These values can be overridden on a per endpoint basis. ACF . configuration_annotation Paginated , page : UInt32 = 1 , per_page : UInt32 = 100 , max_per_page : UInt32 = 1000 # Define and register our listener that will handle paginating the response. @[ ADI :: Register ] struct PaginationListener include AED :: EventListenerInterface private PAGE_QUERY_PARAM = \"page\" private PER_PAGE_QUERY_PARAM = \"per_page\" def self . subscribed_events : AED :: SubscribedEvents AED :: SubscribedEvents { # We want this to run before anything else so that # future listeners are working with the paginated data. ART :: Events :: View => 255 , } end def call ( event : ART :: Events :: View , dispatcher : AED :: EventDispatcherInterface ) : Nil # Return if the endpoint is not paginated. return unless ( pagination = event . request . action . annotation_configurations [ Paginated ]? ) # Return if the action result is not able to be paginated. return unless ( action_result = event . action_result ) . is_a? Indexable request = event . request # Determine pagination values; first checking the request's query parameters, # using the default values in the `Paginated` object if not provided. page = request . query_params [ PAGE_QUERY_PARAM ]?. try &. to_i || pagination . page per_page = request . query_params [ PER_PAGE_QUERY_PARAM ]?. try &. to_i || pagination . per_page # Raise an exception if `per_page` is higher than the max. raise ART :: Exceptions :: BadRequest . new \"Query param 'per_page' should be ' #{ pagination . max_per_page } ' or less.\" if per_page > pagination . max_per_page # Paginate the resulting data. # In the future a more robust pagination service could be injected # that could handle types other than `Indexable`, such as # ORM `Collection` objects. end_index = page * per_page start_index = end_index - per_page # Paginate and set the action's result. event . action_result = action_result [ start_index ... end_index ] end end class ExampleController < ART :: Controller @[ ART :: Get ( \"values\" ) ] @[ Paginated ( per_page : 2 ) ] def get_values : Array ( Int32 ) ( 1 .. 10 ) . to_a end end ART . run # GET /values # => [1, 2] # GET /values?page=2 # => [3, 4] # GET /values?per_page=3 # => [1, 2, 3] # GET /values?per_page=3&page=2 # => [4, 5, 6]","title":"Listeners"},{"location":"cookbook/listeners/#jwt-security","text":"Currently Athena does not have any built in abstractions related to authentication or authorization. This feature is planned and will be implemented at some point in the future. Until then however, we can define a security listener that implements our authentication logic via listening on the action event which includes a reference to the original HTTP::Request object. # Define and register a listener to handle authenticating requests. @[ ADI :: Register ] struct SecurityListener include AED :: EventListenerInterface def self . subscribed_events : AED :: SubscribedEvents AED :: SubscribedEvents { # Specify that we want to listen on the request event # with slightly higher priority just because ART :: Events :: Request => 10 , } end # Define a `#call` method scoped to the `Request` event. def call ( event : ART :: Events :: Request , _dispatcher : AED :: EventDispatcherInterface ) : Nil # Don't execute the listener logic for endpoints that we consider to be public. # Again this'll eventually be handled by the security related abstractions. if event . request . method == \"POST\" && { \"/user\" , \"/login\" } . includes? event . request . path return end # Return a 401 error if the token is missing or malformed raise ART :: Exceptions :: Unauthorized . new \"Missing bearer token\" , \"Bearer realm= \\\" My App \\\" \" unless ( auth_header = event . request . headers . get? ( \"authorization\" ) . try &. first ) && auth_header . starts_with? \"Bearer \" # Get the JWT token from the Bearer header token = auth_header . lchop \"Bearer \" begin # Validate the token using the `crystal-community/jwt` shard. body = JWT . decode token , ENV [ \"SECRET\" ] , :hs512 rescue decode_error : JWT :: DecodeError # Throw a 401 error if the JWT token is invalid raise ART :: Exceptions :: Unauthorized . new \"Invalid token\" , \"Bearer realm= \\\" My App \\\" \" end end end At this point any request that is not \"public\" will invoke our listener that ensures the request has a valid JWT Bearer token. From here we can go a step further and define a service that can be used to hold a reference to the current user, such that it could be accessed within other controllers, listeners, or services. @[ ADI :: Register ] class UserStorage # Use a `!` to define both nilable and not nilable getters. # Assume that you have a `User` object that represents a user within your application. property ! user : User end We can then inject this service into our security listener to set the current user. @[ ADI :: Register ] struct SecurityListener ... # Define our initializer for DI to inject the user storage. def initialize ( @user_storage : UserStorage ); end # Define a `#call` method scoped to the `Request` event. def call ( event : ART :: Events :: Request , _dispatcher : AED :: EventDispatcherInterface ) : Nil ... # Set the user in user storage, looking it up from the DB # based on a `user_id` claim within the JWT token. @user_storage . user = User . find body [ 0 ][ \"user_id\" ] end end From here, it would be up to the developer to implement a way to authorize the user now that they have been authenticated and are accessible within the application. One option could be to utilize the Custom Annotations as a means to \"tag\" controller actions with specific \"levels\" of security; then add another #call method to the security listener to listen on the action event which exposes the ART::Action related to the current request from which the annotations could be read off of. Page This example is a modified version of the one used as part of the JSON API Blog Tutorial blog post.","title":"JWT Security"},{"location":"cookbook/listeners/#pagination","text":"Generic pagination can be implemented via listening on the view event which exposes the value returned via the related controller action. We can then define a Paginated Custom Annotation that can be applied to controller actions to have them be paginated via the listener. # Define our configuration annotation with the default pagination values. # These values can be overridden on a per endpoint basis. ACF . configuration_annotation Paginated , page : UInt32 = 1 , per_page : UInt32 = 100 , max_per_page : UInt32 = 1000 # Define and register our listener that will handle paginating the response. @[ ADI :: Register ] struct PaginationListener include AED :: EventListenerInterface private PAGE_QUERY_PARAM = \"page\" private PER_PAGE_QUERY_PARAM = \"per_page\" def self . subscribed_events : AED :: SubscribedEvents AED :: SubscribedEvents { # We want this to run before anything else so that # future listeners are working with the paginated data. ART :: Events :: View => 255 , } end def call ( event : ART :: Events :: View , dispatcher : AED :: EventDispatcherInterface ) : Nil # Return if the endpoint is not paginated. return unless ( pagination = event . request . action . annotation_configurations [ Paginated ]? ) # Return if the action result is not able to be paginated. return unless ( action_result = event . action_result ) . is_a? Indexable request = event . request # Determine pagination values; first checking the request's query parameters, # using the default values in the `Paginated` object if not provided. page = request . query_params [ PAGE_QUERY_PARAM ]?. try &. to_i || pagination . page per_page = request . query_params [ PER_PAGE_QUERY_PARAM ]?. try &. to_i || pagination . per_page # Raise an exception if `per_page` is higher than the max. raise ART :: Exceptions :: BadRequest . new \"Query param 'per_page' should be ' #{ pagination . max_per_page } ' or less.\" if per_page > pagination . max_per_page # Paginate the resulting data. # In the future a more robust pagination service could be injected # that could handle types other than `Indexable`, such as # ORM `Collection` objects. end_index = page * per_page start_index = end_index - per_page # Paginate and set the action's result. event . action_result = action_result [ start_index ... end_index ] end end class ExampleController < ART :: Controller @[ ART :: Get ( \"values\" ) ] @[ Paginated ( per_page : 2 ) ] def get_values : Array ( Int32 ) ( 1 .. 10 ) . to_a end end ART . run # GET /values # => [1, 2] # GET /values?page=2 # => [3, 4] # GET /values?per_page=3 # => [1, 2, 3] # GET /values?per_page=3&page=2 # => [4, 5, 6]","title":"Pagination"},{"location":"cookbook/param_converters/","text":"Param Converters allow applying custom logic in order to convert one or more primitive request parameter into a more complex type. DB In a REST API, endpoints usually contain a reference to the id of the object in question; e.x. GET /user/10 . A useful converter would be able to extract this ID from the path, lookup the related entity, and provide that object directly to the controller action. This reduces the boilerplate associated with doing a DB lookup within every controller action. It also makes testing easier as it abstract the logic of how that object is resolved from what should be done to it. NOTE: This examples uses the Granite ORM, but should work with others. # Define an register our param converter as a service. @[ ADI :: Register ] struct DBConverter < ART :: ParamConverterInterface # Define a customer configuration for this converter. # This allows us to provide a `entity` field within the annotation # in order to define _what_ entity should be queried for. configuration entity : Granite :: Base . class # :inherit: # # Be sure to handle any possible exceptions here to return more helpful errors to the client. def apply ( request : HTTP :: Request , configuration : Configuration ) : Nil # Grab the `id` path parameter from the request's attributes as an Int32. primary_key = request . attributes . get \"id\" , Int32 # Raise a `404` error if a record with the provided ID does not exist. # This assumes there is a `.find` method on the related entity class. raise ART :: Exceptions :: NotFound . new \"An item with the provided ID could not be found\" unless entity = configuration . entity . find primary_key # Set the resolved entity within the request's attributes # with a key matching the name of the argument within the converter annotation. request . attributes . set configuration . name , model , configuration . entity end end class Article < Granite :: Base connection \"default\" table \"articles\" column id : Int64 , primary : true column title : String end @[ ART :: Prefix ( \"article\" ) ] class ExampleController < ART :: Controller @[ ART :: Get ( \"/:id\" ) ] @[ ART :: ParamConverter ( \"article\" , converter : DBConverter , entity : Article ) ] def get_article ( article : Article ) : Article # Nothing else to do except return the releated article. article end end # Run the server ART . run # GET /article/1 # => {\"id\":1,\"title\":\"Article A\"} # GET /article/5 # => {\"id\":5,\"title\":\"Article E\"} # GET /article/-123 # => {\"code\":404,\"message\":\"An item with the provided ID could not be found.\"} Tada. We now testable, reusable logic to provide database objects directly as arguments to our controller action. Since the entity class is specified on the annotation, the actual converter can be reused for multiple actions and multiple entity classes. Request Body Similar to the DB converter, another common practice is deserializing a request's body into an object. NOTE: This examples uses the Granite ORM, but should work with others. # Define an register our param converter as a service. @[ ADI :: Register ] struct RequestBody < ART :: ParamConverterInterface # Define a customer configuration for this converter. # This allows us to provide a `entity` field within the annotation # in order to define _what_ entity should be queried for. configuration entity : Granite :: Base . class # Inject the serializer and validator into our converter. def initialize ( @serializer : ASR :: SerializerInterface , @validator : AVD :: Validator :: ValidatorInterface , ); end # :inherit: def apply ( request : HTTP :: Request , configuration : Configuration ) : Nil # Be sure to handle any possible exceptions here to return more helpful errors to the client. raise ART :: Exceptions :: BadRequest . new \"Request body is empty.\" unless body = request . body # Deserialize the object, based on the type provided in the annotation. object = @serializer . deserialize configuration . entity , body , :json # Validate the object if it is validatable. if object . is_a? AVD :: Validatable errors = @validator . validate object raise AVD :: Exceptions :: ValidationFailed . new errors unless errors . empty? end # Add the resolved object to the request's attributes. request . attributes . set configuration . name , object , configuration . entity end end # Make the compiler happy when we want to allow any Granite entity to be deserializable. class Granite:: Base include ASR :: Model end class Article < Granite :: Base connection \"default\" table \"articles\" column id : Int64 , primary : true column title : String end @[ ART :: Prefix ( \"article\" ) ] class ExampleController < ART :: Controller @[ ART :: Post ( path : \"\" ) ] @[ ART :: View ( status : :created ) ] @[ ART :: ParamConverter ( \"article\" , converter : RequestBody , model : Article ) ] def new_article ( article : Article ) : Article # Since we have an actual `Article` instance, we can simply save and return the article. article . save article end end We can now easily save new entities, and be assured they are valid by running validations as well within our converter. However what about updating an entity? The Serializer component has the concept of Object Constructors that determine how a new object is constructed during deserialization. This feature allows updated values to be applied to an existing object as opposed to either needing to create a whole new object from the request data or manually handle applying those changes. # Define a custom `ASR::ObjectConstructorInterface` to allow sourcing the model from the database # as part of `PUT` requests, and if the type is a `Granite::Base`. # # Alias our service to `ASR::ObjectConstructorInterface` so ours gets injected instead. @[ ADI :: Register ( alias : ASR :: ObjectConstructorInterface ) ] class DBObjectConstructor include Athena :: Serializer :: ObjectConstructorInterface # Inject `ART::RequestStore` in order to have access to the current request. # Also inject `ASR::InstantiateObjectConstructor` to act as our fallback constructor. def initialize ( @request_store : ART :: RequestStore , @fallback_constructor : ASR :: InstantiateObjectConstructor ); end # :inherit: def construct ( navigator : ASR :: Navigators :: DeserializationNavigatorInterface , properties : Array ( ASR :: PropertyMetadataBase ), data : ASR :: Any , type ) # Fallback on the default object constructor if the type is not a `Granite` model. unless type <= Granite :: Base return @fallback_constructor . construct navigator , properties , data , type end # Fallback on the default object constructor if the current request is not a `PUT`. unless @request_store . request . method == \"PUT\" return @fallback_constructor . construct navigator , properties , data , type end # Lookup the object from the database; assume the object has an `id` property. entity = type . find data [ \"id\" ]. as_i64 # Return a `404` error if no record exists with the given ID. raise ART :: Exceptions :: NotFound . new \"An item with the provided ID could not be found.\" unless entity # Apply the updated properties to the retrieved record entity . apply navigator , properties , data # Return the entity entity end end The Validator component could also be injected into the param converter to run validations after deserialzing an object.","title":"Param Converters"},{"location":"cookbook/param_converters/#db","text":"In a REST API, endpoints usually contain a reference to the id of the object in question; e.x. GET /user/10 . A useful converter would be able to extract this ID from the path, lookup the related entity, and provide that object directly to the controller action. This reduces the boilerplate associated with doing a DB lookup within every controller action. It also makes testing easier as it abstract the logic of how that object is resolved from what should be done to it. NOTE: This examples uses the Granite ORM, but should work with others. # Define an register our param converter as a service. @[ ADI :: Register ] struct DBConverter < ART :: ParamConverterInterface # Define a customer configuration for this converter. # This allows us to provide a `entity` field within the annotation # in order to define _what_ entity should be queried for. configuration entity : Granite :: Base . class # :inherit: # # Be sure to handle any possible exceptions here to return more helpful errors to the client. def apply ( request : HTTP :: Request , configuration : Configuration ) : Nil # Grab the `id` path parameter from the request's attributes as an Int32. primary_key = request . attributes . get \"id\" , Int32 # Raise a `404` error if a record with the provided ID does not exist. # This assumes there is a `.find` method on the related entity class. raise ART :: Exceptions :: NotFound . new \"An item with the provided ID could not be found\" unless entity = configuration . entity . find primary_key # Set the resolved entity within the request's attributes # with a key matching the name of the argument within the converter annotation. request . attributes . set configuration . name , model , configuration . entity end end class Article < Granite :: Base connection \"default\" table \"articles\" column id : Int64 , primary : true column title : String end @[ ART :: Prefix ( \"article\" ) ] class ExampleController < ART :: Controller @[ ART :: Get ( \"/:id\" ) ] @[ ART :: ParamConverter ( \"article\" , converter : DBConverter , entity : Article ) ] def get_article ( article : Article ) : Article # Nothing else to do except return the releated article. article end end # Run the server ART . run # GET /article/1 # => {\"id\":1,\"title\":\"Article A\"} # GET /article/5 # => {\"id\":5,\"title\":\"Article E\"} # GET /article/-123 # => {\"code\":404,\"message\":\"An item with the provided ID could not be found.\"} Tada. We now testable, reusable logic to provide database objects directly as arguments to our controller action. Since the entity class is specified on the annotation, the actual converter can be reused for multiple actions and multiple entity classes.","title":"DB"},{"location":"cookbook/param_converters/#request-body","text":"Similar to the DB converter, another common practice is deserializing a request's body into an object. NOTE: This examples uses the Granite ORM, but should work with others. # Define an register our param converter as a service. @[ ADI :: Register ] struct RequestBody < ART :: ParamConverterInterface # Define a customer configuration for this converter. # This allows us to provide a `entity` field within the annotation # in order to define _what_ entity should be queried for. configuration entity : Granite :: Base . class # Inject the serializer and validator into our converter. def initialize ( @serializer : ASR :: SerializerInterface , @validator : AVD :: Validator :: ValidatorInterface , ); end # :inherit: def apply ( request : HTTP :: Request , configuration : Configuration ) : Nil # Be sure to handle any possible exceptions here to return more helpful errors to the client. raise ART :: Exceptions :: BadRequest . new \"Request body is empty.\" unless body = request . body # Deserialize the object, based on the type provided in the annotation. object = @serializer . deserialize configuration . entity , body , :json # Validate the object if it is validatable. if object . is_a? AVD :: Validatable errors = @validator . validate object raise AVD :: Exceptions :: ValidationFailed . new errors unless errors . empty? end # Add the resolved object to the request's attributes. request . attributes . set configuration . name , object , configuration . entity end end # Make the compiler happy when we want to allow any Granite entity to be deserializable. class Granite:: Base include ASR :: Model end class Article < Granite :: Base connection \"default\" table \"articles\" column id : Int64 , primary : true column title : String end @[ ART :: Prefix ( \"article\" ) ] class ExampleController < ART :: Controller @[ ART :: Post ( path : \"\" ) ] @[ ART :: View ( status : :created ) ] @[ ART :: ParamConverter ( \"article\" , converter : RequestBody , model : Article ) ] def new_article ( article : Article ) : Article # Since we have an actual `Article` instance, we can simply save and return the article. article . save article end end We can now easily save new entities, and be assured they are valid by running validations as well within our converter. However what about updating an entity? The Serializer component has the concept of Object Constructors that determine how a new object is constructed during deserialization. This feature allows updated values to be applied to an existing object as opposed to either needing to create a whole new object from the request data or manually handle applying those changes. # Define a custom `ASR::ObjectConstructorInterface` to allow sourcing the model from the database # as part of `PUT` requests, and if the type is a `Granite::Base`. # # Alias our service to `ASR::ObjectConstructorInterface` so ours gets injected instead. @[ ADI :: Register ( alias : ASR :: ObjectConstructorInterface ) ] class DBObjectConstructor include Athena :: Serializer :: ObjectConstructorInterface # Inject `ART::RequestStore` in order to have access to the current request. # Also inject `ASR::InstantiateObjectConstructor` to act as our fallback constructor. def initialize ( @request_store : ART :: RequestStore , @fallback_constructor : ASR :: InstantiateObjectConstructor ); end # :inherit: def construct ( navigator : ASR :: Navigators :: DeserializationNavigatorInterface , properties : Array ( ASR :: PropertyMetadataBase ), data : ASR :: Any , type ) # Fallback on the default object constructor if the type is not a `Granite` model. unless type <= Granite :: Base return @fallback_constructor . construct navigator , properties , data , type end # Fallback on the default object constructor if the current request is not a `PUT`. unless @request_store . request . method == \"PUT\" return @fallback_constructor . construct navigator , properties , data , type end # Lookup the object from the database; assume the object has an `id` property. entity = type . find data [ \"id\" ]. as_i64 # Return a `404` error if no record exists with the given ID. raise ART :: Exceptions :: NotFound . new \"An item with the provided ID could not be found.\" unless entity # Apply the updated properties to the retrieved record entity . apply navigator , properties , data # Return the entity entity end end The Validator component could also be injected into the param converter to run validations after deserialzing an object.","title":"Request Body"},{"location":"getting_started/advanced_usage/","text":"Athena also ships with some more advanced features to provide more flexibility/control for an application. These features may not be required for a simple application; however as the application grows they may become more useful. Param Converters ART::ParamConverterInterface s allow complex types to be supplied to an action via its arguments. An example of this could be extracting the id from /users/10 , doing a DB query to lookup the user with the PK of 10 , then providing the full user object to the action. Param converters abstract any custom parameter handling that would otherwise have to be done in each action. require \"athena\" @[ ADI :: Register ] struct MultiplyConverter < ART :: ParamConverterInterface # :inherit: def apply ( request : HTTP :: Request , configuration : Configuration ) : Nil arg_name = configuration . name return unless request . attributes . has? arg_name value = request . attributes . get arg_name , Int32 request . attributes . set arg_name , value * 2 , Int32 end end class ParamConverterController < ART :: Controller @[ ART :: Get ( path : \"/multiply/:num\" ) ] @[ ART :: ParamConverter ( \"num\" , converter : MultiplyConverter ) ] def multiply ( num : Int32 ) : Int32 num end end ART . run # GET / multiply/3 # => 6 Middleware Athena is an event based framework; meaning it emits ART::Events that are acted upon internally to handle the request. These same events can also be listened on by custom listeners, via AED::EventListenerInterface , in order to tap into the life-cycle of the request as a more flexible alternative to HTTP::Handler s. An example use case of this could be: adding common headers, cookies, compressing the response, authentication, or even returning a response early like ART::Listeners::CORS . See the Event Dispatcher component for a more detailed look. Custom Annotations User defined annotations may also be used to allow for more advanced logic; such as for Pagination or Rate limiting logic. Custom annotations can be applied to a controller class and/or controller action method. These annotations can then be accessed, including the data defined on them, within event listeners or anywhere the current request's ART::Action is exposed. See the Config component for a more detailed look. Testing Each component in the Athena Framework includes a Spec module that includes common/helpful testing utilities/types for testing that specific component. Athena itself defines some of its own testing types, mainly to allow for easisly integration testing ART::Controller s. See the Spec component for a more detailed look.","title":"Advanced Usage"},{"location":"getting_started/advanced_usage/#param-converters","text":"ART::ParamConverterInterface s allow complex types to be supplied to an action via its arguments. An example of this could be extracting the id from /users/10 , doing a DB query to lookup the user with the PK of 10 , then providing the full user object to the action. Param converters abstract any custom parameter handling that would otherwise have to be done in each action. require \"athena\" @[ ADI :: Register ] struct MultiplyConverter < ART :: ParamConverterInterface # :inherit: def apply ( request : HTTP :: Request , configuration : Configuration ) : Nil arg_name = configuration . name return unless request . attributes . has? arg_name value = request . attributes . get arg_name , Int32 request . attributes . set arg_name , value * 2 , Int32 end end class ParamConverterController < ART :: Controller @[ ART :: Get ( path : \"/multiply/:num\" ) ] @[ ART :: ParamConverter ( \"num\" , converter : MultiplyConverter ) ] def multiply ( num : Int32 ) : Int32 num end end ART . run # GET / multiply/3 # => 6","title":"Param Converters"},{"location":"getting_started/advanced_usage/#middleware","text":"Athena is an event based framework; meaning it emits ART::Events that are acted upon internally to handle the request. These same events can also be listened on by custom listeners, via AED::EventListenerInterface , in order to tap into the life-cycle of the request as a more flexible alternative to HTTP::Handler s. An example use case of this could be: adding common headers, cookies, compressing the response, authentication, or even returning a response early like ART::Listeners::CORS . See the Event Dispatcher component for a more detailed look.","title":"Middleware"},{"location":"getting_started/advanced_usage/#custom-annotations","text":"User defined annotations may also be used to allow for more advanced logic; such as for Pagination or Rate limiting logic. Custom annotations can be applied to a controller class and/or controller action method. These annotations can then be accessed, including the data defined on them, within event listeners or anywhere the current request's ART::Action is exposed. See the Config component for a more detailed look.","title":"Custom Annotations"},{"location":"getting_started/advanced_usage/#testing","text":"Each component in the Athena Framework includes a Spec module that includes common/helpful testing utilities/types for testing that specific component. Athena itself defines some of its own testing types, mainly to allow for easisly integration testing ART::Controller s. See the Spec component for a more detailed look.","title":"Testing"}]}